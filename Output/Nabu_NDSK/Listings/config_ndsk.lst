              	; --------------------------------------
              	; zasm: assemble "config_ndsk.asm"
              	; date: 2023-06-22 20:21:25
              	; --------------------------------------


              	;
              	;**************************************************************
              	;*
              	;*          I S H K U R   S Y S T E M   C O N F I G
              	;*
              	;*      This file contains points that should be modifed
              	;*      if new devices are to be added to IshkurCP/M. At
              	;*      a mimumum, they need to be included at the bottom
              	;*      of the file, and added to their appropriate dev
              	;*      switch. Some devices may need additional config
              	;*      directly in their source files
              	;*       
              	;*
              	;**************************************************************
              	;
              	;   Set default drive / user
              	;   (uuuudddd) where 'uuuu' is the user number and 'dddd' is the drive number.
              	;
0000:         	default	equ	0
              	
              	;
              	;**************************************************************
              	;*
              	;*                M E M O R Y   C O N F I G
              	;*
              	;*        CP/M memory will start at mem*1024. For example,
              	;*        if memory is configured to be 40, then the image
              	;*        will start at 40kb. The higher memory is configured
              	;*        to, the more memory user programs will have. If memory
              	;*        is configured to be too high, then the core image and
              	;*        BSS space will not fit.
              	;*
              	;**************************************************************
              	;
              	;
              	;   Set memory base here. 
              	;
0037:         	mem	equ	55		; CP/M image starts at mem*1024
              	
              	
              	
              	#target	BIN			; Set up memory segments
DC00:         	#code	_TEXT,(mem)*1024
FAC5:         	#data	_BSS,_TEXT_end
FF00:         	#data	_JUMP_TABLE,0xFF00
FF00: 00000000	intvec:	defs	16
FF04: 00...   	
FF10: 00000000	dircbuf:defs	128
FF14: 00...   	
              	.area	_TEXT
              	
              	; Include CP/M and BIOS
              	#include "../zcpr1_ccp.asm"
              	;**************************************************************
              	;*
              	;*         Z C P R 1   C O M M A N D   P R O C E S S O R
              	;*
              	;*          Adapted to work with Ishkur by snhirsch
              	;*
              	;**************************************************************
              	
0003:         	iobyte	equ	3		;i/o definition byte.
0004:         	tdrive	equ	4		;current drive name and user number.
0004:         	UDFLAG  equ     4
0005:         	entry	equ	5		;entry point for the cp/m bdos.
0005:         	BDOS    equ     5
005C:         	tfcb	equ	5ch		;default file control block.
005C:         	TFCB    equ     5ch
0080:         	TBUFF   equ     80h
0080:         	tbuff	equ	80h		;i/o buffer and command line storage.
0100:         	tbase	equ	100h		;transiant program storage area.
              	;
              	;   set control character equates.
              	;
0003:         	cntrlc	equ	3		;control-c
0005:         	cntrle	equ	05h		;control-e
0008:         	bs	equ	08h		;backspace
0009:         	tab	equ	09h		;tab
000A:         	lf	equ	0ah		;line feed
000C:         	ff	equ	0ch		;form feed
000D:         	cr	equ	0dh		;carriage return
0010:         	cntrlp	equ	10h		;control-p
0012:         	cntrlr	equ	12h		;control-r
0013:         	cntrls	equ	13h		;control-s
0015:         	cntrlu	equ	15h		;control-u
0018:         	cntrlx	equ	18h		;control-x
001A:         	cntrlz	equ	1ah		;control-z (end-of-file mark)
007F:         	del	equ	7fh		;rubout
              	
              	;================================================================
              	
              	;	.Z80
              	;	TITLE	'NZCPR V 1.6Z OF 01/07/84'
              	;  This is ZCPR Version 1.6 changed to Zilog mnemonics and put in a
              	;form suitable for the Microsoft M80 assembler. Note that the file uses
              	;the PHASE option to create the memory offset. The COM file should be 
              	;created using L80 with the /P:100 switch option. The COM file can be
              	;loaded into the sysgen program using the methods described in the ZCPR
              	;documentation.
              	;		MMA - Murray Arnow
              	;
              	;  CP/M Z80 Command Processor Replacement (CPR) Version 1.6 in
              	; the NZCPR line.
              	;
              	;	CCPZ CREATED AND CUSTOMIZED FOR ARIES-II BY RLC
              	;	ZCPR VERSION 1.0 CREATED FROM CCPZ VERSION 4.0 BY RLC IN
              	;		A COORDINATED EFFORT WITH CCP-GROUP
              	;
              	;	ZCPR is a group effort by CCP-GROUP, whose active membership involved
              	; in this project consists of the following:
              	;		RLC - Richard Conn
              	;		RGF - Ron Fowler
              	;		KBP - Keith Peterson
              	;		FJW - Frank Wancho
              	;	The following individuals also provided a contribution:
              	;		SBB - Steve Bogolub
              	;
              	;  Since RLC has decided that ZCPR V1.0 is the last official version
              	; sanctioned by the CCPZ group, changes beyond that point are being
              	; called by consensus of a group of new changers "NZCPR Vx.x". The
              	; following individuals have put in their code or opinions:
              	;
              	;		SBB - Steve Bogolub
              	;		PST - Paul Traina
              	;		HLB - Howard Booker
              	;		CAF - Chuck Forsberg
              	;		RAF - Bob Fischer
              	;		BB  - Ben Bronson
              	;		PRG - Paul Grupp
              	;		PJH - Paul Homchick
              	;		HEW - Hal Walchli
              	;
              	;   In an attempt to maintain a link to the past, changes between the
              	; current version of NZCPR are provided as both a difference file
              	; between NZCPR's (NZ14-16.DIF) and as a difference between the current
              	; version and the "official" ZCPR V1.0 (NZCPR-16.DIF).  These changes
              	; are made and supported by individuals in contact with each other through
              	; the Hyde Park RCPM in Chicago. Make comments or complaints there, to
              	; SBB or PST or anyone else interested.
              	;
              	;   The most obvious differences between NZCPR and ZCPR are the security
              	; features, controlled by additional conditional assembly flags. Such
              	; features restrict access to ZCPR intrinsic commands, add additional
              	; levels of .COM file searching, and prevent access to higher drives
              	; or user levels, with either internal or external password control of
              	; these features. Less obvious differences involve code optimization to
              	; gain space, and some minor bug fixes in the TYPE command.
              	;
              	;******** Structure Notes ********
              	;
              	;	This CPR is divided into a number of major sections.  The following
              	; is an outline of these sections and the names of the major routines
              	; located therein.
              	;
              	; Section	Function/Routines
              	; -------	-----------------
              	;
              	;   --		Opening Comments, Equates, and Macro Definitions
              	;
              	;    0		JMP Table into CPR
              	;
              	;    1		Buffers
              	;
              	;    2		CPR Starting Modules
              	;			CPR1	CPR	RESTRT	RSTCPR	RCPRNL
              	;			PRNNF	CMDTBL
              	;
              	;    3		Utilities
              	;			CRLF	CONOUT	CONIN	LCOUT	LSTOUT
              	;			READF	READ	BDOSB	PRINTC	PRINT
              	;			GETDRV	DEFDMA	DMASET	RESET	BDOSJP
              	;			LOGIN	OPENF	OPEN	GRBDOS	CLOSE
              	;			SEARF	SEAR1	SEARN	SUBKIL	DELETE
              	;			RESETUSR GETUSR	SETUSR	PAGER	UCASE
              	;			NOECHO
              	;
              	;     4		CPR Utilities
              	;			SETUD	SETU0D	REDBUF	CNVBUF	CMDSER
              	;			BREAK	USRNUM	ERROR	SDELM	ADVAN
              	;			SBLANK	ADDAH	NUMBER	NUMERR	HEXNUM
              	;			DIRPTR	SLOGIN	DLOGIN	COMLOG	SCANER
              	;
              	;     5		CPR-Resident Commands and Functions
              	;     5A		DIR	DIRPR	FILLQ
              	;     5B		ERA
              	;     5C		LIST
              	;     5D		TYPE
              	;     5E		SAVE
              	;     5F		REN
              	;     5G		USER
              	;     5H		DFU
              	;     5I		JUMP
              	;     5J		GO
              	;     5K		COM	CALLPROG	ERRLOG	ERRJMP
              	;     5L		GET	MEMLOAD	PRNLE
              	;     5M		PASS	NORM
              	;
              	;
0000:         	FALSE	EQU	0
00FF:         	TRUE	EQU	0FFh
              	;
              	;  CUSTOMIZATION EQUATES
              	;
              	;  The following equates may be used to customize this CPR for the user's
              	;    system and integration technique.  The following constants are provided:
              	;
              	;    REL - TRUE if integration is to be done via MOVCPM
              	;        - FALSE if integration is to be done via DDT and SYSGEN
              	;
              	;    SECURE -  TRUE to conditionally disable potentially-harmful
              	;	       commands (GO, ERA, SAVE, REN, DFU, GET, JUMP). Under
              	;	       SECURE, if WHEEL contains RESTRCT, do not accept those
              	;	       commands, and search for COM files under current user
              	;	       then user "DEFUSR" only. If WHEEL does not contain
              	;	       RESTRCT (presumably from passworded change), allow
              	;	       all commands, and search current user, then last user
              	;	       set by DFU (originally "RESUSR"), then user "DEFUSR"
              	;	       for COM files, giving access with password to an
              	;	       additional level of COM files.
              	;
              	;	       (Note: WHEEL must point to a safe place in memory that
              	;		won't be overlayed)
              	;
              	;	If you have chosen a SECURE system,  all resident commands may be
              	; activated by entering:  PASS <password> <cr>  Where <password> is a sequence
              	; of characters placed at PASSID (if INPASS is true, otherwise, see
              	; documentation in PST's PASS.ASM).  If the password is incorrect. the system
              	; will come back with PASS? as if it was looking for a COM file.
              	;	NORM is the reverse of PASS, it will disable the WHEEL mode.
              	;
              	;    INPASS -  If in the SECURE mode, you wish to use a program similar
              	;	       to PST's PASS.ASM, set this false, otherwise, ZCPR will
              	;	       handle the PASSword coding with a built in command.
              	;
              	;    DRUSER -  Set this EQU false if you wish to disable RAF's neat hack
              	;	       that allows you the type B: 7 to move to drive B: user area
              	;	       seven.  This also removes the USER command.  Basically, set
              	;	       this equate false if you want to use USERPW or some other pgm.
              	;
              	;    RAS    -  Remote-Access System; setting this equate to TRUE disables
              	;	       certain CPR commands that are considered harmful in a Remote-
              	;	       Access environment; use under Remote-Access Systems (RBBS) for
              	;	       security purposes.  Note: SECURE is the direct enemy of RAS,
              	;	       DON'T define both equates or you will be VERY sorry.
              	;	       The advantage SECURE has over RAS is that by saying a magic
              	;	       word, all of the normal commands pop into existance.
              	;
              	;    MAXDRIV - Maximum legal drive number stored in this location.
              	;	       (0 means only A:, etc.)  0000H disables this feature.
              	;	       The value MAXDR is stuffed into MAXDRIV at cold boot,
              	;	       and presumably will be changed later by a passworded
              	;	       program if desired.
              	;
              	;	       (This code is in addition to BIOS checks. It's needed here
              	;	       because X: can hang if X: is off line in some BIOS
              	;	       implementations. Personally, I think CAF and others should fix
              	;	       their BIOS instead. Mine works right...SBB).
              	;
              	;    USRMAX -  Maximum legal user # + 1 stored in this location. 0000H
              	;	       disables this feature, and uses the value of MAXUSR+1 instead.
              	;
              	;    BASE - Base Address of user's CP/M system (normally 0 for DR version)
              	;           This equate allows easy modification by non-standard CP/M (eg,H89)
              	;
              	;    CPRLOC - Base Page Address of CPR; this value can be obtained by running
              	;	      the BDOSLOC program on your system, or by setting the
              	;	      MSIZE and BIOSEX equates to the system memory size in
              	;	      K-bytes and the "extra" memory required by your BIOS
              	;	      in K-bytes. BIOSEX is zero if your BIOS is normal size,
              	;	      and can be negative if your BIOS is in PROM or in
              	;	      non-contiguous memory.
              	;
              	;    EPRMPT - Set TRUE to be prompted "OK?" after seeing what files will
              	;	      be erased. No, this is NOT for individual file prompting,
              	;	      it is just to confirm deletion of all selected files at once.
              	;
              	;  Various individuals keep trying to yank out the TYPE, LIST, and DIR
              	; commands, either to use the space for other options or just because
              	; they prefer replacement COM files. To these individuals, I (SBB) say
              	; keep your paws off these commands. For compatibility with the stock
              	; CCP, intrinsic DIR and TYPE commands are required. And many users in
              	; MY neighborhood find it more convenient to use the intrinsic LIST
              	; command than to have a LIST/PRINT program on every disk. If you want
              	; to call a transient program by an intrinsic, then CHANGE THE INTRINSIC
              	; NAME IN THE TABLE. Even setting the name to blanks is fine to get
              	; rid of it. The point is, don't remove features others may want, just
              	; because you disagree, then throw it back in our laps. For those who
              	; simply MUST be rid of these commands, the following symbols control
              	; generation of the code in a CLEAN ACCEPTABLE fashion that allows
              	; others to have these features:
              	;
              	;    CPRTYP -	Set to TRUE to generate code for intrinsic TYPE command.
              	;
              	;    WSTYPE -	Set to TRUE to generate an extra three lines of code
              	;		to correctly interpret the WordStar (tm) internal
              	;		end of line hyphen for display, which is the ASCII
              	;		NEWLINE code (1FH) and normally non-printing or
              	;		troublemaking -- thanks to PJH for this one. CPRTYP
              	;		must be TRUE, or this symbol will be ignored.
              	;
              	;    CPRLST -	Set to TRUE to generate code for intrinsic LIST command.
              	;		Since almost all of the LIST code is common to the
              	;		TYPE code, CPRTYP must be set TRUE as well, or this
              	;		symbol will be ignored.
              	;
              	;    CPRDIR -	Set to TRUE to generate code for intrinsic DIR command.
              	;		Note that unlike the various directory programs, a
              	;		restricted DIR command here allows displaying the names
              	;		of SYS file ONLY, so many RCPM operators WANT this code.
              	;
              	;  Remember, you only get a total of 2048 (0800H) bytes of space for
              	; ALL of the generated code, or many other areas of your system
              	; generation will be affected. For example, to be fully SECURE, you
              	; would set SECURE to TRUE, and define MAXDRIV and USRMAX, and maybe
              	; use the internal password by setting INPASS to TRUE (external is
              	; MUCH recommended for easier modification). Those options absolutely
              	; generate too much code unless either CPRTYP or CPRDIR or both are
              	; set FALSE. A system with SECURE set to FALSE is right on the edge,
              	; and requires a give and take on options to fit, i.e. you can have
              	; MAXDRIV and USRMAX with DIR and TYPE if you leave out LIST and
              	; querying on ERASE, and so on.
              	;
              	;***************************************************************************
              	;** Be careful when playing with different combinations of these equates. **
              	;** You might not have enough memory to some combinations.  Check this    **
              	;** if you have problems, if they still persist, gripe to me (PST).       **
              	;***************************************************************************
              	;
              	;REL	EQU	TRUE		;SET TO TRUE FOR MOVCPM INTEGRATION
              	;
              	;BASE	EQU	0		;BASE OF CP/M SYSTEM (SET FOR STANDARD CP/M)
              	;
              	;; 	IF	REL
              	;; CPRLOC	EQU	0		;MOVCPM IMAGE
              	;; 	ELSE
              	;; ;
              	;; ; If REL is FALSE, the value of CPRLOC may be set in one
              	;; ; of two ways.  The first way is to set MSIZE and BIOSEX
              	;; ; as described above using the following three lines:
              	;; ;
              	;; ;MSIZE	EQU	56		;SIZE OF MEM IN K-BYTES
              	;; ;BIOSEX	EQU	2		;EXTRA # K-BYTES IN BIOS
              	;; ;CPRLOC	EQU	3400H+(MSIZE-20-BIOSEX)*1024	;CPR ORIGIN
              	;; ;
              	;; ; The second way is to obtain the origin of your current
              	;; ; CPR using BDSLOC or its equivalent, then merely set CPRLOC
              	;; ; to that value as in the following line:
              	;; ;
              	;; CPRLOC	EQU	0C400H		;FILL IN WITH BDOSLOC SUPPLIED VALUE
              	;; ;
              	;; ; Note that you should only use one method or the other.
              	;; ; Do NOT define CPRLOC twice!
              	;; ;
              	;; ; The following gives the required offset to load the CPR into the
              	;; ; CP/M SYSGEN Image through DDT (the Roffset command); Note that this
              	;; ; value conforms with the standard value presented in the CP/M reference
              	;; ; manuals, but it may not necessarily conform with the location of the
              	;; ; CCP in YOUR CP/M system; several systems (Morrow Designs, P&T, Heath
              	;; ; Org-0 to name a few) have the CCP located at a non-standard address in
              	;; ; the SYSGEN Image
              	;; ;
              	;; CPRR	EQU	0E00H-CPRLOC	;DDT LOAD OFFSET FOR APPLE SOFTCARD 56K
              	;; ;CPRR	EQU	0980H-CPRLOC	;DDT LOAD OFFSET
              	;; ;CPRR	EQU	1600H-CPRLOC	;DDT LOAD OFFSET FOR COMPUPRO DISK-1
              	;; ;CPRR	EQU	1100H-CPRLOC	;DDT LOAD OFFSET FOR MORROW DESIGNS
              	;; 	ENDIF
              	;
0000:         	RAS	EQU	FALSE		;SET TO TRUE IF CPR IS FOR A REMOTE-ACCESS
              					; SYSTEM AND YOU DON'T WANT TO RUN SECURE
              					; (FOO...)
              	;
0000:         	USRMAX	EQU	0000H		;LOCATION OF BYTE IN MEMORY CONTAINING
              					; NUMBER OF HIGHEST ALLOWABLE USER CODE + 1
              					; THIS VALUE IS SET BY CPR ON COLD BOOT,
              					; AND PRESUMABLY CONTROLLED AFTER THAT
              					; BY A PASSWORD PROGRAM. IF USRMAX=0, THEN
              					; MAXUSR BELOW IS USED FOR CHECKING ONLY.
              					; 03FH IS RECOMMENDED IF USED  ***
000F:         	MAXUSR	EQU	15		;MAX ALLOWED USER NUMBER, THIS + 1 IS STUFFED
              					; INTO USRMAX ON COLD BOOT, OR USED DIRECTLY
              					; IF USRMAX=0
              	;
0000:         	MAXDRIV	EQU	0000H		;LOCATION THAT HAS MAX LEGAL DRIVE #
              					;SET IT TO ZERO TO DISABLE THIS CHECK
              					;03DH IS RECOMMENDED IF USED ***
0001:         	MAXDR	EQU	1		;MAX DRIVE # TO SET INTO MAXDRIV ON COLD BOOT
              	;
0000:         	SECURE	EQU	FALSE		;SET TRUE FOR SECURE ENVIRONMENT...
              	;
0000:         	DEFUSR	EQU	0		;DEFAULT USER FOR UNRESTRICTED COM FILES
              	;
              		IF	SECURE
              	WHEEL	EQU	3EH		;SET TO "RESTRCT" FOR LIMITED ACCESS
              	RESTRCT EQU	0		;WHEN (WHEEL)==RESTRCT, LIMIT COMMANDS
              	RESUSR	EQU	15		;CHECK HERE FOR RESTRICTED ACCESS COM FILES
              					; (LIKE PIP) UNTIL CHANGED BY DFU OR WARM BOOT
              		ENDIF			;SECURE
              	;
0000:         	INPASS	EQU	FALSE		;SET TRUE IF RUNNING SECURE AND NOT PASS.COM
              	;
00FF:         	DRUSER	EQU	TRUE		;TRUE TO ALLOW USER COMMAND AND DRIVE/USER HACK
              	;
0000:         	EPRMPT	EQU	FALSE		;TRUE TO PROMPT BEFORE ERASING ALL FILES
              	;
00FF:         	CPRTYP	EQU	TRUE		;TRUE TO GENERATE TYPE CODE
00FF:         	WSTYPE	EQU	TRUE		;TRUE TO GENERATE WORDSTAR HYPHEN CHECK (CPRTYP
              					; MUST BE TRUE TOO)
00FF:         	CPRLST	EQU	TRUE		;TRUE TO GENERATE LIST CODE (CPRTYP MUST BETRUE TOO)
00FF:         	CPRDIR	EQU	TRUE		;TRUE TO GENERATE DIR CODE
              	;
              	;  ***  Note to Apple Softcard Users  ***
              	;
              	;  In their infinite (?) wisdom (???), Microsoft decided that the way to
              	; get a two-column directory display instead of four-column (narrow 40-col
              	; screen, remember) was to have their BIOS poke CCP every time it was
              	; loaded, if there was no terminal interface card in I/O slot 3.
              	; Naturally, that will turn into a random poke on any non-standard
              	; CCP, like this one.  The best way to get this CPR up on the Apple is to
              	; load it into CPM56.COM, at location 0E00H in the image.  The BIOS code
              	; that pokes the CPR can also be modified at that time.  The poke is done
              	; by "STA 0C8B2H", found at 24FEH in the CPM56 image.  To keep this
              	; feature, change the 0C8B2H address in that instruction by hand to
              	; the value generated for the symbol TWOPOK in the DIR routine.  If
              	; you have assembled out the DIR code by setting CPRDIR to FALSE, then
              	; disable this feature by changing the "STA" to "LDA", i.e. set the
              	; contents of location 24FEH from 32H to 3AH. If you wish to force
              	; a two-column display in all cases, set the TWOCOL switch below to a
              	; value of TRUE, and disable the poke.
              	;
0000:         	TWOCOL	EQU	FALSE		;TRUE IF TWO COL DIR INSTEAD OF FOUR
              	;
              	; The following is presented as an option, but is not generally user-customiz-
              	; able.  A basic design choice had to be made in the design of ZCPR concerning
              	; the execution of SUBMIT files.  The original CCP had a problem in this sense
              	; in that it ALWAYS looked for the SUBMIT file from drive A: and the SUBMIT
              	; program itself (SUBMIT.COM) would place the $$$.SUB file on the currently
              	; logged-in drive, so when the user was logged into B: and he issued a SUBMIT
              	; command, the $$$.SUB was placed on B: and did not execute because the CCP
              	; looked for it on A: and never found it.
              	;
              	;	After much debate it was decided to have ZCPR perform the same type of
              	; function as CCP (look for the $$$.SUB file on A:), but the problem with
              	; SUBMIT.COM still exists.  Hence, RGF designed SuperSUB and RLC took his
              	; SuperSUB and designed SUB from it; both programs are set up to allow the
              	; selection at assembly time of creating the $$$.SUB on the logged-in drive
              	; or on drive A:.
              	;
              	;	A final definition of the Indirect Command File ($$$.SUB or SUBMIT
              	; File) is presented as follows:
              	;
              	;		"An Indirect Command File is one which contains
              	;		 a series of commands exactly as they would be
              	;		 entered from a CP/M Console.  The SUBMIT Command
              	;		 (or SUB Command) reads this files and transforms
              	;		 it for processing by the ZCPR (the $$$.SUB File).
              	;		 ZCPR will then execute the commands indicated
              	;		 EXACTLY as if they were typed at the Console."
              	;
              	;	Hence, to permit this to happen, the $$$.SUB file must always
              	; be present on a specific drive, and A: is the choice for said drive.
              	; With this facility engaged as such, Indirect Command Files like:
              	;
              	;		DIR
              	;		A:
              	;		DIR
              	;
              	; can be executed, even though the currently logged-in drive is changed
              	; during execution.  If the $$$.SUB file was present on the currently
              	; logged-in drive, the above series of commands would not work since the
              	; ZCPR would be looking for $$$.SUB on the logged-in drive, and switching
              	; logged-in drives without moving the $$$.SUB file as well would cause
              	; processing to abort.
              	;
00FF:         	SUBA	EQU	TRUE 		;Set to TRUE to have $$$.SUB always on A:
              					;Set to FALSE to have $$$.SUB on the
              					; logged-in drive
              	;
              	;   The following flag enables extended processing for user-program supplied
              	; command lines.  This is for Command Level 3 of ZCPR.  Under the current
              	; ZCPR philosophy, three command levels exist:
              	;
              	;	(1) that command issued by the user from his console at the '>' prompt
              	;	(2) that command issued by a $$$.SUB file at the '$' prompt
              	;	(3) that command issued by a user program by placing the command into
              	;	    CIBUFF and setting the character count in CBUFF
              	;
              	;   Setting CLEVEL3 to TRUE enables extended processing of the third level of
              	; ZCPR command.  All the user program need do is to store the command line and
              	; set the character count; ZCPR will initialize the pointers properly, store
              	; the ending zero properly, and capitalize the command line for processing.
              	; Once the command line is properly stored, the user executes the command line
              	; by reentering the ZCPR through CPRLOC [NOTE:  The C register MUST contain
              	; a valid User/Disk Flag (see location 4) at this time.]
              	;
00FF:         	CLEVEL3	EQU	TRUE		;ENABLE COMMAND LEVEL 3 PROCESSING
              	;
              	;
              	;*** TERMINAL AND 'TYPE' CUSTOMIZATION EQUATES
              	;
0018:         	NLINES	EQU	24		;NUMBER OF LINES ON CRT SCREEN
00FF:         	WIDE	EQU	TRUE		;TRUE IF WIDE DIR DISPLAY
007C:         	FENCE	EQU	'|'		;SEP CHAR BETWEEN DIR FILES
              	;
0000:         	PGDFLT	EQU	FALSE 		;SET TO FALSE TO DISABLE PAGING BY DEFAULT
0050:         	PGDFLG	EQU	'P'		;FOR TYPE COMMAND: PAGE OR NOT (DEP ON PGDFLT)
              					;  THIS FLAG REVERSES THE DEFAULT EFFECT
              	;
0041:         	SYSFLG	EQU	'A' 		;FOR DIR COMMAND: LIST $SYS AND $DIR
              	;
0053:         	SOFLG	EQU	'S'		;FOR DIR COMMAND: LIST $SYS FILES ONLY
              	;
0000:         	SUPRES	EQU	FALSE		;SUPRESSES USER # REPORT FOR USER 0
              	;
0024:         	SPRMPT	EQU	'$'		;CPR PROMPT INDICATING SUBMIT COMMAND
003E:         	CPRMPT	EQU	'>'		;CPR PROMPT INDICATING USER COMMAND
              	;
0048:         	NUMBASE	EQU	'H'		;CHARACTER USED TO SWITCH FROM DEFAULT
              					; NUMBER BASE
              	;
0053:         	SECTFLG	EQU	'S'		;OPTION CHAR FOR SAVE COMMAND TO SAVE SECTORS
              	;
              	; END OF CUSTOMIZATION SECTION
              	;
000D:         	CR	EQU	0DH
000A:         	LF	EQU	0AH
0009:         	TAB	EQU	09H
000C:         	FFEED	EQU	0CH
0007:         	BEL	EQU	07H
              	;
              	;; WBOOT	EQU	BASE+0000H		;CP/M WARM BOOT ADDRESS
              	;; UDFLAG	EQU	BASE+0004H		;USER NUM IN HIGH NYBBLE, DISK IN LOW
              	;; BDOS	EQU	BASE+0005H		;BDOS FUNCTION CALL ENTRY PT
              	;; TFCB	EQU	BASE+005CH		;DEFAULT FCB BUFFER
              	;; TBUFF	EQU	BASE+0080H		;DEFAULT DISK I/O BUFFER
              	;; TPA	EQU	BASE+0100H		;BASE OF TPA
              	
0100:         	TPA    EQU     100H
              	
              	;
              	;**** Section 0 ****
              	;
              	;	ORG	0100H
              	;	.PHASE	CPRLOC
              	;
              	;  ENTRY POINTS INTO ZCPR
              	;
              	;    If the ZCPR is entered at location CPRLOC (at the JMP to CPR), then
              	; the default command in CIBUFF will be processed.  If the ZCPR is entered
              	; at location CPRLOC+3 (at the JMP to CPR1), then the default command in
              	; CIBUFF will NOT be processed.
              	;
              	;    NOTE:  Entry into ZCPR in this way is permitted under this version,
              	; but in order for this to work, CIBUFF and CBUFF MUST be initialized properly
              	; AND the C register MUST contain a valid User/Disk Flag (see Location 4: the
              	; most significant nybble contains the User Number and the least significant
              	; nybble contains the Disk Number).
              	;
              	;    Some user programs (such as SYNONYM3) attempt to use the default
              	; command facility.  Under the original CCP, it was necessary to initialize
              	; the pointer after the reserved space for the command buffer to point to
              	; the first byte of the command buffer.  Under current versions, this is
              	; no longer the case.  The CIBPTR (Command Input Buffer PoinTeR) is located
              	; to be compatible with such programs (provided they determine the buffer
              	; length from the byte at MBUFF [CPRLOC + 6]), but under ZCPR this is
              	; no longer necessary, since this buffer pointer is automatically
              	; initialized in all cases.
              	;
DC00:         	cbase:  
DC00:         	ENTRY:
DC00: C3C3DC  		JP	CPR		; Process potential default command, and set
              					; USRMAX to MAXUSR default
DC03: C3BFDC  		JP	CPR1		; Do NOT process potential default command
              	;	
              	;**** Section 1 ****
              	; BUFFERS ET AL
              	;
              	; INPUT COMMAND LINE AND DEFAULT COMMAND
              	;
              	;   The command line to be executed is stored here.  This command line
              	; is generated in one of three ways:
              	;
              	;	(1) by the user entering it through the BDOS READLN function at
              	;	    the du> prompt [user input from keyboard]
              	;	(2) by the SUBMIT File Facility placing it there from a $$$.SUB
              	;	    file
              	;	(3) by an external program or user placing the required command
              	;	    into this buffer
              	;
              	;   In all cases, the command line is placed into the buffer starting at
              	; CIBUFF.  This command line is terminated by the last character (NOT Carriage
              	; Return), and a character count of all characters in the command line
              	; up to and including the last character is placed into location CBUFF
              	; (immediately before the command line at CIBUFF).  The placed command line
              	; is then parsed, interpreted, and the indicated command is executed.
              	; If CLEVEL3 is permitted, a terminating zero is placed after the command
              	; (otherwise the user program has to place this zero) and the CIBPTR is
              	; properly initialized (otherwise the user program has to init this ptr).
              	; If the command is placed by a user program, entering at CPRLOC is enough
              	; to have the command processed.  Again, under the current ZCPR, it is not
              	; necessary to store the pointer to CIBUFF in CIBPTR; ZCPR will do this for
              	; the calling program if CLEVEL3 is made TRUE.
              	;
              	;   WARNING:  The command line must NOT exceed BUFLEN characters in length.
              	; For user programs which load this command, the value of BUFLEN can be
              	; obtained by examining the byte at MBUFF (CPRLOC + 6).
              	;
DC06:         	inbuff: 
0050:         	BUFLEN	EQU	80		;MAXIMUM BUFFER LENGTH
DC06:         	MBUFF:
DC06: 50      		DEFB	BUFLEN		;MAXIMUM BUFFER LENGTH
DC07:         	CBUFF:
DC07: 00      		DEFB	0		;NUMBER OF VALID CHARS IN COMMAND LINE
              	
DC08:         	CIBUFF:
DC08: 494E4954	 	DEFM	'INIT '
DC0C: 20      	
DC0D: FF      	        DEFB    255
DC0E: 20202020	        DEFM    '        ';DEFAULT (COLD BOOT) COMMAND
DC12: 20202020	
              	;
              	;  The copyright notice from Digital Research is genned into the
              	; stock CCP at this location. It should be maintained in ZCPR,
              	; since Digital Research grants permission for ZCPR to exist.
              	;
DC16: 2020434F		DEFM	'  COPYRIGHT (C) 1979, DIGITAL RESEARCH  '
DC1A: 50595249	
DC1E: 47485420	
DC22: 28432920	
DC26: 31393739	
DC2A: 2C204449	
DC2E: 47495441	
DC32: 4C205245	
DC36: 53454152	
DC3A: 43482020	
DC3E:         	CIBUF:
DC3E: 00      		DEFB	0		;COMMAND STRING TERMINATOR
DC3F: 4E5A4350		DEFM	'NZCPR V 1.6 of'
DC43: 52205620	
DC47: 312E3620	
DC4B: 6F66    	
DC4D: 2030382F		DEFM	' 08/03/82 '	;ZCPR ID FOR DISK DUMP
DC51: 30332F38	
DC55: 3220    	
DC57: 0000    	 	DEFS	BUFLEN-($-CIBUFF)+1	;TOTAL IS 'BUFLEN' BYTES
              	;
DC59:         	CIBPTR:
DC59: 08DC    		DEFW	CIBUFF		;POINTER TO COMMAND INPUT BUFFER
DC5B:         	CIPTR:
DC5B: 3EDC    		DEFW	CIBUF		;POINTER TO CURR COMMAND FOR
              					; ERROR REPORTING
              	;
DC5D: 00000000		DEFS	26		;STACK AREA
DC61: 00...   	
DC77:         	STACK	EQU	$		;TOP OF STACK
              	;
              	; FILE TYPE FOR COMMAND
              	;
DC77:         	COMMSG:
DC77: 434F4D  		DEFM	'COM'
              	;
              	; SUBMIT FILE CONTROL BLOCK
              	;
DC7A:         	SUBFCB:
              		IF	SUBA		;IF $$$.SUB ON A:
DC7A: 01      		DEFB	1		;DISK NAME SET TO DEFAULT TO DRIVE A:
              	;	ENDIF
              	;
              	;	IF	NOT SUBA	;IF $$$.SUB ON CURRENT DRIVE
              	        ELSE
              		DEFB	0		;DISK NAME SET TO DEFAULT TO CURRENT DRIVE
              		ENDIF
              	;
DC7B: 242424  		DEFM	'$$$'		;FILE NAME
DC7E: 20202020		DEFM	'     '
DC82: 20      	
DC83: 535542  		DEFM	'SUB'		;FILE TYPE
DC86: 00      		DEFB	0		;EXTENT NUMBER
DC87: 00      		DEFB	0		;S1
DC88:         	SUBFS2:
DC88: 00      		DEFS	1		;S2
DC89:         	SUBFRC:
DC89: 00      		DEFS	1		;RECORD COUNT
DC8A: 00000000		DEFS	16		;DISK GROUP MAP
DC8E: 00...   	
DC9A:         	SUBFCR:
DC9A: 00      		DEFS	1		;CURRENT RECORD NUMBER
              	; COMMAND FILE CONTROL BLOCK
              	;
DC9B:         	FCBDN:
DC9B: 00      		DEFS	1		;DISK NAME
DC9C:         	FCBFN:
DC9C: 00000000		DEFS	8		;FILE NAME
DCA0: 00000000	
DCA4:         	FCBFT:
DCA4: 000000  		DEFS	3		;FILE TYPE
DCA7: 00      		DEFS	1		;EXTENT NUMBER
DCA8: 0000    		DEFS	2		;S1 AND S2
DCAA: 00      		DEFS	1		;RECORD COUNT
DCAB:         	FCBDM:
DCAB: 00000000		DEFS	16		;DISK GROUP MAP
DCAF: 00...   	
DCBB:         	FCBCR:
DCBB: 00      		DEFS	1		;CURRENT RECORD NUMBER
              	;
              	; OTHER BUFFERS
              	;
DCBC:         	PAGCNT:
DCBC: 16      		DEFB	NLINES-2	;LINES LEFT ON PAGE
DCBD:         	CHRCNT:
DCBD: 00      		DEFB	0		;CHAR COUNT FOR TYPE
DCBE:         	QMCNT:
DCBE: 00      		DEFB	0		;QUESTION MARK COUNT FOR FCB TOKEN SCANNER
              	;
              	;
              	;**** Section 2 ****
              	; CPR STARTING POINTS.  NOTE THAT SOME CP/M IMPLEMENTATIONS
              	; REQUIRE THE COLD START ADDRESS TO BE IN THE STARTING PAGE
              	; OF THE CPR, FOR DYNAMIC CCP LOADING.  CMDTBL WAS MOVED FOR
              	; THIS REASON.
              	;
              	; SET USRMAX AND/OR MAXDRIV TO DEFAULT VALUES ON COLD BOOT
              	; IF REQUIRED. NOTE THAT SOME BIOS IMPLEMENTATIONS WILL END
              	; UP HERE INSTEAD OF AT THE WARM BOOT, DEFEATING PASSWORDING
              	; OF THESE OPTIONS. RECOMMEND SUCH A BIOS BE FIXED.
              	;
              		IF	USRMAX OR MAXDRIV
              	CPR:
              		IF	USRMAX
              		LD	A,MAXUSR+1	;SET USRMAX ON COLD BOOT
              		LD	(USRMAX),A
              		ENDIF			;USRMAX
              	;
              		IF	MAXDRIV
              		LD	A,MAXDR		;SET MAXDRIV ON COLD BOOT
              		LD	(MAXDRIV),A
              		ENDIF			;MAXDRIV
              	;
              		JR	CPR2		; THEN PROCEED
              		ENDIF			;USRMAX OR MAXDRIV
              	;
              	; START CPR AND DON'T PROCESS DEFAULT COMMAND STORED
              	;
DCBF:         	CPR1:
DCBF: AF      		XOR	A		;SET NO DEFAULT COMMAND
DCC0: 3207DC  		LD	(CBUFF),A
              	;
              	; START CPR AND POSSIBLY PROCESS DEFAULT COMMAND
              	;
              	; NOTE ON MODIFICATION BY RGF: BDOS RETURNS 0FFH IN
              	; ACCUMULATOR WHENEVER IT LOGS IN A DIRECTORY, IF ANY
              	; FILE NAME CONTAINS A '$' IN IT.  THIS IS NOW USED AS
              	; A CLUE TO DETERMINE WHETHER OR NOT TO DO A SEARCH
              	; FOR SUBMIT FILE, IN ORDER TO ELIMINATE WASTEFUL SEARCHES.
              	;
              		IF	USRMAX OR MAXDRIV
              	CPR2:
              		ELSE
DCC3:         	CPR:
              		ENDIF			;USRMAX OR MAXDRIV
              	;
DCC3: 3177DC  		LD	SP,STACK	;RESET STACK
DCC6: C5      		PUSH	BC
DCC7: 79      		LD	A,C		;C=USER/DISK NUMBER (SEE LOC 4)
DCC8: 1F      		RRA			;EXTRACT USER NUMBER
DCC9: 1F      		RRA
DCCA: 1F      		RRA
DCCB: 1F      		RRA
DCCC: E60F    		AND	0FH
DCCE: 5F      		LD	E,A		;SET USER NUMBER
DCCF: CD70DE  		CALL	SETUSR
DCD2: CD33DE  		CALL	RESET		;RESET DISK SYSTEM
DCD5: 32E8DC  		LD	(RNGSUB),A	;SAVE SUBMIT CLUE FROM DRIVE A:
DCD8: C1      		POP	BC
DCD9: 79      		LD	A,C		;C=USER/DISK NUMBER (SEE LOC 4)
DCDA: E60F    		AND	0FH		;EXTRACT DEFAULT DISK DRIVE
DCDC: 3284DE  		LD	(TDRIVE),A	;SET IT
DCDF: 2803    		JR	Z,NOLOG		;SKIP IF 0...ALREADY LOGGED
DCE1: CD38DE  		CALL	LOGIN		;LOG IN DEFAULT DISK
              	;
              		IF	SUBA	;IF $$$.SUB IS ON CURRENT DRIVE
              	        ELSE
              		LD	(RNGSUB),A	;BDOS '$' CLUE
              		ENDIF
              	;
DCE4:         	NOLOG:
DCE4: 117ADC  		LD	DE,SUBFCB	;CHECK FOR $$$.SUB ON CURRENT DISK
DCE8:         	batch   equ     $+1
DCE8:         	RNGSUB	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
DCE7: 3E00    	        LD	A,0	        ;2ND BYTE (IMMEDIATE ARG) IS THE RNGSUB FLAG
DCE9: B7      		OR	A		;SET FLAGS ON CLUE
DCEA: 2F      		CPL			;PREPARE FOR COMING 'CPL'
DCEB: C452DE  		CALL	NZ,SEAR1
DCEE: 2F      		CPL			;0FFH IS RETURNED IF NO $$$.SUB, SO COMPLEMENT
DCEF: 32E8DC  		LD	(RNGSUB),A	;SET FLAG (0=NO $$$.SUB)
DCF2: 3A07DC  		LD	A,(CBUFF)	;EXECUTE DEFAULT COMMAND?
DCF5: B7      		OR	A		;0=NO
DCF6: 2026    		JR	NZ,RS1
              	;
              	; PROMPT USER AND INPUT COMMAND LINE FROM HIM
              	;
DCF8:         	RESTRT:
DCF8: 3177DC  		LD	SP,STACK	;RESET STACK
              	;
              	; PRINT PROMPT (DU>)
              	;
DCFB: CDA7DD  		CALL	CRLF		;PRINT PROMPT
DCFE: CD28DE  		CALL	GETDRV		;CURRENT DRIVE IS PART OF PROMPT
DD01: C641    		ADD	A,'A'		;CONVERT TO ASCII A-P
DD03: CDAEDD  		CALL	CONOUT
DD06: CD6EDE  		CALL	GETUSR		;GET USER NUMBER
              	;
              		IF	SUPRES		;IF SUPPRESSING USR # REPORT FOR USR 0
              		OR	A
              		JR	Z,RS000
              		ENDIF
              	;
DD09: FE0A    		CP	10		;USER < 10?
DD0B: 3809    		JR	C,RS00
DD0D: D60A    		SUB	10		;SUBTRACT 10 FROM IT
DD0F: F5      		PUSH	AF		;SAVE IT
DD10: 3E31    		LD	A,'1'		;OUTPUT 10'S DIGIT
DD12: CDAEDD  		CALL	CONOUT
DD15: F1      		POP	AF
DD16:         	RS00:
DD16: C630    		ADD	A,'0'		;OUTPUT 1'S DIGIT (CONVERT TO ASCII)
DD18: CDAEDD  		CALL	CONOUT
              	;
              	; READ INPUT LINE FROM USER OR $$$.SUB
              	;
DD1B:         	RS000:
DD1B: CD89DE  		CALL	REDBUF		;INPUT COMMAND LINE FROM USER (OR $$$.SUB)
              	;
              	; PROCESS INPUT LINE
              	;
DD1E:         	RS1:
              	;
              		IF	CLEVEL3		;IF THIRD COMMAND LEVEL IS PERMITTED
DD1E: CDEADE  		CALL	CNVBUF		;CAPITALIZE COMMAND LINE, PLACE ENDING 0,
              					; AND SET CIBPTR VALUE
              		ENDIF
              	;
DD21: CD2CDE  		CALL	DEFDMA		;SET TBUFF TO DMA ADDRESS
DD24: CD28DE  		CALL	GETDRV		;GET DEFAULT DRIVE NUMBER
DD27: 3284DE  		LD	(TDRIVE),A	;SET IT
DD2A: CD02E0  		CALL	SCANER		;PARSE COMMAND NAME FROM COMMAND LINE
DD2D: C411DF  		CALL	NZ,ERROR	;ERROR IF COMMAND NAME CONTAINS A '?'
DD30: 1146DD  		LD	DE,RSTCPR	;PUT RETURN ADDRESS OF COMMAND
DD33: D5      		PUSH	DE		;ON THE STACK
DD34: 3AF9DF  		LD	A,(TEMPDR)	;IS COMMAND OF FORM 'D:COMMAND'?
DD37: B7      		OR	A		;NZ=YES
DD38: C2F1E2  		JP	NZ,COM		; IMMEDIATELY
DD3B: CD81E0  		CALL	CMDSER		;SCAN FOR CPR-RESIDENT COMMAND
DD3E: C2F1E2  		JP	NZ,COM		;NOT CPR-RESIDENT
DD41: 7E      		LD	A,(HL)		;FOUND IT:  GET LOW-ORDER PART
DD42: 23      		INC	HL		;GET HIGH-ORDER PART
DD43: 66      		LD	H,(HL)		;STORE HIGH
DD44: 6F      		LD	L,A		;STORE LOW
DD45: E9      		JP	(HL)		;EXECUTE CPR ROUTINE
              	;
              	; ENTRY POINT FOR RESTARTING CPR AND LOGGING IN DEFAULT DRIVE
              	;
DD46:         	RSTCPR:
DD46: CDEEDF  		CALL	DLOGIN		;LOG IN DEFAULT DRIVE
              	;
              	; ENTRY POINT FOR RESTARTING CPR WITHOUT LOGGING IN DEFAULT DRIVE
              	;
DD49:         	RCPRNL:
DD49: CD02E0  		CALL	SCANER		;EXTRACT NEXT TOKEN FROM COMMAND LINE
DD4C: 3A9CDC  		LD	A,(FCBFN)	;GET FIRST CHAR OF TOKEN
DD4F: D620    		SUB	' '		;ANY CHAR?
DD51: 21F9DF  		LD	HL,TEMPDR
DD54: B6      		OR	(HL)
DD55: C211DF  		JP	NZ,ERROR
DD58: 189E    		JR	RESTRT
              	;
              	; No File Error Message
              	;
DD5A:         	PRNNF:
DD5A: CD10DE  		CALL	PRINTC		;NO FILE MESSAGE
DD5D: 4E6F2046		DEFM	'No Fil'
DD61: 696C    	
DD63: E5      		DEFB	'e'+80H
DD64: C9      		RET
              	;
              	; CPR BUILT-IN COMMAND TABLE
              	;
0004:         	NCHARS	EQU	4		;NUMBER OF CHARS/COMMAND
              	;
              	; CPR COMMAND NAME TABLE
              	;   EACH TABLE ENTRY IS COMPOSED OF THE 4-BYTE COMMAND AND 2-BYTE ADDRESS
              	;
DD65:         	CMDTBL:
              	;
              		IF	INPASS AND SECURE
              		DEFM	'PASS'		;ENABLE WHEEL (SYSOP) MODE
              		DEFW	PASS
              		ENDIF			;INPASS AND SECURE
              	;
              		IF	DRUSER
DD65: 55534552		DEFM	'USER'		;CHANGE USER AREAS
DD69: D5E2    		DEFW	USER
              		ENDIF			;DRUSER
              	;
              		IF	CPRTYP
DD6B: 54595045		DEFM	'TYPE'		;TYPE A FILE TO CON:
DD6F: 7FE1    		DEFW	TYPE
              		ENDIF			;CPRTYP
              	;
              		IF	CPRDIR
DD71: 44495220		DEFM	'DIR '		;PULL A DIRECTORY OF DISK FILES
DD75: A3E0    		DEFW	DIR
              		ENDIF			;CPRDIR
              	
0003:         	NRCMDS	EQU	($-CMDTBL)/(NCHARS+2)
              					;PUT ANY COMMANDS THAT ARE OK TO
              					;RUN WHEN NOT UNDER WHEEL MODE
              					;IN FRONT OF THIS LABEL
              		IF	CPRLST AND CPRTYP
DD77: 4C495354		DEFM	'LIST'		;LIST FILE TO PRINTER
DD7B: 7BE1    		DEFW	LIST
              		ENDIF			;CPRLST AND CPRTYP
              	;
              		IF	INPASS AND SECURE
              		DEFM	'NORM'		;DISABLE WHEEL MODE
              		DEFW	NORM
              		ENDIF			;INPASS AND SECURE
              	;
              		IF	RAS		;FOR NON-RAS
              	        ELSE
DD7D: 474F2020		DEFM	'GO  '		;JUMP TO 100H
DD81: ECE2    		DEFW	GO
DD83: 45524120		DEFM	'ERA '		;ERASE FILE
DD87: 54E1    		DEFW	ERA
DD89: 53415645		DEFM	'SAVE'		;SAVE MEMORY IMAGE TO DISK
DD8D: 0CE2    		DEFW	SAVE
DD8F: 52454E20		DEFM	'REN '		;RENAME FILE
DD93: 91E2    		DEFW	REN
DD95: 44465520		DEFM	'DFU '		;SET DEFAULT USER
DD99: DFE2    		DEFW	DFU
DD9B: 47455420		DEFM	'GET '		;LOAD FILE INTO MEMORY
DD9F: 93E3    		DEFW	GET
DDA1: 4A554D50		DEFM	'JUMP'		;JUMP TO LOCATION IN MEMORY
DDA5: E7E2    		DEFW	JUMP
              		ENDIF			;RAS
              	;
000B:         	NCMNDS	EQU	($-CMDTBL)/(NCHARS+2)
              	;
              	;**** Section 3 ****
              	; I/O UTILITIES
              	;
              	; OUTPUT CHAR IN REG A TO CONSOLE AND DON'T CHANGE BC
              	;
              	;
              	; OUTPUT <CRLF>
              	;
DDA7:         	CRLF:
DDA7: 3E0D    		LD	A,CR
DDA9: CDAEDD  		CALL	CONOUT
DDAC: 3E0A    		LD	A,LF		;FALL THRU TO CONOUT
              	;
DDAE:         	CONOUT:
DDAE: C5      		PUSH	BC
DDAF: 0E02    		LD	C,02H
DDB1:         	OUTPUT:
DDB1: E67F    		AND	7FH		;PREVENT INADVERTANT GRAPHIC OUTPUT
              					; TO EPSON-TYPE PRINTERS
DDB3: 5F      		LD	E,A
DDB4: E5      		PUSH	HL
DDB5: CD0500  		CALL	BDOS
DDB8: E1      		POP	HL
DDB9: C1      		POP	BC
DDBA: C9      		RET
              	;
DDBB:         	CONIN:
DDBB: 0E01    		LD	C,01H		;GET CHAR FROM CON: WITH ECHO
DDBD: CD09DE  		CALL	BDOSB
              	;
              	; CONVERT CHAR IN A TO UPPER CASE
              	;
DDC0:         	UCASE:
DDC0: FE61    		CP	61H		;LOWER-CASE A
DDC2: D8      		RET	C
DDC3: FE7B    		CP	7BH		;GREATER THAN LOWER-CASE Z?
DDC5: D0      		RET	NC
DDC6: E65F    		AND	5FH		;CAPITALIZE
DDC8: C9      		RET
              	;
DDC9:         	NOECHO:
DDC9: D5      		PUSH	DE		;SAVE D
DDCA: 0E06    		LD	C,6		;DIRECT CONSOLE I/O
DDCC: 1EFF    		LD	E,0FFH		;INPUT
DDCE: CD09DE  		CALL	BDOSB
DDD1: D1      		POP	DE
DDD2: B7      		OR	A		;DID WE GET A CHAR?
DDD3: 28F4    		JR	Z,NOECHO	;WAIT FOR IT IF NOT, IT'S EXPECTED
DDD5: C9      		RET
              	;
              		IF	CPRTYP
DDD6:         	LCOUT:
              		ENDIF			;CPRTYP
              	;
              		IF	CPRTYP AND CPRLST
DDD6: F5      		PUSH	AF		;OUTPUT CHAR TO CON: OR LST: DEP ON PRFLG
DDD8:         	PRFLG	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
DDD7: 3E00    		LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS THE PRINT FLAG
DDD9: B7      		OR	A		;0=TYPE
DDDA: 2806    		JR	Z,LC1
DDDC: F1      		POP	AF		;GET CHAR
              	;
              	; OUTPUT CHAR IN REG A TO LIST DEVICE
              	;
DDDD:         	LSTOUT:
DDDD: C5      		PUSH	BC
DDDE: 0E05    		LD	C,05H
DDE0: 18CF    		JR	OUTPUT
DDE2:         	LC1:
DDE2: F1      		POP	AF		;GET CHAR
              		ENDIF			;CPRTYP AND CPRLST
              	;
              		IF	CPRTYP
DDE3: F5      		PUSH	AF
DDE4: CDAEDD  		CALL	CONOUT		;OUTPUT TO CON:
DDE7: F1      		POP	AF
DDE8: FE0A    		CP	LF		;CHECK FOR PAGING
DDEA: C0      		RET	NZ		;DONE IF NOT EOL YET
              	;
              	;  COUNT DOWN LINES AND PAUSE FOR INPUT (DIRECT) IF COUNT EXPIRES
              	;
DDEB: E5      		PUSH	HL
DDEC: 21BCDC  		LD	HL,PAGCNT	;COUNT DOWN
DDEF: 35      		DEC	(HL)
DDF0: 2010    		JR	NZ,PGBAK	;JUMP IF NOT END OF PAGE
DDF2: 3616    		LD	(HL),NLINES-2	;REFILL COUNTER
              	;
DDF5:         	PGFLG	EQU	$+1		;POINTER TO IN-THE-CODE BUFFER PGFLG
DDF4: 3E00    		LD	A,0		;0 MAY BE CHANGED BY PGFLG EQUATE
DDF6: FE50    		CP	PGDFLG		;PAGE DEFAULT OVERRIDE OPTION WANTED?
              	;
              		IF	PGDFLT		;IF PAGING IS DEFAULT
              		JR	Z,PGBAK		;  PGDFLG MEANS NO PAGING, PLEASE
              		ELSE			;IF PAGING NOT DEFAULT
DDF8: 2008    		JR	NZ,PGBAK	;  PGDFLG MEANS PLEASE PAGINATE
              		ENDIF
              	;
DDFA: CDC9DD  		CALL	NOECHO		;GET CHAR BUT DON'T ECHO TO SCREEN
DDFD: FE03    		CP	'C'-'@' 	;^C
DDFF: CA46DD  		JP	Z,RSTCPR	;RESTART CPR
DE02:         	PGBAK:
DE02: E1      		POP	HL		;RESTORE HL
DE03: C9      		RET
              		ENDIF			;CPRTYP
              	;
DE04:         	READF:
DE04: 119BDC  		LD	DE,FCBDN 	;FALL THRU TO READ
DE07:         	READ:
DE07: 0E14    		LD	C,14H		;FALL THRU TO BDOSB
              	;
              	; CALL BDOS AND SAVE BC
              	;
DE09:         	BDOSB:
DE09: C5      		PUSH	BC
DE0A: CD0500  		CALL	BDOS
DE0D: C1      		POP	BC
DE0E: B7      		OR	A
DE0F: C9      		RET
              	;
              	; PRINT STRING ENDING WITH ZERO BYTE OR CHAR WITH HIGH BIT SET
              	; PT'ED TO BY RET ADDR, START WITH <CR><LF>
              	;
DE10:         	PRINTC:
DE10: F5      		PUSH	AF		;SAVE FLAGS
DE11: CDA7DD  		CALL	CRLF		;NEW LINE
DE14: F1      		POP	AF
              	;
DE15:         	PRINT:
DE15: E3      		EX	(SP),HL		;GET PTR TO STRING
DE16: F5      		PUSH	AF		;SAVE FLAGS
DE17: CD1DDE  		CALL	PRIN1		;PRINT STRING
DE1A: F1      		POP	AF		;GET FLAGS
DE1B: E3      		EX	(SP),HL		;RESTORE HL AND RET ADR
DE1C: C9      		RET
              	;
              	; PRINT STRING ENDING WITH ZERO BYTE OR CHAR WITH HIGH BIT SET
              	; PT'ED TO BY HL
              	;
DE1D:         	PRIN1:
DE1D: 7E      		LD	A,(HL)		;GET NEXT BYTE
DE1E: CDAEDD  		CALL	CONOUT		;PRINT CHAR
DE21: 7E      		LD	A,(HL)		;GET NEXT BYTE AGAIN FOR TEST
DE22: 23      		INC	HL		;PT TO NEXT BYTE
DE23: B7      		OR	A		;SET FLAGS
DE24: C8      		RET	Z		;DONE IF ZERO
DE25: F8      		RET	M		;DONE IF MSB SET
DE26: 18F5    		JR	PRIN1
              	;
              	; BDOS FUNCTION ROUTINES
              	;
              	;
              	; RETURN NUMBER OF CURRENT DISK IN A
              	;
DE28:         	GETDRV:
DE28: 0E19    		LD	C,19H
DE2A: 1809    		JR	BDOSJP
              	;
              	; SET 80H AS DMA ADDRESS
              	;
DE2C:         	DEFDMA:
DE2C: 118000  		LD	DE,TBUFF 	;80H=TBUFF
DE2F:         	DMASET:
DE2F: 0E1A    		LD	C,1AH
DE31: 1802    		JR	BDOSJP
              	;
DE33:         	RESET:
DE33: 0E0D    		LD	C,0DH
DE35:         	BDOSJP:
DE35: C30500  		JP	BDOS
              	;
DE38:         	LOGIN:
DE38: 5F      		LD	E,A		;MOVE DESIRED # TO BDOS REG
              	;
              		IF	MAXDRIV
              		LD	A,(MAXDRIV)	;CHECK FOR LEGAL DRIVE #
              		CP	E
              		JP	C,ERROR		;DON'T DO IT IF TOO HIGH
              		ENDIF			;MAXDRIV
              	;
DE39: 0E0E    		LD	C,0EH
DE3B: 18F8    		JR	BDOSJP		;SAVE SOME CODE SPACE
              	;
DE3D:         	OPENF:
DE3D: AF      		XOR	A
DE3E: 32BBDC  		LD	(FCBCR),A
DE41: 119BDC  		LD	DE,FCBDN 	;FALL THRU TO OPEN
              	;
DE44:         	OPEN:
DE44: 0E0F    		LD	C,0FH		;FALL THRU TO GRBDOS
              	;
DE46:         	GRBDOS:
DE46: CD0500  		CALL	BDOS
DE49: 3C      		INC	A		;SET ZERO FLAG FOR ERROR RETURN
DE4A: C9      		RET
              	;
DE4B:         	CLOSE:
DE4B: 0E10    		LD	C,10H
DE4D: 18F7    		JR	GRBDOS
              	;
DE4F:         	SEARF:
DE4F: 119BDC  		LD	DE,FCBDN 	;SPECIFY FCB
DE52:         	SEAR1:
DE52: 0E11    		LD	C,11H
DE54: 18F0    		JR	GRBDOS
              	;
DE56:         	SEARN:
DE56: 0E12    		LD	C,12H
DE58: 18EC    		JR	GRBDOS
              	;
              	; CHECK FOR SUBMIT FILE IN EXECUTION AND ABORT IT IF SO
              	;
DE5A:         	SUBKIL:
DE5A: 21E8DC  		LD	HL,RNGSUB	;CHECK FOR SUBMIT FILE IN EXECUTION
DE5D: 7E      		LD	A,(HL)
DE5E: B7      		OR	A		;0=NO
DE5F: C8      		RET	Z
DE60: 3600    		LD	(HL),0		;ABORT SUBMIT FILE
DE62: 117ADC  		LD	DE,SUBFCB	;DELETE $$$.SUB
              	;
DE65:         	DELETE:
DE65: 0E13    		LD	C,13H
DE67: 18CC    		JR	BDOSJP		;SAVE MORE SPACE
              	;
              	; RESET USER NUMBER IF CHANGED
              	;
DE69:         	RESETUSR:
DE6A:         	TMPUSR	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
DE69: 3E00    		LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS TMPUSR
DE6B: 5F      		LD	E,A		;PLACE IN E
DE6C: 1802    		JR	SETUSR		;THEN GO SET USER
DE6E:         	GETUSR:
DE6E: 1EFF    		LD	E,0FFH		;GET CURRENT USER NUMBER
DE70:         	SETUSR:
DE70: 0E20    		LD	C,20H		;SET USER NUMBER TO VALUE IN E (GET IF E=FFH)
DE72: 18C1    		JR	BDOSJP		;MORE SPACE SAVING
              	;
              	; END OF BDOS FUNCTIONS
              	;
              	;
              	;**** Section 4 ****
              	; CPR UTILITIES
              	;
              	; SET USER/DISK FLAG TO CURRENT USER AND DEFAULT DISK
              	;
DE74:         	SETUD:
DE74: CD6EDE  		CALL	GETUSR		;GET NUMBER OF CURRENT USER
DE77: 87      		ADD	A,A		;PLACE IT IN HIGH NYBBLE
DE78: 87      		ADD	A,A
DE79: 87      		ADD	A,A
DE7A: 87      		ADD	A,A
DE7B: 2184DE  		LD	HL,TDRIVE	;MASK IN DEFAULT DRIVE NUMBER (LOW NYBBLE)
DE7E: B6      		OR	(HL)		;MASK IN
DE7F: 320400  		LD	(UDFLAG),A	;SET USER/DISK NUMBER
DE82: C9      		RET
              	;
              	; SET USER/DISK FLAG TO USER 0 AND DEFAULT DISK
              	;
DE83:         	SETU0D:
DE84:         	TDRIVE	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
DE83: 3E00    		LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS TDRIVE
DE85: 320400  		LD	(UDFLAG),A	;SET USER/DISK NUMBER
DE88: C9      		RET
              	;
              	; INPUT NEXT COMMAND TO CPR
              	;	This routine determines if a SUBMIT file is being processed
              	; and extracts the command line from it if so or from the user's console
              	;
DE89:         	REDBUF:
DE89: 3AE8DC  		LD	A,(RNGSUB)	;SUBMIT FILE CURRENTLY IN EXECUTION?
DE8C: B7      		OR	A		;0=NO
DE8D: 2845    		JR	Z,RB1		;GET LINE FROM CONSOLE IF NOT
DE8F: 117ADC  		LD	DE,SUBFCB	;OPEN $$$.SUB
DE92: D5      		PUSH	DE		;SAVE DE
DE93: CD44DE  		CALL	OPEN
DE96: D1      		POP	DE		;RESTORE DE
DE97: 283B    		JR	Z,RB1		;ERASE $$$.SUB IF END OF FILE AND GET CMND
DE99: 3A89DC  		LD	A,(SUBFRC)	;GET VALUE OF LAST RECORD IN FILE
DE9C: 3D      		DEC	A		;PT TO NEXT TO LAST RECORD
DE9D: 329ADC  		LD	(SUBFCR),A	;SAVE NEW VALUE OF LAST RECORD IN $$$.SUB
DEA0: CD07DE  		CALL	READ		;DE=SUBFCB
DEA3: 202F    		JR	NZ,RB1		;ABORT $$$.SUB IF ERROR IN READING LAST REC
DEA5: 1107DC  		LD	DE,CBUFF 	;COPY LAST RECORD (NEXT SUBMIT CMND) TO CBUFF
DEA8: 218000  		LD	HL,TBUFF 	;  FROM TBUFF
DEAB: 015000  		LD	BC,BUFLEN	;NUMBER OF BYTES
DEAE: EDB0    		LDIR
DEB0: 2188DC  		LD	HL,SUBFS2	;PT TO S2 OF $$$.SUB FCB
DEB3: 3600    		LD	(HL),0		;SET S2 TO ZERO
DEB5: 23      		INC	HL		;PT TO RECORD COUNT
DEB6: 35      		DEC	(HL)		;DECREMENT RECORD COUNT OF $$$.SUB
DEB7: 117ADC  		LD	DE,SUBFCB	;CLOSE $$$.SUB
DEBA: CD4BDE  		CALL	CLOSE
DEBD: 2815    		JR	Z,RB1		;ABORT $$$.SUB IF ERROR
DEBF: 3E24    		LD	A,SPRMPT	;PRINT SUBMIT PROMPT
DEC1: CDAEDD  		CALL	CONOUT
DEC4: 2108DC  		LD	HL,CIBUFF	;PRINT COMMAND LINE FROM $$$.SUB
DEC7: CD1DDE  		CALL	PRIN1
DECA: CD00DF  		CALL	BREAK		;CHECK FOR ABORT (ANY CHAR)
              	;
              		IF	CLEVEL3		;IF THIRD COMMAND LEVEL IS PERMITTED
DECD: C8      		RET	Z		;IF <NULL> (NO ABORT), RETURN TO CALLER AND RUN
              		ENDIF
              	;
              		IF	CLEVEL3	;IF THIRD COMMAND LEVEL IS NOT PERMITTED
              	        ELSE
              		JR	Z,CNVBUF	;IF <NULL> (NO ABORT), CAPITALIZE COMMAND
              		ENDIF
              	;
DECE: CD5ADE  		CALL	SUBKIL		;KILL $$$.SUB IF ABORT
DED1: C3F8DC  		JP	RESTRT		;RESTART CPR
              	;
              	; INPUT COMMAND LINE FROM USER CONSOLE
              	;
DED4:         	RB1:
DED4: CD5ADE  		CALL	SUBKIL		;ERASE $$$.SUB IF PRESENT
DED7: CD74DE  		CALL	SETUD		;SET USER AND DISK
DEDA: 3E3E    		LD	A,CPRMPT	;PRINT PROMPT
DEDC: CDAEDD  		CALL	CONOUT
DEDF: 0E0A    		LD	C,0AH		;READ COMMAND LINE FROM USER
DEE1: 1106DC  		LD	DE,MBUFF
DEE4: CD0500  		CALL	BDOS
              	;
              		IF	CLEVEL3		;IF THIRD COMMAND LEVEL IS PERMITTED
DEE7: C383DE  		JP	SETU0D		;SET CURRENT DISK NUMBER IN LOWER PARAMS
              		ENDIF
              	;
              		IF	CLEVEL3	;IF THIRD COMMAND LEVEL IS NOT PERMITTED
              	        ELSE
              		CALL	SETU0D		;SET CURRENT DISK NUMBER IF LOWER PARAMS
              					; AND FALL THRU TO CNVBUF
              		ENDIF
              	;
              	; CAPITALIZE STRING (ENDING IN 0) IN CBUFF AND SET PTR FOR PARSING
              	;
DEEA:         	CNVBUF:
DEEA: 2107DC  		LD	HL,CBUFF 	;PT TO USER'S COMMAND
DEED: 46      		LD	B,(HL)		;CHAR COUNT IN B
DEEE: 04      		INC	B		;ADD 1 IN CASE OF ZERO
DEEF:         	CB1:
DEEF: 23      		INC	HL		;PT TO 1ST VALID CHAR
DEF0: 7E      		LD	A,(HL)		;CAPITALIZE COMMAND CHAR
DEF1: CDC0DD  		CALL	UCASE
DEF4: 77      		LD	(HL),A
DEF5: 10F8    		DJNZ	CB1		;CONTINUE TO END OF COMMAND LINE
DEF7:         	CB2:
DEF7: 3600    		LD	(HL),0		;STORE ENDING <NULL>
DEF9: 2108DC  		LD	HL,CIBUFF	;SET COMMAND LINE PTR TO 1ST CHAR
DEFC: 2259DC  		LD	(CIBPTR),HL
DEFF: C9      		RET
              	;
              	; CHECK FOR ANY CHAR FROM USER CONSOLE;RET W/ZERO SET IF NONE
              	;
DF00:         	BREAK:
DF00: D5      		PUSH	DE		;SAVE DE
DF01: 0E0B    		LD	C,11		;CSTS CHECK
DF03: CD09DE  		CALL	BDOSB
DF06: C4BBDD  		CALL	NZ,CONIN	;GET INPUT CHAR
DF09:         	BRKBK:
DF09: D1      		POP	DE
DF0A: C9      		RET
              	;
              	; GET THE REQUESTED USER NUMBER FROM THE COMMAND LINE AND VALIDATE IT.
              	;
DF0B:         	USRNUM:		
DF0B: CD5DDF  		CALL	NUMBER
              	;
              		IF	USRMAX
              		LD	HL,USRMAX 	;PT TO MAXUSR + 1
              		CP	(HL)		;NEW VALUE ALLOWED?
              		ELSE
DF0E: FE10    		CP	MAXUSR+1 	;NEW VALUE ALLOWED?
              		ENDIF			;USRMAX
              	;
DF10: D8      		RET	C		;RETURN TO CALLER IF SO,
              					; ELSE FLAG AS ERROR
              	;
              	; INVALID COMMAND -- PRINT IT
              	;
DF11:         	ERROR:
DF11: CDA7DD  		CALL	CRLF		;NEW LINE
DF14: 2A5BDC  		LD	HL,(CIPTR)	;PT TO BEGINNING OF COMMAND LINE
DF17:         	ERR2:
DF17: 7E      		LD	A,(HL)		;GET CHAR
DF18: FE21    		CP	' '+1		;SIMPLE '?' IF <SP> OR LESS
DF1A: 3808    		JR	C,ERR1
DF1C: E5      		PUSH	HL		;SAVE PTR TO ERROR COMMAND CHAR
DF1D: CDAEDD  		CALL	CONOUT		;PRINT COMMAND CHAR
DF20: E1      		POP	HL		;GET PTR
DF21: 23      		INC	HL		;PT TO NEXT
DF22: 18F3    		JR	ERR2		;CONTINUE
DF24:         	ERR1:
DF24: CD15DE  		CALL	PRINT		;PRINT '?'
DF27: BF      		DEFB	'?'+80H
DF28: CD5ADE  		CALL	SUBKIL		;TERMINATE ACTIVE $$$.SUB IF ANY
DF2B: C3F8DC  		JP	RESTRT		;RESTART CPR
              	;
              	; CHECK TO SEE IF DE PTS TO DELIMITER; IF SO, RET W/ZERO FLAG SET
              	;
DF2E:         	SDELM:
DF2E: 1A      		LD	A,(DE)
DF2F: B7      		OR	A		;0=DELIMITER
DF30: C8      		RET	Z
DF31: FE20    		CP	' '		;ERROR IF < <SP>
DF33: 38DC    		JR	C,ERROR
DF35: C8      		RET	Z			;<SP>=DELIMITER
DF36: FE3D    		CP	'='		;'='=DELIMITER
DF38: C8      		RET	Z
DF39: FE5F    		CP	5FH		;UNDERSCORE=DELIMITER
DF3B: C8      		RET	Z
DF3C: FE2E    		CP	'.'		;'.'=DELIMITER
DF3E: C8      		RET	Z
DF3F: FE3A    		CP	':'		;':'=DELIMITER
DF41: C8      		RET	Z
DF42: FE3B    		CP	';'		;';'=DELIMITER
DF44: C8      		RET	Z
DF45: FE3C    		CP	'<'		;'<'=DELIMITER
DF47: C8      		RET	Z
DF48: FE3E    		CP	'>'		;'>'=DELIMITER
DF4A: C9      		RET
              	;
              	; ADVANCE INPUT PTR TO FIRST NON-BLANK AND FALL THROUGH TO SBLANK
              	;
DF4B:         	ADVAN:
DF4B: ED5B59DC		LD	DE,(CIBPTR)
              	;
              	; SKIP STRING PTED TO BY DE (STRING ENDS IN 0) UNTIL END OF STRING
              	;   OR NON-BLANK ENCOUNTERED (BEGINNING OF TOKEN)
              	;
DF4F:         	SBLANK:
DF4F: 1A      		LD	A,(DE)
DF50: B7      		OR	A
DF51: C8      		RET	Z
DF52: FE20    		CP	' '
DF54: C0      		RET	NZ
DF55: 13      		INC	DE
DF56: 18F7    		JR	SBLANK
              	;
              	; ADD A TO HL (HL=HL+A)
              	;
DF58:         	ADDAH:
DF58: 85      		ADD	A,L
DF59: 6F      		LD	L,A
DF5A: D0      		RET	NC
DF5B: 24      		INC	H
DF5C: C9      		RET
              	;
              	; EXTRACT DECIMAL NUMBER FROM COMMAND LINE
              	;   RETURN WITH VALUE IN REG A;ALL REGISTERS MAY BE AFFECTED
              	;
DF5D:         	NUMBER:
DF5D: CD02E0  		CALL	SCANER		;PARSE NUMBER AND PLACE IN FCBFN
DF60: 21A6DC  		LD	HL,FCBFN+10 	;PT TO END OF TOKEN FOR CONVERSION
DF63: 060B    		LD	B,11		;11 CHARS MAX
              	;
              	; CHECK FOR SUFFIX FOR HEXADECIMAL NUMBER
              	;
DF65:         	NUMS:
DF65: 7E      		LD	A,(HL)		;GET CHARS FROM END, SEARCHING FOR SUFFIX
DF66: 2B      		DEC	HL		;BACK UP
DF67: FE20    		CP	' '		;SPACE?
DF69: 2004    		JR	NZ,NUMS1	;CHECK FOR SUFFIX
DF6B: 10F8    		DJNZ	NUMS		;COUNT DOWN
DF6D: 1804    		JR	NUM0		;BY DEFAULT, PROCESS
DF6F:         	NUMS1:
DF6F: FE48    		CP	NUMBASE		;CHECK AGAINST BASE SWITCH FLAG
DF71: 282B    		JR	Z,HNUM0
              	;
              	; PROCESS DECIMAL NUMBER
              	;
DF73:         	NUM0:
DF73: 219CDC  		LD	HL,FCBFN	;PT TO BEGINNING OF TOKEN
DF76: 010011  		LD	BC,1100H	;C=ACCUMULATED VALUE, B=CHAR COUNT
              					; (C=0, B=11)
DF79:         	NUM1:
DF79: 7E      		LD	A,(HL)		;GET CHAR
DF7A: FE20    		CP	' '		;DONE IF <SP>
DF7C: 2818    		JR	Z,NUM2
DF7E: 23      		INC	HL		;PT TO NEXT CHAR
DF7F: D630    		SUB	'0'		;CONVERT TO BINARY (ASCII 0-9 TO BINARY)
DF81: FE0A    		CP	10		;ERROR IF >= 10
DF83: 3013    		JR	NC,NUMERR
DF85: 57      		LD	D,A		;DIGIT IN D
DF86: 79      		LD	A,C		;NEW VALUE = OLD VALUE * 10
DF87: 07      		RLCA
DF88: 07      		RLCA
DF89: 07      		RLCA
DF8A: 81      		ADD	A,C		;CHECK FOR RANGE ERROR
DF8B: 380B    		JR	C,NUMERR
DF8D: 81      		ADD	A,C		;CHECK FOR RANGE ERROR
DF8E: 3808    		JR	C,NUMERR
DF90: 82      		ADD	A,D		;NEW VALUE = OLD VALUE * 10 + DIGIT
DF91: 3805    		JR	C,NUMERR	;CHECK FOR RANGE ERROR
DF93: 4F      		LD	C,A		;SET NEW VALUE
DF94: 10E3    		DJNZ	NUM1		;COUNT DOWN
              	;
              	; RETURN FROM NUMBER
              	;
DF96:         	NUM2:
DF96: 79      		LD	A,C		;GET ACCUMULATED VALUE
DF97: C9      		RET
              	;
              	; NUMBER ERROR ROUTINE FOR SPACE CONSERVATION
              	;
DF98:         	NUMERR:
DF98: C311DF  		JP	ERROR		;USE ERROR ROUTINE - THIS IS RELATIVE PT
              	;
              	; EXTRACT HEXADECIMAL NUMBER FROM COMMAND LINE
              	;   RETURN WITH VALUE IN REG A; ALL REGISTERS MAY BE AFFECTED
              	;
DF9B:         	HEXNUM:
DF9B: CD02E0  		CALL	SCANER		;PARSE NUMBER AND PLACE IN FCBFN
DF9E:         	HNUM0:
DF9E: 219CDC  		LD	HL,FCBFN	;PT TO TOKEN FOR CONVERSION
DFA1: 110000  		LD	DE,0		;DE=ACCUMULATED VALUE
DFA4: 060B    		LD	B,11		;B=CHAR COUNT
DFA6:         	HNUM1:
DFA6: 7E      		LD	A,(HL)		;GET CHAR
DFA7: FE20    		CP	' '		;DONE?
DFA9: 282D    		JR	Z,HNUM3		;RETURN IF SO
DFAB: FE48    		CP	NUMBASE		;DONE IF NUMBASE SUFFIX
DFAD: 2829    		JR	Z,HNUM3
DFAF: D630    		SUB	'0'		;CONVERT TO BINARY
DFB1: 38E5    		JR	C,NUMERR	;RETURN AND DONE IF ERROR
DFB3: FE0A    		CP	10		;0-9?
DFB5: 3806    		JR	C,HNUM2
DFB7: D607    		SUB	7		;A-F?
DFB9: FE10    		CP	10H		;ERROR?
DFBB: 30DB    		JR	NC,NUMERR
DFBD:         	HNUM2:
DFBD: 23      		INC	HL		;PT TO NEXT CHAR
DFBE: 4F      		LD	C,A		;DIGIT IN C
DFBF: 7A      		LD	A,D		;GET ACCUMULATED VALUE
DFC0: 07      		RLCA			;EXCHANGE NYBBLES
DFC1: 07      		RLCA
DFC2: 07      		RLCA
DFC3: 07      		RLCA
DFC4: E6F0    		AND	0F0H		;MASK OUT LOW NYBBLE
DFC6: 57      		LD	D,A
DFC7: 7B      		LD	A,E		;SWITCH LOW-ORDER NYBBLES
DFC8: 07      		RLCA
DFC9: 07      		RLCA
DFCA: 07      		RLCA
DFCB: 07      		RLCA
DFCC: 5F      		LD	E,A		;HIGH NYBBLE OF E=NEW HIGH OF E,
              					;  LOW NYBBLE OF E=NEW LOW OF D
DFCD: E60F    		AND	0FH		;GET NEW LOW OF D
DFCF: B2      		OR	D		;MASK IN HIGH OF D
DFD0: 57      		LD	D,A		;NEW HIGH BYTE IN D
DFD1: 7B      		LD	A,E
DFD2: E6F0    		AND	0F0H		;MASK OUT LOW OF E
DFD4: B1      		OR	C		;MASK IN NEW LOW
DFD5: 5F      		LD	E,A		;NEW LOW BYTE IN E
DFD6: 10CE    		DJNZ	HNUM1		;COUNT DOWN
              	;
              	; RETURN FROM HEXNUM
              	;
DFD8:         	HNUM3:
DFD8: EB      		EX	DE,HL		;RETURNED VALUE IN HL
DFD9: 7D      		LD	A,L		;LOW-ORDER BYTE IN A
DFDA: C9      		RET
              	;
              	; PT TO DIRECTORY ENTRY IN TBUFF WHOSE OFFSET IS SPECIFIED BY A AND C
              	;
DFDB:         	DIRPTR:
DFDB: 218000  		LD	HL,TBUFF 	;PT TO TEMP BUFFER
DFDE: 81      		ADD	A,C		;PT TO 1ST BYTE OF DIR ENTRY
DFDF: CD58DF  		CALL	ADDAH		;PT TO DESIRED BYTE IN DIR ENTRY
DFE2: 7E      		LD	A,(HL)		;GET DESIRED BYTE
DFE3: C9      		RET
              	;
              	; CHECK FOR SPECIFIED DRIVE AND LOG IT IN IF NOT DEFAULT
              	;
DFE4:         	SLOGIN:
DFE4: AF      		XOR	A		;SET FCBDN FOR DEFAULT DRIVE
DFE5: 329BDC  		LD	(FCBDN),A
DFE8: CDF8DF  		CALL	COMLOG		;CHECK DRIVE
DFEB: C8      		RET	Z
DFEC: 1807    		JR	DLOG5		;DO LOGIN OTHERWISE
              	;
              	; CHECK FOR SPECIFIED DRIVE AND LOG IN DEFAULT DRIVE IF SPECIFIED<>DEFAULT
              	;
DFEE:         	DLOGIN:
DFEE: CDF8DF  		CALL	COMLOG		;CHECK DRIVE
DFF1: C8      		RET	Z		;ABORT IF SAME
DFF2: 3A84DE  		LD	A,(TDRIVE)	;LOG IN DEFAULT DRIVE
              	;
DFF5: C338DE  	DLOG5:	JP	LOGIN
              	;
              	; ROUTINE COMMON TO BOTH LOGIN ROUTINES; ON EXIT, Z SET MEANS ABORT
              	;
DFF8:         	COMLOG:
DFF9:         	TEMPDR	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
DFF8: 3E00    		LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS TEMPDR
DFFA: B7      		OR	A		;0=NO
DFFB: C8      		RET	Z
DFFC: 3D      		DEC	A		;COMPARE IT AGAINST DEFAULT
DFFD: 2184DE  		LD	HL,TDRIVE
E000: BE      		CP	(HL)
E001: C9      		RET			;ABORT IF SAME
              	;
              	; EXTRACT TOKEN FROM COMMAND LINE AND PLACE IT INTO FCBDN;
              	;   FORMAT FCBDN FCB IF TOKEN RESEMBLES FILE NAME AND TYPE (FILENAME.TYP);
              	;   ON INPUT, CIBPTR PTS TO CHAR AT WHICH TO START SCAN;
              	;   ON OUTPUT, CIBPTR PTS TO CHAR AT WHICH TO CONTINUE AND ZERO FLAG IS RESET
              	;     IF '?' IS IN TOKEN
              	;
              	; ENTRY POINTS:
              	;	SCANER - LOAD TOKEN INTO FIRST FCB
              	;	SCANX - LOAD TOKEN INTO FCB PTED TO BY HL
              	;
E002:         	SCANER:
E002: 219BDC  		LD	HL,FCBDN 	;POINT TO FCBDN
E005:         	SCANX:
E005: AF      		XOR	A		;SET TEMPORRY DRIVE NUMBER TO DEFAULT
E006: 32F9DF  		LD	(TEMPDR),A
E009: CD4BDF  		CALL	ADVAN		;SKIP TO NON-BLANK OR END OF LINE
E00C: ED535BDC		LD	(CIPTR),DE	;SET PTR TO NON-BLANK OR END OF LINE
E010: 1A      		LD	A,(DE)		;END OF LINE?
E011: B7      		OR	A		;0=YES
E012: 280A    		JR	Z,SCAN2
E014: DE40    		SBC	A,'A'-1		;CONVERT POSSIBLE DRIVE SPEC TO NUMBER
E016: 47      		LD	B,A		;STORE NUMBER (A:=0, B:=1, ETC) IN B
E017: 13      		INC	DE		;PT TO NEXT CHAR
E018: 1A      		LD	A,(DE)		;SEE IF IT IS A COLON (:)
E019: FE3A    		CP	':'
E01B: 2807    		JR	Z,SCAN3		;YES, WE HAVE A DRIVE SPEC
E01D: 1B      		DEC	DE		;NO, BACK UP PTR TO FIRST NON-BLANK CHAR
E01E:         	SCAN2:
E01E: 3A84DE  		LD	A,(TDRIVE)	;SET 1ST BYTE OF FCBDN AS DEFAULT DRIVE
E021: 77      		LD	(HL),A
E022: 1806    		JR	SCAN4
E024:         	SCAN3:
E024: 78      		LD	A,B		;WE HAVE A DRIVE SPEC
E025: 32F9DF  		LD	(TEMPDR),A	;SET TEMPORRY DRIVE
E028: 70      		LD	(HL),B		;SET 1ST BYTE OF FCBDN AS SPECIFIED DRIVE
E029: 13      		INC	DE		;PT TO BYTE AFTER ':'
              	;
              	; EXTRACT FILENAME FROM POSSIBLE FILENAME.TYP
              	;
E02A:         	SCAN4:
E02A: AF      		XOR	A		;A=0
E02B: 32BEDC  		LD	(QMCNT),A	;INIT COUNT OF NUMBER OF QUESTION MARKS IN FCB
E02E: 0608    		LD	B,8		;MAX OF 8 CHARS IN FILE NAME
E030: CD52E0  		CALL	SCANF		;FILL FCB FILE NAME
              	;
              	; EXTRACT FILE TYPE FROM POSSIBLE FILENAME.TYP
              	;
E033: 0603    		LD	B,3		;PREPARE TO EXTRACT TYPE
E035: FE2E    		CP	'.'		;IF (DE) DELIMITER IS A '.', WE HAVE A TYPE
E037: 2006    		JR	NZ,SCAN15	;FILL FILE TYPE BYTES WITH <SP>
E039: 13      		INC	DE		;PT TO CHAR IN COMMAND LINE AFTER '.'
E03A: CD52E0  		CALL	SCANF		;FILL FCB FILE TYPE
E03D: 1803    		JR	SCAN16		;SKIP TO NEXT PROCESSING
E03F:         	SCAN15:
E03F: CD73E0  		CALL	SCANF4		;SPACE FILL
              	;
              	; FILL IN EX, S1, S2, AND RC WITH ZEROES
              	;
E042:         	SCAN16:
E042: 0604    		LD	B,4		;4 BYTES
E044:         	SCAN17:
E044: 23      		INC	HL		;PT TO NEXT BYTE IN FCBDN
E045: 3600    		LD	(HL),0
E047: 10FB    		DJNZ	SCAN17
              	;
              	; SCAN COMPLETE -- DE PTS TO DELIMITER BYTE AFTER TOKEN
              	;
E049: ED5359DC		LD	(CIBPTR),DE
              	;
              	; SET ZERO FLAG TO INDICATE PRESENCE OF '?' IN FILENAME.TYP
              	;
E04D: 3ABEDC  		LD	A,(QMCNT)	;GET NUMBER OF QUESTION MARKS
E050: B7      		OR	A		;SET ZERO FLAG TO INDICATE ANY '?'
E051: C9      		RET
              	;
              	;  SCANF -- SCAN TOKEN PTED TO BY DE FOR A MAX OF B BYTES; PLACE IT INTO
              	;    FILE NAME FIELD PTED TO BY HL; EXPAND AND INTERPRET WILD CARDS OF
              	;    '*' AND '?'; ON EXIT, DE PTS TO TERMINATING DELIMITER
              	;
E052:         	SCANF:
E052: CD2EDF  		CALL	SDELM		;DONE IF DELIMITER ENCOUNTERED - <SP> FILL
E055: 281C    		JR	Z,SCANF4
E057: 23      		INC	HL		;PT TO NEXT BYTE IN FCBDN
E058: FE2A    		CP	'*'		;IS (DE) A WILD CARD?
E05A: 2007    		JR	NZ,SCANF1	;CONTINUE IF NOT
E05C: 363F    		LD	(HL),'?'	;PLACE '?' IN FCBDN AND DON'T ADVANCE DE IF SO
E05E: CD79E0  		CALL	SCQ		;SCANNER COUNT QUESTION MARKS
E061: 1807    		JR	SCANF2
E063:         	SCANF1:
E063: 77      		LD	(HL),A		;STORE FILENAME CHAR IN FCBDN
E064: 13      		INC	DE		;PT TO NEXT CHAR IN COMMAND LINE
E065: FE3F    		CP	'?'		;CHECK FOR QUESTION MARK (WILD)
E067: CC79E0  		CALL	Z,SCQ		;SCANNER COUNT QUESTION MARKS
E06A:         	SCANF2:
E06A: 10E6    		DJNZ	SCANF		;DECREMENT CHAR COUNT UNTIL 8 ELAPSED
E06C:         	SCANF3:
E06C: CD2EDF  		CALL	SDELM		;8 CHARS OR MORE - SKIP UNTIL DELIMITER
E06F: C8      		RET	Z		;ZERO FLAG SET IF DELIMITER FOUND
E070: 13      		INC	DE		;PT TO NEXT CHAR IN COMMAND LINE
E071: 18F9    		JR	SCANF3
              	;
              	;  FILL MEMORY POINTED TO BY HL WITH SPACES FOR B BYTES
              	;
E073:         	SCANF4:
E073: 23      		INC	HL		;PT TO NEXT BYTE IN FCBDN
E074: 3620    		LD	(HL),' '	;FILL FILENAME PART WITH <SP>
E076: 10FB    		DJNZ	SCANF4
E078: C9      		RET
              	;
              	;  INCREMENT QUESTION MARK COUNT FOR SCANNER
              	;    THIS ROUTINE INCREMENTS THE COUNT OF THE NUMBER OF QUESTION MARKS IN
              	;    THE CURRENT FCB ENTRY
              	;
E079:         	SCQ:
E079: 3ABEDC  		LD	A,(QMCNT)	;GET COUNT
E07C: 3C      		INC	A		;INCREMENT
E07D: 32BEDC  		LD	(QMCNT),A	;PUT COUNT
E080: C9      		RET
              	;
              	; CMDTBL (COMMAND TABLE) SCANNER
              	;   ON RETURN, HL PTS TO ADDRESS OF COMMAND IF CPR-RESIDENT
              	;   ON RETURN, ZERO FLAG SET MEANS CPR-RESIDENT COMMAND
              	;
E081:         	CMDSER:
E081: 2165DD  		LD	HL,CMDTBL	;PT TO COMMAND TABLE
              	;
              		IF	SECURE
              		LD	C,NRCMDS
              		LD	A,(WHEEL)	;SEE IF NON-RESTRCTED
              		CP	RESTRCT
              		JR	Z,CMS1		;PASS IF RESTRCTED
              		ENDIF			;SECURE
              	;
E084: 0E0B    		LD	C,NCMNDS	;SET COMMAND COUNTER
E086:         	CMS1:
E086: 119CDC  		LD	DE,FCBFN 	;PT TO STORED COMMAND NAME
E089: 0604    		LD	B,NCHARS	;NUMBER OF CHARS/COMMAND (8 MAX)
E08B:         	CMS2:
E08B: 1A      		LD	A,(DE)		;COMPARE AGAINST TABLE ENTRY
E08C: BE      		CP	(HL)
E08D: 200A    		JR	NZ,CMS3		;NO MATCH
E08F: 13      		INC	DE		;PT TO NEXT CHAR
E090: 23      		INC	HL
E091: 10F8    		DJNZ	CMS2		;COUNT DOWN
E093: 1A      		LD	A,(DE)		;NEXT CHAR IN INPUT COMMAND MUST BE <SP>
E094: FE20    		CP	' '
E096: 2004    		JR	NZ,CMS4
E098: C9      		RET			;COMMAND IS CPR-RESIDENT (ZERO FLAG SET)
E099:         	CMS3:
E099: 23      		INC	HL		;SKIP TO NEXT COMMAND TABLE ENTRY
E09A: 10FD    		DJNZ	CMS3
E09C:         	CMS4:
E09C: 23      		INC	HL		;SKIP ADDRESS
E09D: 23      		INC	HL
E09E: 0D      		DEC	C		;DECREMENT TABLE ENTRY NUMBER
E09F: 20E5    		JR	NZ,CMS1
E0A1: 0C      		INC	C		;CLEAR ZERO FLAG
E0A2: C9      		RET			;COMMAND IS DISK-RESIDENT (ZERO FLAG CLEAR)
              	;
              	;**** Section 5 ****
              	; CPR-Resident Commands
              	;
              	;
              	;Section 5A
              	;Command: DIR
              	;Function:  To display a directory of the files on disk
              	;Forms:
              	;	DIR <afn>	Displays the DIR files
              	;	DIR <afn> S	Displays the SYS files
              	;	DIR <afn> A	Display both DIR and SYS files
              	;
              		IF	CPRDIR
              	;
E0A3:         	DIR:
E0A3: 3E80    		LD	A,80H		;SET SYSTEM BIT EXAMINATION
E0A5: F5      		PUSH	AF
E0A6: CD02E0  		CALL	SCANER		;EXTRACT POSSIBLE D:FILENAME.TYP TOKEN
E0A9: CDE4DF  		CALL	SLOGIN		;LOG IN DRIVE IF NECESSARY
E0AC: 219CDC  		LD	HL,FCBFN 	;MAKE FCB WILD (ALL '?') IF NO FILENAME.TYP
E0AF: 7E      		LD	A,(HL)		;GET FIRST CHAR OF FILENAME.TYP
E0B0: FE20    		CP	' '		;IF <SP>, ALL WILD
E0B2: CC4CE1  		CALL	Z,FILLQ
E0B5: CD4BDF  		CALL	ADVAN		;LOOK AT NEXT INPUT CHAR
E0B8: 0600    		LD	B,0		;SYS TOKEN DEFAULT
E0BA: 2816    		JR	Z,DIR2		;JUMP; THERE ISN'T ONE
E0BC: FE41    		CP	SYSFLG		;SYSTEM FLAG SPECIFIER?
E0BE: 2806    		JR	Z,GOTSYS	;GOT SYSTEM SPECIFIER
E0C0: FE53    		CP	SOFLG		;SYS ONLY?
E0C2: 200E    		JR	NZ,DIR2
E0C4: 0680    		LD	B,80H		;FLAG SYS ONLY
E0C6:         	GOTSYS:
E0C6: 13      		INC	DE
E0C7: ED5359DC		LD	(CIBPTR),DE
E0CB: FE53    		CP	SOFLG		;SYS ONLY SPEC?
E0CD: 2803    		JR	Z,DIR2		;THEN LEAVE BIT SPEC UNCHAGNED
E0CF: F1      		POP	AF		;GET FLAG
E0D0: AF      		XOR	A		;SET NO SYSTEM BIT EXAMINATION
E0D1: F5      		PUSH	AF 
E0D2:         	DIR2:
E0D2: F1      		POP	AF		;GET FLAG
E0D3:         	DIR2A:
              					;DROP INTO DIRPR TO PRINT DIRECTORY
              					; THEN RESTART CPR
              		ENDIF			;CPRDIR
              	;
              	; DIRECTORY PRINT ROUTINE; ON ENTRY, MSB OF A IS 1 (80H) IF SYSTEM FILES
              	; EXCLUDED. THIS ROUTINE IS ALSO USED BY ERA.
              	;
E0D3:         	DIRPR:
E0D3: 57      		LD	D,A		;STORE SYSTEM FLAG IN D
E0D4: 1E00    		LD	E,0		;SET COLUMN COUNTER TO ZERO
E0D6: D5      		PUSH	DE		;SAVE COLUMN COUNTER (E) AND SYSTEM FLAG (D)
E0D7: 78      		LD	A,B		;SYS ONLY SPECIFIER
E0D8: 32F3E0  		LD	(SYSTST),A
E0DB: CD4FDE  		CALL	SEARF		;SEARCH FOR SPECIFIED FILE (FIRST OCCURRANCE)
E0DE: CC5ADD  		CALL	Z,PRNNF		;PRINT NO FILE MSG;REG A NOT CHANGED
              	;
              	; ENTRY SELECTION LOOP; ON ENTRY, A=OFFSET FROM SEARF OR SEARN
              	;
E0E1:         	DIR3:
E0E1: 2867    		JR	Z,DIR11		;DONE IF ZERO FLAG SET
E0E3: 3D      		DEC	A		;ADJUST TO RETURNED VALUE
E0E4: 0F      		RRCA			;CONVERT NUMBER TO OFFSET INTO TBUFF
E0E5: 0F      		RRCA
E0E6: 0F      		RRCA
E0E7: E660    		AND	60H
E0E9: 4F      		LD	C,A		;OFFSET INTO TBUFF IN C (C=OFFSET TO ENTRY)
E0EA: 3E0A    		LD	A,10		;ADD 10 TO PT TO SYSTEM FILE ATTRIBUTE BIT
E0EC: CDDBDF  		CALL	DIRPTR
E0EF: D1      		POP	DE		;GET SYSTEM BIT MASK FROM D
E0F0: D5      		PUSH	DE
E0F1: A2      		AND	D		;MASK FOR SYSTEM BIT
E0F3:         	SYSTST	EQU	$+1		;POINTER TO IN-THE-CODE BUFFER SYSTST
E0F2: FE00    		CP	0
E0F4: 204A    		JR	NZ,DIR10
E0F6: D1      		POP	DE		;GET ENTRY COUNT (=<CR> COUNTER)
E0F7: 7B      		LD	A,E		;ADD 1 TO IT
E0F8: 1C      		INC	E
E0F9: D5      		PUSH	DE		;SAVE IT
              	;
              		IF	TWOCOL
              		AND	01H		;OUTPUT <CRLF> IF 2 ENTRIES PRINTED IN LINE
              		ENDIF			;TWOCOL
              	;
              		IF	TWOCOL
              	        ELSE
E0FB:         	TWOPOK	EQU	$+1		;FOR APPLE PATCHING
E0FA: E603    		AND	03H		;OUTPUT <CRLF> IF 4 ENTRIES PRINTED IN LINE
              		ENDIF			;NOT TWOCOL
              	;
E0FC: F5      		PUSH	AF
E0FD: 2005    		JR	NZ,DIR4
E0FF: CDA7DD  		CALL	CRLF		;NEW LINE
E102: 1808    		JR	DIR5
E104:         	DIR4:
E104: CD15DE  		CALL	PRINT
              	;
              		IF	WIDE
E107: 2020    		DEFM	'  '		;2 SPACES
E109: 7C      		DEFB	FENCE		;THEN FENCE CHAR
E10A: 20A0    		DEFB	' ',' '+80H	;THEN 2 MORE SPACES
              	;	ENDIF
              	;
              	        ELSE
              		DEFB	' '		;SPACE
              		DEFB	FENCE		;THEN FENCE CHAR
              		DEFB	' '+80H		;THEN SPACE
              		ENDIF
              	;
E10C:         	DIR5:
E10C: 0601    		LD	B,01H		;PT TO 1ST BYTE OF FILE NAME
E10E:         	DIR6:
E10E: 78      		LD	A,B		;A=OFFSET
E10F: CDDBDF  		CALL	DIRPTR		;HL NOW PTS TO 1ST BYTE OF FILE NAME
E112: E67F    		AND	7FH		;MASK OUT MSB
E114: FE20    		CP	' '		;NO FILE NAME?
E116: 2013    		JR	NZ,DIR8		;PRINT FILE NAME IF PRESENT
E118: F1      		POP	AF
E119: F5      		PUSH	AF
E11A: FE03    		CP	03H
E11C: 200B    		JR	NZ,DIR7
E11E: 3E09    		LD	A,09H		;PT TO 1ST BYTE OF FILE TYPE
E120: CDDBDF  		CALL	DIRPTR		;HL NOW PTS TO 1ST BYTE OF FILE TYPE
E123: E67F    		AND	7FH		;MASK OUT MSB
E125: FE20    		CP	' '		;NO FILE TYPE?
E127: 2816    		JR	Z,DIR9		;CONTINUE IF SO
E129:         	DIR7:
E129: 3E20    		LD	A,' '		;OUTPUT <SP>
E12B:         	DIR8:
E12B: CDAEDD  		CALL	CONOUT		;PRINT CHAR
E12E: 04      		INC	B		;INCR CHAR COUNT
E12F: 78      		LD	A,B
E130: FE0C    		CP	12		;END OF FILENAME.TYP?
E132: 300B    		JR	NC,DIR9		;CONTINUE IF SO
E134: FE09    		CP	09H		;END IF FILENAME ONLY?
E136: 20D6    		JR	NZ,DIR6		;PRINT TYP IF SO
E138: 3E2E    		LD	A,'.'		;PRINT DOT BETWEEN FILE NAME AND TYPE
E13A: CDAEDD  		CALL	CONOUT
E13D: 18CF    		JR	DIR6
E13F:         	DIR9:
E13F: F1      		POP	AF
E140:         	DIR10:
E140: CD00DF  		CALL	BREAK		;CHECK FOR ABORT
E143: 2005    		JR	NZ,DIR11
E145: CD56DE  		CALL	SEARN		;SEARCH FOR NEXT FILE
E148: 1897    		JR	DIR3		;CONTINUE
E14A:         	DIR11:
E14A: D1      		POP	DE		;RESTORE STACK
E14B: C9      		RET
              	;
              	; FILL FCB @HL WITH '?'
              	;
E14C:         	FILLQ:
E14C: 060B    		LD	B,11		;NUMBER OF CHARS IN FN & FT
E14E:         	FQLP:
E14E: 363F    		LD	(HL),'?'	;STORE '?'
E150: 23      		INC	HL
E151: 10FB    		DJNZ	FQLP
E153: C9      		RET
              	;
              	;Section 5B
              	;Command: ERA
              	;Function:  Erase files
              	;Forms:
              	;	ERA <afn>	Erase Specified files and print their names
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
              	;
E154:         	ERA:
E154: CD02E0  		CALL	SCANER		;PARSE FILE SPECIFICATION
E157: FE0B    		CP	11		;ALL WILD (ALL FILES = 11 '?')?
E159: 2012    		JR	NZ,ERA1		;IF NOT, THEN DO ERASES
E15B: CD10DE  		CALL	PRINTC
E15E: 416C6C  		DEFM	'All'
E161: BF      		DEFB	'?'+80H
E162: CDBBDD  		CALL	CONIN		;GET REPLY
E165: FE59    		CP	'Y'		;YES?
E167:         	ERARJ:
E167: C2F8DC  		JP	NZ,RESTRT	;RESTART CPR IF NOT
E16A: CDA7DD  		CALL	CRLF		;NEW LINE
E16D:         	ERA1:
E16D: CDE4DF  		CALL	SLOGIN		;LOG IN SELECTED DISK IF ANY
E170: AF      		XOR	A		;PRINT ALL FILES (EXAMINE SYSTEM BIT)
E171: 47      		LD	B,A		;NO SYS-ONLY OPT TO DIRPR
E172: CDD3E0  		CALL	DIRPR		;PRINT DIRECTORY OF ERASED FILES
              	;
              		IF	EPRMPT
              	;
              	;  QUERY USER AFTER FILES ARE SEEN, AND GIVE ONE LAST CHANCE TO BACK OUT
              	;
              		LD	A,E		;HOW MANY FILES DISPLAYED?
              		OR	A
              		JP	Z,RESTRT	;IF NONE, DON'T ASK OR DELETE
              		CALL	PRINTC		;PROMPT
              		DEFM	'Ok'
              		DEFB	'?'+80H
              		CALL	CONIN		;GET REPLY FOLDED
              		CP	'Y'		;YES?
              		JR	NZ,ERARJ	;GET OUT IF NOT
              		ENDIF			;EPRMPT
              	;
E175: 119BDC  		LD	DE,FCBDN 	;DELETE FILE(S) SPECIFIED
E178: C365DE  		JP	DELETE		;RESTART CPR AFTER DELETE
              	;
              		ENDIF			;RAS
              	;
              	;Section 5C
              	;Command: LIST
              	;Function:  Print out specified file on the LST: Device
              	;Forms:
              	;	LIST <ufn>	Print file (NO Paging)
              	;
              		IF	CPRLST
E17B:         	LIST:
E17B: 3EFF    		LD	A,0FFH		;TURN ON PRINTER FLAG
E17D: 1801    		JR	TYPE0
              		ENDIF			;CPRLST
              	;
              	;Section 5D
              	;Command: TYPE
              	;Function:  Print out specified file on the CON: Device
              	;Forms:
              	;	TYPE <ufn>	Print file
              	;	TYPE <ufn> P	Print file with paging flag	
              	;
              		IF	CPRTYP
E17F:         	TYPE:
              		ENDIF			;CPRTYP
              	;
              		IF	CPRTYP AND CPRLST
E17F: AF      		XOR	A		;TURN OFF PRINTER FLAG
              	;
              	; ENTRY POINT FOR CPR LIST FUNCTION (LIST)
              	;
E180:         	TYPE0:
E180: 32D8DD  		LD	(PRFLG),A	;SET FLAG
              		ENDIF			;CPRTYP AND CPRLST
              	;
              		IF	CPRTYP
E183: CD02E0  		CALL	SCANER		;EXTRACT FILENAME.TYP TOKEN
E186: C211DF  		JP	NZ,ERROR	;ERROR IF ANY QUESTION MARKS
E189: CD4BDF  		CALL	ADVAN		;GET PGDFLG IF IT'S THERE
E18C: 32F5DD  		LD	(PGFLG),A	;SAVE IT AS A FLAG
E18F: 2805    		JR	Z,NOSLAS	;JUMP IF INPUT ENDED
E191: 13      		INC	DE		;PUT NEW BUF POINTER
E192: EB      		EX	DE,HL
E193: 2259DC  		LD	(CIBPTR),HL
E196:         	NOSLAS:
E196: CDE4DF  		CALL	SLOGIN		;LOG IN SELECTED DISK IF ANY
E199: CD3DDE  		CALL	OPENF		;OPEN SELECTED FILE
E19C: CA09E2  		JP	Z,TYPE4		;ABORT IF ERROR
E19F: CDA7DD  		CALL	CRLF		;NEW LINE
E1A2: 3E17    		LD	A,NLINES-1	;SET LINE COUNT
E1A4: 32BCDC  		LD	(PAGCNT),A
E1A7: 21BDDC  		LD	HL,CHRCNT	;SET CHAR POSITION/COUNT
E1AA: 36FF    		LD	(HL),0FFH	;EMPTY LINE
E1AC: 0600    		LD	B,0		;SET TAB CHAR COUNTER
E1AE:         	TYPE1:
E1AE: 21BDDC  		LD	HL,CHRCNT	;PT TO CHAR POSITION/COUNT
E1B1: 7E      		LD	A,(HL)		;END OF BUFFER?
E1B2: FE80    		CP	80H
E1B4: 3809    		JR	C,TYPE2
E1B6: E5      		PUSH	HL		;READ NEXT BLOCK
E1B7: CD04DE  		CALL	READF
E1BA: E1      		POP	HL
E1BB: 204A    		JR	NZ,TYPE3	;ERROR?
E1BD: AF      		XOR	A		;RESET COUNT
E1BE: 77      		LD	(HL),A
E1BF:         	TYPE2:
E1BF: 34      		INC	(HL)		;INCREMENT CHAR COUNT
E1C0: 218000  		LD	HL,TBUFF 	;PT TO BUFFER
E1C3: CD58DF  		CALL	ADDAH		;COMPUTE ADDRESS OF NEXT CHAR FROM OFFSET
E1C6: 7E      		LD	A,(HL)		;GET NEXT CHAR
E1C7: E67F    		AND	7FH		;MASK OUT MSB
E1C9: FE1A    		CP	1AH		;END OF FILE (^Z)?
E1CB: C8      		RET	Z		;RESTART CPR IF SO
              	;
              	; OUTPUT CHAR TO CON: OR LST: DEVICE WITH TABULATION
              	;
              		IF	WSTYPE		;WORDSTAR HYPHEN CHECK
E1CC: FE1F    		CP	1FH		;IS CHAR WORDSTAR EOL HYPHEN?
E1CE: 2002    		JR	NZ,NOHYPH	;PASS IF NOT
E1D0: 3E2D    		LD	A,'-'		;YES, MAKE IT A REAL HYPHEN
E1D2:         	NOHYPH:
              		ENDIF			;WSTYPE
              	;
E1D2: FE20    		CP	' '		;IS CHAR CONTROL CODE?
E1D4: 3023    		JR	NC,PRT		;GO BOP CHAR COUNT AND PRINT IF NOT
E1D6: FE0D    		CP	CR		;IS CHAR A CR?
E1D8: 281D    		JR	Z,YESCR		;IF SO, GO ZERO B THEN PRINT
E1DA: FE0C    		CP	FFEED		;FORM FEED?
E1DC: 2819    		JR	Z,YESCR		;MANY PRINTERS RETURN CARRIAGE ON THIS
E1DE: FE0A    		CP	LF		;LINE FEED?
E1E0: 2818    		JR	Z,NOBOP		;PRINT, BUT DON'T BOP B
E1E2: FE07    		CP	BEL		;BELL?
E1E4: 2814    		JR	Z,NOBOP		;GO RING BUT DON'T BOP B
E1E6: FE09    		CP	TAB		;TAB?
E1E8: 2013    		JR	NZ,TYPE2L	;IF NOT, NO OTHER CHOICES, TOSS CONTROL
E1EA:         	LTAB:
E1EA: 3E20    		LD	A,' '		;<SP>
E1EC: CDD6DD  		CALL	LCOUT
E1EF: 04      		INC	B		;INCR POS COUNT
E1F0: 78      		LD	A,B
E1F1: E607    		AND	7
E1F3: 20F5    		JR	NZ,LTAB
E1F5: 1806    		JR	TYPE2L
              	;
E1F7: 06FF    	YESCR:	LD	B,0FFH		;COMBINE WITH INC BELOW TO GET ZERO
              	;
E1F9: 04      	PRT:	INC	B		;INCREMENT CHAR COUNT
E1FA: CDD6DD  	NOBOP:	CALL	LCOUT		;PRINT IT
              	;
              	; CONTINUE PROCESSING
              	;
              	;
E1FD:         	TYPE2L:
E1FD: CD00DF  		CALL	BREAK		;CHECK FOR ABORT
E200: 28AC    		JR	Z,TYPE1		;CONTINUE IF NO CHAR
E202: FE03    		CP	'C'-'@' 	;^C?
E204: C8      		RET	Z		;RESTART IF SO
E205: 18A7    		JR	TYPE1
E207:         	TYPE3:
E207: 3D      		DEC	A		;NO ERROR?
E208: C8      		RET	Z		;RESTART CPR
E209:         	TYPE4:
E209: C3F6E3  		JP	ERRLOG
              		ENDIF			;CPRTYP
              	;
              	;Section 5E
              	;Command: SAVE
              	;Function:  To save the contents of the TPA onto disk as a file
              	;Forms:
              	;	SAVE <Number of Pages> <ufn>
              	;				Save specified number of pages (start at 100H)
              	;				from TPA into specified file; <Number of
              	;				Pages> is in DEC
              	;	SAVE <Number of Sectors> <ufn> S
              	;				Like SAVE above, but numeric argument specifies
              	;				number of sectors rather than pages
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
              	;
E20C:         	SAVE:
E20C: CD5DDF  		CALL	NUMBER		;EXTRACT NUMBER FROM COMMAND LINE
E20F: 6F      		LD	L,A		;HL=PAGE COUNT
E210: 2600    		LD	H,0
E212: E5      		PUSH	HL		;SAVE PAGE COUNT
E213: CD62E2  		CALL	EXTEST		;TEST FOR EXISTENCE OF FILE AND ABORT IF SO
E216: 0E16    		LD	C,16H		;BDOS MAKE FILE
E218: CD46DE  		CALL	GRBDOS
E21B: E1      		POP	HL		;GET PAGE COUNT
E21C: 2841    		JR	Z,SAVE3		;ERROR?
E21E: AF      		XOR	A		;SET RECORD COUNT FIELD OF NEW FILE'S FCB
E21F: 32BBDC  		LD	(FCBCR),A
E222: CD4BDF  		CALL	ADVAN		;LOOK FOR 'S' FOR SECTOR OPTION
E225: 13      		INC	DE		;PT TO AFTER 'S' TOKEN
E226: FE53    		CP	SECTFLG
E228: 2802    		JR	Z,SAVE0
E22A: 1B      		DEC	DE		;NO 'S' TOKEN, SO BACK UP
E22B: 29      		ADD	HL,HL		;DOUBLE IT FOR HL=SECTOR (128 BYTES) COUNT
E22C:         	SAVE0:
E22C: ED5359DC		LD	(CIBPTR),DE	;SET PTR TO BAD TOKEN OR AFTER GOOD TOKEN
E230: 110001  		LD	DE,TPA		;PT TO START OF SAVE AREA (TPA)
E233:         	SAVE1:
E233: 7C      		LD	A,H		;DONE WITH SAVE?
E234: B5      		OR	L		;HL=0 IF SO
E235: 2818    		JR	Z,SAVE2
E237: 2B      		DEC	HL		;COUNT DOWN ON SECTORS
E238: E5      		PUSH	HL		;SAVE PTR TO BLOCK TO SAVE
E239: 218000  		LD	HL,128		;128 BYTES PER SECTOR
E23C: 19      		ADD	HL,DE		;PT TO NEXT SECTOR
E23D: E5      		PUSH	HL		;SAVE ON STACK
E23E: CD2FDE  		CALL	DMASET		;SET DMA ADDRESS FOR WRITE (ADDRESS IN DE)
E241: 119BDC  		LD	DE,FCBDN 	;WRITE SECTOR
E244: 0E15    		LD	C,15H		;BDOS WRITE SECTOR
E246: CD09DE  		CALL	BDOSB		;SAVE BC
E249: D1      		POP	DE		;GET PTR TO NEXT SECTOR IN DE
E24A: E1      		POP	HL		;GET SECTOR COUNT
E24B: 28E6    		JR	Z,SAVE1		;CONTINUE IF NO WRITE ERROR
E24D: 1809    		JR	PRNLE		;GO PRINT ERROR AND RESET DMA
E24F:         	SAVE2:
E24F: 119BDC  		LD	DE,FCBDN 	;CLOSE SAVED FILE
E252: CD4BDE  		CALL	CLOSE
E255: 3C      		INC	A		;ERROR?
E256: 2007    		JR	NZ,SAVE3	;PASS IF OK
              	;
              	;  PRNLE IS ALSO USED BY MEMLOAD FOR TPA FULL ERROR
              	;
E258: CD10DE  	PRNLE:	CALL	PRINTC		;DISK OR MEM FULL
E25B: 46756C  		DEFM	'Ful'
E25E: EC      		DEFB	'l'+80H
              	;
E25F: C32CDE  	SAVE3:	JP	DEFDMA		;SET DMA TO 0080 AND RESTART CPR
              					; OR RETURN TO MLERR
              	;
              	; Test File in FCB for existence, ask user to delete if so, and abort if he
              	;  choses not to
              	;
E262:         	EXTEST:
E262: CD02E0  		CALL	SCANER		;EXTRACT FILE NAME
E265: C211DF  		JP	NZ,ERROR	;'?' IS NOT PERMITTED
E268: CDE4DF  		CALL	SLOGIN		;LOG IN SELECTED DISK
E26B: CD4FDE  		CALL	SEARF		;LOOK FOR SPECIFIED FILE
E26E: 119BDC  		LD	DE,FCBDN	;PT TO FILE FCB
E271: C8      		RET	Z		;OK IF NOT FOUND
E272: D5      		PUSH	DE		;SAVE PTR TO FCB
E273: CD10DE  		CALL	PRINTC
E276: 44656C65		DEFM	'Delete File'
E27A: 74652046	
E27E: 696C65  	
E281: BF      		DEFB	'?'+80H
E282: CDBBDD  		CALL	CONIN		;GET RESPONSE
E285: D1      		POP	DE		;GET PTR TO FCB
E286: FE59    		CP	'Y'		;KEY ON YES
E288: C246DD  		JP	NZ,RSTCPR	;RESTART IF NO, SP RESET EVENTUALLY
E28B: D5      		PUSH	DE		;SAVE PTR TO FCB
E28C: CD65DE  		CALL	DELETE		;DELETE FILE
E28F: D1      		POP	DE		;GET PTR TO FCB
E290: C9      		RET
              	;
              		ENDIF			;RAS
              	;
              	;Section 5F
              	;Command: REN
              	;Function:  To change the name of an existing file
              	;Forms:
              	;	REN <New ufn>=<Old ufn>	Perform function
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
              	;
E291:         	REN:
E291: CD62E2  		CALL	EXTEST		;TEST FOR FILE EXISTENCE AND RETURN
              					; IF FILE DOESN'T EXIST; ABORT IF IT DOES
E294: 3AF9DF  		LD	A,(TEMPDR)	;SAVE CURRENT DEFAULT DISK
E297: F5      		PUSH	AF		;SAVE ON STACK
E298:         	REN0:
E298: 219BDC  		LD	HL,FCBDN 	;SAVE NEW FILE NAME
E29B: 11ABDC  		LD	DE,FCBDM
E29E: 011000  		LD	BC,16		;16 BYTES
E2A1: EDB0    		LDIR
E2A3: CD4BDF  		CALL	ADVAN		;ADVANCE CIBPTR
E2A6: FE3D    		CP	'='		;'=' OK
E2A8: 2028    		JR	NZ,REN4
E2AA:         	REN1:
E2AA: EB      		EX	DE,HL		;PT TO CHAR AFTER '=' IN HL
E2AB: 23      		INC	HL
E2AC: 2259DC  		LD	(CIBPTR),HL	;SAVE PTR TO OLD FILE NAME
E2AF: CD02E0  		CALL	SCANER		;EXTRACT FILENAME.TYP TOKEN
E2B2: 201E    		JR	NZ,REN4		;ERROR IF ANY '?'
E2B4: F1      		POP	AF		;GET OLD DEFAULT DRIVE
E2B5: 47      		LD	B,A		;SAVE IT
E2B6: 21F9DF  		LD	HL,TEMPDR	;COMPARE IT AGAINST CURRENT DEFAULT DRIVE
E2B9: 7E      		LD	A,(HL)		;MATCH?
E2BA: B7      		OR	A
E2BB: 2804    		JR	Z,REN2
E2BD: B8      		CP	B		;CHECK FOR DRIVE ERROR
E2BE: 70      		LD	(HL),B
E2BF: 2011    		JR	NZ,REN4
E2C1:         	REN2:
E2C1: 70      		LD	(HL),B
E2C2: AF      		XOR	A
E2C3: 329BDC  		LD	(FCBDN),A	;SET DEFAULT DRIVE
E2C6: 119BDC  		LD	DE,FCBDN 	;RENAME FILE
E2C9: 0E17    		LD	C,17H		;BDOS RENAME FCT
E2CB: CD46DE  		CALL	GRBDOS
E2CE: C0      		RET	NZ
E2CF:         	REN3:
E2CF: CD5ADD  		CALL	PRNNF		;PRINT NO FILE MSG
E2D2:         	REN4:
E2D2: C3F6E3  		JP	ERRLOG
              	;
              		ENDIF			;RAS
              	;
              	;Section 5G
              	;Command: USER
              	;Function:  Change current USER number
              	;Forms:
              	;	USER <unum>	Select specified user number;<unum> is in DEC
              	;
              		IF	DRUSER		;IF DRIVE/USER CODE OK...
E2D5:         	USER:
E2D5: CD0BDF  		CALL	USRNUM		;EXTRACT USER NUMBER FROM COMMAND LINE
E2D8: 5F      		LD	E,A		;PLACE USER NUMBER IN E
E2D9: CD70DE  	SUSER:	CALL	SETUSR		;SET SPECIFIED USER
              		ENDIF			;DRUSER
E2DC:         	RSTJP:
E2DC: C349DD  		JP	RCPRNL		;RESTART CPR
              	;
              	;Section 5H
              	;Command: DFU
              	;Function:  Set the Default User Number for the command/file scanner
              	;	     (MEMLOAD)
              	;	    Note: When under SECURE mode, this will select the second
              	;	          user area to check for programs (normally user 15).
              	;
              	;Forms:
              	;	DFU <unum>	Select Default User Number;<unum> is in DEC
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
E2DF:         	DFU:
E2DF: CD0BDF  		CALL	USRNUM		;GET USER NUMBER
E2E2: 32B3E3  		LD	(DFUSR),A	;PUT IT AWAY
E2E5: 18F5    		JR	RSTJP		;RESTART CPR (NO DEFAULT LOGIN)
              		ENDIF			;NOT RAS
              	;
              	;Section 5I
              	;Command: JUMP
              	;Function:  To Call the program (subroutine) at the specified address
              	;	     without loading from disk
              	;Forms:
              	;	JUMP <adr>		Call at <adr>;<adr> is in HEX
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
              	;
E2E7:         	JUMP:
E2E7: CD9BDF  		CALL	HEXNUM		;GET LOAD ADDRESS IN HL
E2EA: 1846    		JR	CALLPROG	;PERFORM CALL
              	;
              		ENDIF			;RAS
              	;
              	;Section 5J
              	;Command: GO
              	;Function:  To Call the program in the TPA without loading
              	;	     loading from disk. Same as JUMP 100H, but much
              	;	     more convenient, especially when used with
              	;	     parameters for programs like STAT. Also can be
              	;	     allowed on remote-access systems with no problems.
              	;
              	;Form:
              	;	GO <parameters like for COMMAND>
              	;
              		IF	RAS		;ONLY IF RAS
              	        ELSE
              	;
E2EC: 210001  	GO:	LD	HL,TPA		;Always to TPA
E2EF: 1841    		JR	CALLPROG	;Perform call
              	;
              		ENDIF			;END OF GO FOR RAS
              	;
              	;Section 5K
              	;Command: COM file processing
              	;Function:  To load the specified COM file from disk and execute it
              	;Forms:
              	;	<command>
              	;
E2F1:         	COM:
E2F1: 3A9CDC  		LD	A,(FCBFN)	;ANY COMMAND?
E2F4: FE20    		CP	' '		;' ' MEANS COMMAND WAS 'D:' TO SWITCH
E2F6: 201F    		JR	NZ,COM1		;NOT <SP>, SO MUST BE TRANSIENT OR ERROR
E2F8: 3AF9DF  		LD	A,(TEMPDR)	;LOOK FOR DRIVE SPEC
E2FB: B7      		OR	A		;IF ZERO, JUST BLANK
E2FC: CA49DD  		JP	Z,RCPRNL
E2FF: 3D      		DEC	A		;ADJUST FOR LOG IN
E300: 3284DE  		LD	(TDRIVE),A	;SET DEFAULT DRIVE
E303: CD83DE  		CALL	SETU0D		;SET DRIVE WITH USER 0
E306: CD38DE  		CALL	LOGIN		;LOG IN DRIVE
              	;
              		IF	DRUSER		;DRIVE/USER HACKERY OK?
E309: CD0BDF  		CALL	USRNUM		;GET USER #, IF ANY
E30C: 5F      		LD	E,A		;GET IT READY FOR BDOS
E30D: 3A9CDC  		LD	A,(FCBFN)	;SEE IF # SPECIFIED
E310: FE20    		CP	' '
E312: 20C5    		JR	NZ,SUSER	;SELECT IF WANTED
              		ENDIF			;DRUSER
              	;
E314: C349DD  		JP	RCPRNL		;RESTART CPR
E317:         	COM1:
E317: 3AA4DC  		LD	A,(FCBFT)	;FILE TYPE MUST BE BLANK
E31A: FE20    		CP	' '
E31C: C211DF  		JP	NZ,ERROR
E31F: 2177DC  		LD	HL,COMMSG	;PLACE DEFAULT FILE TYPE (COM) INTO FCB
E322: 11A4DC  		LD	DE,FCBFT	;COPY INTO FILE TYPE
E325: 010300  		LD	BC,3		;3 BYTES
E328: EDB0    		LDIR
E32A: 210001  		LD	HL,TPA		;SET EXECUTION/LOAD ADDRESS
E32D: E5      		PUSH	HL		;SAVE FOR EXECUTION
E32E: CD9EE3  		CALL	MEMLOAD		;LOAD MEMORY WITH FILE SPECIFIED IN CMD LINE
              					; (NO RETURN IF ERROR OR TOO BIG)
E331: E1      		POP	HL		;GET EXECUTION ADDRESS
              	;
              	; CALLPROG IS THE ENTRY POINT FOR THE EXECUTION OF THE LOADED
              	;   PROGRAM. ON ENTRY TO THIS ROUTINE, HL MUST CONTAIN THE EXECUTION
              	;   ADDRESS OF THE PROGRAM (SUBROUTINE) TO EXECUTE
              	;
E332:         	CALLPROG:
E332: 2285E3  		LD	(EXECADR),HL	;PERFORM IN-LINE CODE MODIFICATION
E335: CDEEDF  		CALL	DLOGIN		;LOG IN DEFAULT DRIVE
E338: CD02E0  		CALL	SCANER		;SEARCH COMMAND LINE FOR NEXT TOKEN
E33B: 21F9DF  		LD	HL,TEMPDR	;SAVE PTR TO DRIVE SPEC
E33E: E5      		PUSH	HL
E33F: 7E      		LD	A,(HL)		;SET DRIVE SPEC
E340: 329BDC  		LD	(FCBDN),A
E343: 21ABDC  		LD	HL,FCBDN+10H	;PT TO 2ND FILE NAME
E346: CD05E0  		CALL	SCANX		;SCAN FOR IT AND LOAD IT INTO FCBDN+16
E349: E1      		POP	HL		;SET UP DRIVE SPECS
E34A: 7E      		LD	A,(HL)
E34B: 32ABDC  		LD	(FCBDM),A
E34E: AF      		XOR	A
E34F: 32BBDC  		LD	(FCBCR),A
E352: 115C00  		LD	DE,TFCB		;COPY TO DEFAULT FCB
E355: 219BDC  		LD	HL,FCBDN 	;FROM FCBDN
E358: 012100  		LD	BC,33		;SET UP DEFAULT FCB
E35B: EDB0    		LDIR
E35D: 2107DC  		LD	HL,CIBUFF-1
E360:         	COM4:
E360: 23      		INC	HL
E361: 7E      		LD	A,(HL)		;SKIP TO END OF 2ND FILE NAME
E362: B7      		OR	A		;END OF LINE?
E363: 2804    		JR	Z,COM5
E365: FE20    		CP	' '		;END OF TOKEN?
E367: 20F7    		JR	NZ,COM4
              	;
              	; LOAD COMMAND LINE INTO TBUFF
              	;
E369:         	COM5:
E369: 06FF    		LD	B,-1		;SET CHAR COUNT
E36B: 118000  		LD	DE,TBUFF	;PT TO CHAR POS
E36E: 2B      		DEC	HL
E36F:         	COM6:
E36F: 04      		INC	B		;INCR CHAR COUNT
E370: 23      		INC	HL		;PT TO NEXT
E371: 13      		INC	DE
E372: 7E      		LD	A,(HL)		;COPY COMMAND LINE TO TBUFF
E373: 12      		LD	(DE),A
E374: B7      		OR	A		;DONE IF ZERO
E375: 20F8    		JR	NZ,COM6
              	;
              	; RUN LOADED TRANSIENT PROGRAM
              	;
E377:         	COM7:
E377: 78      		LD	A,B		;SAVE CHAR COUNT
E378: 328000  		LD	(TBUFF),A
E37B: CDA7DD  		CALL	CRLF		;NEW LINE
E37E: CD2CDE  		CALL	DEFDMA		;SET DMA TO 0080
E381: CD74DE  		CALL	SETUD		;SET USER/DISK
              	;
              	; EXECUTION (CALL) OF PROGRAM (SUBROUTINE) OCCURS HERE
              	;
E385:         	EXECADR	EQU	$+1		;CHANGE ADDRESS FOR IN-LINE CODE MODIFICATION
E384: CD0001  		CALL	TPA		;CALL TRANSIENT
E387: CD2CDE  		CALL	DEFDMA		;SET DMA TO 0080, IN CASE
              					;PROG CHANGED IT ON US
E38A: CD83DE  		CALL	SETU0D		;SET USER 0/DISK
E38D: CD38DE  		CALL	LOGIN		;LOGIN DISK
E390: C3F8DC  		JP	RESTRT		;RESTART CPR
              	;
              	;Section 5L
              	;Command: GET
              	;Function:  To load the specified file from disk to the specified address
              	;Forms:
              	;	GET <adr> <ufn>	Load the specified file at the specified page;
              	;			<adr> is in HEX
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
              	;
E393:         	GET:
E393: CD9BDF  		CALL	HEXNUM		;GET LOAD ADDRESS IN HL
E396: E5      		PUSH	HL		;SAVE ADDRESS
E397: CD02E0  		CALL	SCANER		;GET FILE NAME
E39A: E1      		POP	HL		;RESTORE ADDRESS
E39B: C211DF  		JP	NZ,ERROR	;MUST BE UNAMBIGUOUS
              	;
              	; FALL THRU TO MEMLOAD
              	;
              		ENDIF			;RAS
              	;
              	; LOAD MEMORY WITH THE FILE WHOSE NAME IS SPECIFIED IN THE COMMAND LINE
              	;   ON INPUT, HL CONTAINS STARTING ADDRESS TO LOAD
              	;
              	;  EXIT BACK TO CALLER IF NO ERROR.  IF COM FILE TOO BIG OR
              	; OTHER ERROR, EXIT DIRECTLY TO MLERR.
              	;
E39E:         	MEMLOAD:
E39E: 22D1E3  		LD	(LOADADR),HL	;SET LOAD ADDRESS
E3A1: CD6EDE  		CALL	GETUSR		;GET CURRENT USER NUMBER
E3A4: 326ADE  		LD	(TMPUSR),A	;SAVE IT FOR LATER
E3A7: 32B5E3  		LD	(TSELUSR),A	;TEMP USER TO SELECT
              	;
              	;   MLA is a reentry point for a non-standard CP/M Modification
              	; This is the return point for when the .COM (or GET) file is not found the
              	; first time, Drive A: is selected for a second attempt
              	;
E3AA:         	MLA:
E3AA: CDE4DF  		CALL	SLOGIN		;LOG IN SPECIFIED DRIVE IF ANY
E3AD: CD3DDE  		CALL	OPENF		;OPEN COMMAND.COM FILE
E3B0: 201E    		JR	NZ,MLA1		;FILE FOUND - LOAD IT
              	;
              		IF	SECURE
              	;
              	;  IF SECURE ENABLED, SEARCH CURRENT DRIVE, CURRENT USER, THEN
              	; IF IN WHEEL MODE, SEARCH UNDER LAST USER SET BY DFU (ORIG
              	; "RESUSR" AFTER WARM BOOT) ON CURRENT DRIVE. IF NOT FOUND, OR
              	; NOT IN WHEEL MODE, THEN SEARCH ON CURRENT DRIVE, UNDER USER
              	; "DEFUSR". IF STILL NOT FOUND, LOOK AT SAME SERIES OF USERS
              	; ON DRIVE A.
              	;
              	DFLAG	EQU	$+1		;MARK IN-THE-CODE VARIABLE
              		LD	A,0		;HAVE WE CHECKED THIS DRIVE ALREADY?
              		OR	A
              		JR	NZ,MLA0		;PASS IF SO TO GO TO DRIVE A:
              		LD	A,(WHEEL)	;RESTRICTED PROGS ALLOWED?
              		CP	RESTRCT
              		JR	Z,MLA00		;PASS IF NOT
              		PUSH	BC		;PUSH BC
              		LD	A,(DFUSR)	;LOAD DEFAULT USER
              		LD	B,A		;PUT IT IN B
              		LD	A,(TSELUSR)	;CHECK CURR USER
              	DFUSR	EQU	$+1		;DEFAULT USER LOCATION
              		CP	RESUSR		;RESTRICTED USER?
              		LD	A,B		;ASSUME NOT
              		POP	BC		;RESTORE BC
              		JR	NZ,SETTSE	;GO TRY IF NOT
              	MLA00:				;SS IF NOT
              	TSELUSR	EQU	$+1		;MARK IN-THE-CODE VARIABLE
              		LD	A,0		;GET CURR USER
              		SUB	DEFUSR		;IS IT UNRESTRICTED COM AREA?
              		JR	Z,MLA0		;NO MORE CHOICES IF SO
              		LD	(DFLAG),A	;MAKE DFLAG NON-ZERO IF NOT
              		LD	A,DEFUSR	; AND TRY UNRESTRICTED COM AREA
              		ENDIF			;SECURE
              	;
              		IF	SECURE
              	        ELSE
E3B3:         	DFUSR	EQU	$+1		;MARK IN-THE-CODE VARIABLE
E3B2: 3E00    		LD	A,DEFUSR	;GET DEFAULT USER
E3B5:         	TSELUSR	EQU	$+1		;MARK IN-THE-CODE VARIABLE
E3B4: FE00    		CP	DEFUSR		;CHECK FOR THE USER AREA..
E3B6: 2809    		JR	Z,MLA0		;..EQUAL DEFAULT, AND JUMP IF SO
              		ENDIF			;NOT SECURE
              	;
E3B8:         	SETTSE:
E3B8: 32B5E3  		LD	(TSELUSR),A	;PUT DOWN NEW ONE
E3BB: 5F      		LD	E,A
E3BC: CD70DE  		CALL	SETUSR		;GO SET NEW USER NUMBER
E3BF: 18E9    		JR	MLA		;AND TRY AGAIN
              	;
              	; ERROR ROUTINE TO SELECT DRIVE A: IF DEFAULT WAS ORIGINALLY SELECTED
              	;
E3C1:         	MLA0:
E3C1: 21F9DF  		LD	HL,TEMPDR	;GET DRIVE FROM CURRENT COMMAND
E3C4: AF      		XOR	A		;A=0
              	;
              		IF	SECURE
              		LD	(DFLAG),A	;ALLOW A: SEARCH
              		ENDIF			;SECURE
              	;
E3C5: B6      		OR	(HL)
E3C6: C2F3E3  		JP	NZ,MLERR	;ERROR IF ALREADY DISK A:
E3C9: 3601    		LD	(HL),1		;SELECT DRIVE A:
E3CB: 3A6ADE  		LD	A,(TMPUSR)	;GO TO 'CURRENT' USER CODE
E3CE: 18E8    		JR	SETTSE
              	;
              	; FILE FOUND -- PROCEED WITH LOAD
              	;
E3D0:         	MLA1:
E3D1:         	LOADADR	EQU	$+1
E3D0: 210001  		LD	HL,TPA
E3D3:         	ML2:
E3D3: 3EDB    		LD	A,ENTRY/256-1	;GET HIGH-ORDER ADR OF JUST BELOW CPR
E3D5: BC      		CP	H		;ARE WE GOING TO OVERWRITE THE CPR?
E3D6: 3818    		JR	C,ML4		;ERROR IF SO
E3D8: E5      		PUSH	HL		;SAVE ADDRESS OF NEXT SECTOR
E3D9: EB      		EX	DE,HL		;... IN DE
E3DA: CD2FDE  		CALL	DMASET		;SET DMA ADDRESS FOR LOAD
E3DD: 119BDC  		LD	DE,FCBDN 	;READ NEXT SECTOR
E3E0: CD07DE  		CALL	READ
E3E3: E1      		POP	HL		;GET ADDRESS OF NEXT SECTOR
E3E4: 2006    		JR	NZ,ML3		;READ ERROR OR EOF?
E3E6: 118000  		LD	DE,128		;MOVE 128 BYTES PER SECTOR
E3E9: 19      		ADD	HL,DE		;PT TO NEXT SECTOR IN HL
E3EA: 18E7    		JR	ML2
              	;
E3EC:         	ML3:
E3EC: 3D      		DEC	A		;LOAD COMPLETE
E3ED: CA69DE  		JP	Z,RESETUSR	;IF ZERO, OK, GO RESET CORRECT USER #
              					; ON WAY OUT, ELSE FALL THRU TO PRNLE
              	;
              	;  TPA FULL
              	;
E3F0: CD58E2  	ML4:	CALL	PRNLE		;PRINT MSG AND RESET DEF DMA
              	;
              	; TRANSIENT LOAD ERROR
              	;
E3F3:         	MLERR:
              					;NOTE THAT THERE IS AN EXTRA RETURN ADDRESS ON
              					; THE STACK. IT WILL BE TOSSED WHEN ERROR EXITS
              					; TO RESTRT, WHICH RELOADS SP.
E3F3: CD69DE  		CALL	RESETUSR	;RESET CURRENT USER NUMBER
              					;  RESET MUST BE DONE BEFORE LOGIN
E3F6:         	ERRLOG:
E3F6: CDEEDF  		CALL	DLOGIN		;LOG IN DEFAULT DISK
E3F9: C311DF  		JP	ERROR		;FLAG ERROR
              	;
              	;
              	;Section: 5M
              	;PASS:  Enable wheel mode.
              	;NORM:	Disable wheel mode.
              	;
              	;  Type PASS <password> <cr> to CP/M prompt to enter wheel mode.
              	; This code can be replaced with PST's PASS.ASM which gives many
              	; nice little options like no keyboard echo, etc.
              	;
              		IF	INPASS		;WE WANT TO USE THIS CODE, NOT PASS.COM
              	PASS:
              		LD	HL,PASSWD	;SET UP POINTERS
              		LD	DE,CIBUFF+NCHARS+1
              		LD	B,PRGEND-PASSWD	;B= LENGTH
              	CKPASS:	LD	A,(DE)		;TRIAL PW TO A
              		CP	(HL)		;CHECK FOR MATCH
              		JP	NZ,COM		;NOPE.. LOOK FOR PASS.COM
              		INC	HL		;INCREMENT COUNTER
              		INC	DE
              		DJNZ	CKPASS		;CONTINUE IF MORE
              		LD	A,NOT RESTRCT	;WHEEL = NOT RESTRCT
              	
              	PWOUT:	LD	(WHEEL),A
              		JP	RESTRT
              	;
              	NORM:
              		LD	A,RESTRCT
              		JR	PWOUT
              	;
              	PASSWD:
              		DEFM	'YOURPW'	;YOUR PASSWORD
              	PRGEND	EQU	$		;END OF PASSWORD
              	;
              		ENDIF			;INPASS
              	
E3FC: 00000000	        DEFS    4
              	
              	#include "../bdos.asm"
              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;*      Modified to build as single image from source
              	;*
              	;*
              	;*
              	;**************************************************************
              	
              	
              	
              	;
              	;   note that the following six bytes must match those at
              	; (pattrn1) or cp/m will halt. why?
              	;
E400: 00160000	pattrn2:defb	0,22,0,0,0,0	;(* serial number bytes *).
E404: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
E406: C311E4  	fbase:	jp	fbase1
              	;
              	;   bdos error table.
              	;
E409: 99E4    	badsctr:defw	error1		;bad sector on read or write.
E40B: A5E4    	badslct:defw	error2		;bad disk select.
E40D: ABE4    	rodisk:	defw	error3		;disk is read only.
E40F: B1E4    	rofile:	defw	error4		;file is read only.
              	;
              	;   entry into bdos. (de) or (e) are the parameters passed. the
              	; function number desired is in register (c).
              	;
E411: EB      	fbase1:	ex	de,hl		;save the (de) parameters.
E412: 2243E7  		ld	(params),hl
E415: EB      		ex	de,hl
E416: 7B      		ld	a,e		;and save register (e) in particular.
E417: 32D6F1  		ld	(eparam),a
E41A: 210000  		ld	hl,0
E41D: 2245E7  		ld	(status),hl	;clear return status.
E420: 39      		add	hl,sp
E421: 220FE7  		ld	(usrstack),hl	;save users stack pointer.
E424: 3141E7  		ld	sp,stkarea	;and set our own.
E427: AF      		xor	a		;clear auto select storage space.
E428: 32E0F1  		ld	(autoflag),a
E42B: 2174F1  		ld	hl,goback	;set return address.
E42E: E5      		push	hl
E42F: CD18F3  		call	bshook		; see if anyone wants to intercept the call
E432: 79      		ld	a,c		;get function number.
E433: FE29    		cp	nfuncts		;valid function number?
E435: D0      		ret	nc
E436: 4B      		ld	c,e		;keep single register function here.
E437: 2147E4  		ld	hl,functns	;now look thru the function table.
E43A: 5F      		ld	e,a
E43B: 1600    		ld	d,0		;(de)=function number.
E43D: 19      		add	hl,de
E43E: 19      		add	hl,de		;(hl)=(start of table)+2*(function number).
E43F: 5E      		ld	e,(hl)
E440: 23      		inc	hl
E441: 56      		ld	d,(hl)		;now (de)=address for this function.
E442: 2A43E7  		ld	hl,(params)	;retrieve parameters.
E445: EB      		ex	de,hl		;now (de) has the original parameters.
E446: E9      		jp	(hl)		;execute desired function.
              	;
              	;   bdos function jump table.
              	;
0029:         	nfuncts equ	41		;number of functions in followin table.
              	;
E447: 46F2C8E6	functns:defw	wboot,getcon,outcon,getrdr,punch,list,dircio,getiob
E44B: 90E5CEE6	
E44F: C7F2C3F2	
E453: D4E6EDE6	
E457: F3E6F8E6		defw	setiob,prtstr,rdbuff,getcsts,getver,rstdsk,setdsk,openfil
E45B: E1E5FEE6	
E45F: 7EF083F0	
E463: 45F09CF0	
E467: A5F0ABF0		defw	closefil,getfst,getnxt,delfile,readseq,wrtseq,fcreate
E46B: C8F0D7F0	
E46F: E0F0E6F0	
E473: ECF0    	
E475: F5F0FEF0		defw	renfile,getlog,getcrnt,putdma,getaloc,wrtprtd,getrov,setattr
E479: 04F10AF1	
E47D: 11F12CE9	
E481: 17F11DF1	
E485: 26F12DF1		defw	getparm,getuser,rdrandom,wtrandom,filesize,setran,logoff,rtn
E489: 41F147F1	
E48D: 4DF10EF0	
E491: 53F104E7	
E495: 04E79BF1		defw	rtn,wtspecl
              	;
              	;   bdos error message section.
              	;
E499: 21CAE4  	error1:	ld	hl,badsec	;bad sector message.
E49C: CDE5E4  		call	prterr		;print it and get a 1 char responce.
E49F: FE03    		cp	cntrlc		;re-boot request (control-c)?
E4A1: CA0000  		jp	z,0		;yes.
E4A4: C9      		ret			;no, return to retry i/o function.
              	;
E4A5: 21D5E4  	error2:	ld	hl,badsel	;bad drive selected.
E4A8: C3B4E4  		jp	error5
              	;
E4AB: 21E1E4  	error3:	ld	hl,diskro	;disk is read only.
E4AE: C3B4E4  		jp	error5
              	;
E4B1: 21DCE4  	error4:	ld	hl,filero	;file is read only.
              	;
E4B4: CDE5E4  	error5:	call	prterr
E4B7: C341F2  		jp	eboot		;always reboot on these errors.
              	;
E4BA: 42646F73	bdoserr:defb	'Bdos Err on '
E4BE: 20457272	
E4C2: 206F6E20	
E4C6: 203A2024	bdosdrv:defb	' : $'
E4CA: 42616420	badsec:	defb	'Bad Sector$'
E4CE: 53656374	
E4D2: 6F7224  	
E4D5: 53656C65	badsel:	defb	'Select$'
E4D9: 637424  	
E4DC: 46696C65	filero:	defb	'File '
E4E0: 20      	
E4E1: 522F4F24	diskro:	defb	'R/O$'
              	;
              	;   print bdos error message.
              	;
E4E5: E5      	prterr:	push	hl		;save second message pointer.
E4E6: CDC9E5  		call	outcrlf		;send (cr)(lf).
E4E9: 3A42E7  		ld	a,(active)	;get active drive.
E4EC: C641    		add	a,'A'		;make ascii.
E4EE: 32C6E4  		ld	(bdosdrv),a	;and put in message.
E4F1: 01BAE4  		ld	bc,bdoserr	;and print it.
E4F4: CDD3E5  		call	prtmesg
E4F7: C1      		pop	bc		;print second message line now.
E4F8: CDD3E5  		call	prtmesg
              	;
              	;   get an input character. we will check our 1 character
              	; buffer first. this may be set by the console status routine.
              	;
E4FB: 210EE7  	getchar:ld	hl,charbuf	;check character buffer.
E4FE: 7E      		ld	a,(hl)		;anything present already?
E4FF: 3600    		ld	(hl),0		;...either case clear it.
E501: B7      		or	a
E502: C0      		ret	nz		;yes, use it.
E503: C3ABF2  		jp	conin		;nope, go get a character responce.
              	;
              	;   input and echo a character.
              	;
E506: CDFBE4  	getecho:call	getchar		;input a character.
E509: CD14E5  		call	chkchar		;carriage control?
E50C: D8      		ret	c		;no, a regular control char so don't echo.
E50D: F5      		push	af		;ok, save character now.
E50E: 4F      		ld	c,a
E50F: CD90E5  		call	outcon		;and echo it.
E512: F1      		pop	af		;get character and return.
E513: C9      		ret	
              	;
              	;   check character in (a). set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
E514: FE0D    	chkchar:cp	cr		;check for carriage return, line feed, backspace,
E516: C8      		ret	z		;or a tab.
E517: FE0A    		cp	lf
E519: C8      		ret	z
E51A: FE09    		cp	tab
E51C: C8      		ret	z
E51D: FE08    		cp	bs
E51F: C8      		ret	z
E520: FE20    		cp	' '		;other control char? set carry flag.
E522: C9      		ret	
              	;
              	;   check the console during output. halt on a control-s, then
              	; reboot on a control-c. if anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
E523: 3A0EE7  	ckconsol: ld	a,(charbuf)	;check buffer.
E526: B7      		or	a		;if anything, just return without checking.
E527: C245E5  		jp	nz,ckcon2
E52A: CDA0F2  		call	const		;nothing in buffer. check console.
E52D: E601    		and	01h		;look at bit 0.
E52F: C8      		ret	z		;return if nothing.
E530: CDABF2  		call	conin		;ok, get it.
E533: FE13    		cp	cntrls		;if not control-s, return with zero cleared.
E535: C242E5  		jp	nz,ckcon1
E538: CDABF2  		call	conin		;halt processing until another char
E53B: FE03    		cp	cntrlc		;is typed. control-c?
E53D: CA0000  		jp	z,0		;yes, reboot now.
E540: AF      		xor	a		;no, just pretend nothing was ever ready.
E541: C9      		ret	
E542: 320EE7  	ckcon1:	ld	(charbuf),a	;save character in buffer for later processing.
E545: 3E01    	ckcon2:	ld	a,1		;set (a) to non zero to mean something is ready.
E547: C9      		ret	
              	;
              	;   output (c) to the screen. if the printer flip-flop flag
              	; is set, we will send character to printer also. the console
              	; will be checked in the process.
              	;
E548: 3A0AE7  	outchar:ld	a,(outflag)	;check output flag.
E54B: B7      		or	a		;anything and we won't generate output.
E54C: C262E5  		jp	nz,outchr1
E54F: C5      		push	bc
E550: CD23E5  		call	ckconsol	;check console (we don't care whats there).
E553: C1      		pop	bc
E554: C5      		push	bc
E555: CDB7F2  		call	conout		;output (c) to the screen.
E558: C1      		pop	bc
E559: C5      		push	bc
E55A: 3A0DE7  		ld	a,(prtflag)	;check printer flip-flop flag.
E55D: B7      		or	a
E55E: C4C3F2  		call	nz,list		;print it also if non-zero.
E561: C1      		pop	bc
E562: 79      	outchr1:ld	a,c		;update cursors position.
E563: 210CE7  		ld	hl,curpos
E566: FE7F    		cp	del		;rubouts don't do anything here.
E568: C8      		ret	z
E569: 34      		inc	(hl)		;bump line pointer.
E56A: FE20    		cp	' '		;and return if a normal character.
E56C: D0      		ret	nc
E56D: 35      		dec	(hl)		;restore and check for the start of the line.
E56E: 7E      		ld	a,(hl)
E56F: B7      		or	a
E570: C8      		ret	z		;ingnore control characters at the start of the line.
E571: 79      		ld	a,c
E572: FE08    		cp	bs		;is it a backspace?
E574: C279E5  		jp	nz,outchr2
E577: 35      		dec	(hl)		;yes, backup pointer.
E578: C9      		ret	
E579: FE0A    	outchr2:cp	lf		;is it a line feed?
E57B: C0      		ret	nz		;ignore anything else.
E57C: 3600    		ld	(hl),0		;reset pointer to start of line.
E57E: C9      		ret	
              	;
              	;   output (a) to the screen. if it is a control character
              	; (other than carriage control), use ^x format.
              	;
E57F: 79      	showit:	ld	a,c
E580: CD14E5  		call	chkchar		;check character.
E583: D290E5  		jp	nc,outcon	;not a control, use normal output.
E586: F5      		push	af
E587: 0E5E    		ld	c,'^'		;for a control character, preceed it with '^'.
E589: CD48E5  		call	outchar
E58C: F1      		pop	af
E58D: F640    		or	'@'		;and then use the letter equivelant.
E58F: 4F      		ld	c,a
              	;
              	;   function to output (c) to the console device and expand tabs
              	; if necessary.
              	;
E590: 79      	outcon:	ld	a,c
E591: FE09    		cp	tab		;is it a tab?
E593: C248E5  		jp	nz,outchar	;use regular output.
E596: 0E20    	outcon1:ld	c,' '		;yes it is, use spaces instead.
E598: CD48E5  		call	outchar
E59B: 3A0CE7  		ld	a,(curpos)	;go until the cursor is at a multiple of 8
              	
E59E: E607    		and	07h		;position.
E5A0: C296E5  		jp	nz,outcon1
E5A3: C9      		ret	
              	;
              	;   echo a backspace character. erase the prevoius character
              	; on the screen.
              	;
E5A4: CDACE5  	backup:	call	backup1		;backup the screen 1 place.
E5A7: 0E20    		ld	c,' '		;then blank that character.
E5A9: CDB7F2  		call	conout
E5AC: 0E08    	backup1:ld	c,bs		;then back space once more.
E5AE: C3B7F2  		jp	conout
              	;
              	;   signal a deleted line. print a '#' at the end and start
              	; over.
              	;
E5B1: 0E23    	newline:ld	c,'#'
E5B3: CD48E5  		call	outchar		;print this.
E5B6: CDC9E5  		call	outcrlf		;start new line.
E5B9: 3A0CE7  	newln1:	ld	a,(curpos)	;move the cursor to the starting position.
E5BC: 210BE7  		ld	hl,starting
E5BF: BE      		cp	(hl)
E5C0: D0      		ret	nc		;there yet?
E5C1: 0E20    		ld	c,' '
E5C3: CD48E5  		call	outchar		;nope, keep going.
E5C6: C3B9E5  		jp	newln1
              	;
              	;   output a (cr) (lf) to the console device (screen).
              	;
E5C9: 0E0D    	outcrlf:ld	c,cr
E5CB: CD48E5  		call	outchar
E5CE: 0E0A    		ld	c,lf
E5D0: C348E5  		jp	outchar
              	;
              	;   print message pointed to by (bc). it will end with a '$'.
              	;
E5D3: 0A      	prtmesg:ld	a,(bc)		;check for terminating character.
E5D4: FE24    		cp	'$'
E5D6: C8      		ret	z
E5D7: 03      		inc	bc
E5D8: C5      		push	bc		;otherwise, bump pointer and print it.
E5D9: 4F      		ld	c,a
E5DA: CD90E5  		call	outcon
E5DD: C1      		pop	bc
E5DE: C3D3E5  		jp	prtmesg
              	;
              	;   function to execute a buffered read.
              	;
E5E1: 3A0CE7  	rdbuff:	ld	a,(curpos)	;use present location as starting one.
E5E4: 320BE7  		ld	(starting),a
E5E7: 2A43E7  		ld	hl,(params)	;get the maximum buffer space.
E5EA: 4E      		ld	c,(hl)
E5EB: 23      		inc	hl		;point to first available space.
E5EC: E5      		push	hl		;and save.
E5ED: 0600    		ld	b,0		;keep a character count.
E5EF: C5      	rdbuf1:	push	bc
E5F0: E5      		push	hl
E5F1: CDFBE4  	rdbuf2:	call	getchar		;get the next input character.
E5F4: E67F    		and	7fh		;strip bit 7.
E5F6: E1      		pop	hl		;reset registers.
E5F7: C1      		pop	bc
E5F8: FE0D    		cp	cr		;en of the line?
E5FA: CAC1E6  		jp	z,rdbuf17
E5FD: FE0A    		cp	lf
E5FF: CAC1E6  		jp	z,rdbuf17
E602: FE08    		cp	bs		;how about a backspace?
E604: C216E6  		jp	nz,rdbuf3
E607: 78      		ld	a,b		;yes, but ignore at the beginning of the line.
E608: B7      		or	a
E609: CAEFE5  		jp	z,rdbuf1
E60C: 05      		dec	b		;ok, update counter.
E60D: 3A0CE7  		ld	a,(curpos)	;if we backspace to the start of the line,
E610: 320AE7  		ld	(outflag),a	;treat as a cancel (control-x).
E613: C370E6  		jp	rdbuf10
E616: FE7F    	rdbuf3:	cp	del		;user typed a rubout?
E618: C226E6  		jp	nz,rdbuf4
E61B: 78      		ld	a,b		;ignore at the start of the line.
E61C: B7      		or	a
E61D: CAEFE5  		jp	z,rdbuf1
E620: 7E      		ld	a,(hl)		;ok, echo the prevoius character.
E621: 05      		dec	b		;and reset pointers (counters).
E622: 2B      		dec	hl
E623: C3A9E6  		jp	rdbuf15
E626: FE05    	rdbuf4:	cp	cntrle		;physical end of line?
E628: C237E6  		jp	nz,rdbuf5
E62B: C5      		push	bc		;yes, do it.
E62C: E5      		push	hl
E62D: CDC9E5  		call	outcrlf
E630: AF      		xor	a		;and update starting position.
E631: 320BE7  		ld	(starting),a
E634: C3F1E5  		jp	rdbuf2
E637: FE10    	rdbuf5:	cp	cntrlp		;control-p?
E639: C248E6  		jp	nz,rdbuf6
E63C: E5      		push	hl		;yes, flip the print flag filp-flop byte.
E63D: 210DE7  		ld	hl,prtflag
E640: 3E01    		ld	a,1		;prtflag=1-prtflag
E642: 96      		sub	(hl)
E643: 77      		ld	(hl),a
E644: E1      		pop	hl
E645: C3EFE5  		jp	rdbuf1
E648: FE18    	rdbuf6:	cp	cntrlx		;control-x (cancel)?
E64A: C25FE6  		jp	nz,rdbuf8
E64D: E1      		pop	hl
E64E: 3A0BE7  	rdbuf7:	ld	a,(starting)	;yes, backup the cursor to here.
E651: 210CE7  		ld	hl,curpos
E654: BE      		cp	(hl)
E655: D2E1E5  		jp	nc,rdbuff	;done yet?
E658: 35      		dec	(hl)		;no, decrement pointer and output back up one space.
E659: CDA4E5  		call	backup
E65C: C34EE6  		jp	rdbuf7
E65F: FE15    	rdbuf8:	cp	cntrlu		;cntrol-u (cancel line)?
E661: C26BE6  		jp	nz,rdbuf9
E664: CDB1E5  		call	newline		;start a new line.
E667: E1      		pop	hl
E668: C3E1E5  		jp	rdbuff
E66B: FE12    	rdbuf9:	cp	cntrlr		;control-r?
E66D: C2A6E6  		jp	nz,rdbuf14
E670: C5      	rdbuf10:push	bc		;yes, start a new line and retype the old one.
E671: CDB1E5  		call	newline
E674: C1      		pop	bc
E675: E1      		pop	hl
E676: E5      		push	hl
E677: C5      		push	bc
E678: 78      	rdbuf11:ld	a,b		;done whole line yet?
E679: B7      		or	a
E67A: CA8AE6  		jp	z,rdbuf12
E67D: 23      		inc	hl		;nope, get next character.
E67E: 4E      		ld	c,(hl)
E67F: 05      		dec	b		;count it.
E680: C5      		push	bc
E681: E5      		push	hl
E682: CD7FE5  		call	showit		;and display it.
E685: E1      		pop	hl
E686: C1      		pop	bc
E687: C378E6  		jp	rdbuf11
E68A: E5      	rdbuf12:push	hl		;done with line. if we were displaying
E68B: 3A0AE7  		ld	a,(outflag)	;then update cursor position.
E68E: B7      		or	a
E68F: CAF1E5  		jp	z,rdbuf2
E692: 210CE7  		ld	hl,curpos	;because this line is shorter, we must
E695: 96      		sub	(hl)		;back up the cursor (not the screen however)
E696: 320AE7  		ld	(outflag),a	;some number of positions.
E699: CDA4E5  	rdbuf13:call	backup		;note that as long as (outflag) is non
E69C: 210AE7  		ld	hl,outflag	;zero, the screen will not be changed.
E69F: 35      		dec	(hl)
E6A0: C299E6  		jp	nz,rdbuf13
E6A3: C3F1E5  		jp	rdbuf2		;now just get the next character.
              	;
              	;   just a normal character, put this in our buffer and echo.
              	;
E6A6: 23      	rdbuf14:inc	hl
E6A7: 77      		ld	(hl),a		;store character.
E6A8: 04      		inc	b		;and count it.
E6A9: C5      	rdbuf15:push	bc
E6AA: E5      		push	hl
E6AB: 4F      		ld	c,a		;echo it now.
E6AC: CD7FE5  		call	showit
E6AF: E1      		pop	hl
E6B0: C1      		pop	bc
E6B1: 7E      		ld	a,(hl)		;was it an abort request?
E6B2: FE03    		cp	cntrlc		;control-c abort?
E6B4: 78      		ld	a,b
E6B5: C2BDE6  		jp	nz,rdbuf16
E6B8: FE01    		cp	1		;only if at start of line.
E6BA: CA0000  		jp	z,0
E6BD: B9      	rdbuf16:cp	c		;nope, have we filled the buffer?
E6BE: DAEFE5  		jp	c,rdbuf1
E6C1: E1      	rdbuf17:pop	hl		;yes end the line and return.
E6C2: 70      		ld	(hl),b
E6C3: 0E0D    		ld	c,cr
E6C5: C348E5  		jp	outchar		;output (cr) and return.
              	;
              	;   function to get a character from the console device.
              	;
E6C8: CD06E5  	getcon:	call	getecho		;get and echo.
E6CB: C301E7  		jp	setstat		;save status and return.
              	;
              	;   function to get a character from the tape reader device.
              	;
E6CE: CDCBF2  	getrdr:	call	reader		;get a character from reader, set status and return.
E6D1: C301E7  		jp	setstat
              	;
              	;  function to perform direct console i/o. if (c) contains (ff)
              	; then this is an input request. if (c) contains (fe) then
              	; this is a status request. otherwise we are to output (c).
              	;
E6D4: 79      	dircio:	ld	a,c		;test for (ff).
E6D5: 3C      		inc	a
E6D6: CAE0E6  		jp	z,dirc1
E6D9: 3C      		inc	a		;test for (fe).
E6DA: CAA0F2  		jp	z,const
E6DD: C3B7F2  		jp	conout		;just output (c).
E6E0: CDA0F2  	dirc1:	call	const		;this is an input request.
E6E3: B7      		or	a
E6E4: CA91F1  		jp	z,goback1	;not ready? just return (directly).
E6E7: CDABF2  		call	conin		;yes, get character.
E6EA: C301E7  		jp	setstat		;set status and return.
              	;
              	;   function to return the i/o byte.
              	;
E6ED: 3A0300  	getiob:	ld	a,(iobyte)
E6F0: C301E7  		jp	setstat
              	;
              	;   function to set the i/o byte.
              	;
E6F3: 210300  	setiob:	ld	hl,iobyte
E6F6: 71      		ld	(hl),c
E6F7: C9      		ret	
              	;
              	;   function to print the character string pointed to by (de)
              	; on the console device. the string ends with a '$'.
              	;
E6F8: EB      	prtstr:	ex	de,hl
E6F9: 4D      		ld	c,l
E6FA: 44      		ld	b,h		;now (bc) points to it.
E6FB: C3D3E5  		jp	prtmesg
              	;
              	;   function to interigate the console device.
              	;
E6FE: CD23E5  	getcsts:call	ckconsol
              	;
              	;   get here to set the status and return to the cleanup
              	; section. then back to the user.
              	;
E701: 3245E7  	setstat:ld	(status),a
E704: C9      	rtn:	ret	
              	;
              	;   set the status to 1 (read or write error code).
              	;
E705: 3E01    	ioerr1:	ld	a,1
E707: C301E7  		jp	setstat
              	;
E70A: 00      	outflag:defb	0		;output flag (non zero means no output).
E70B: 02      	starting: defb	2		;starting position for cursor.
E70C: 00      	curpos:	defb	0		;cursor position (0=start of line).
E70D: 00      	prtflag:defb	0		;printer flag (control-p toggle). list if non zero.
E70E: 00      	charbuf:defb	0		;single input character buffer.
              	;
              	;   stack area for bdos calls.
              	;
E70F: 0000    	usrstack: defw	0		;save users stack pointer here.
              	;
E711: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E715: 00...   	
E729: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E72D: 00...   	
E741:         	stkarea equ	$		;end of stack area.
              	;
E741: 00      	userno:	defb	0		;current user number.
E742: 00      	active:	defb	0		;currently active drive.
E743: 0000    	params:	defw	0		;save (de) parameters here on entry.
E745: 0000    	status:	defw	0		;status returned from bdos function.
              	;
              	;   select error occured, jump to error routine.
              	;
E747: 210BE4  	slcterr:ld	hl,badslct
              	;
              	;   jump to (hl) indirectly.
              	;
E74A: 5E      	jumphl:	ld	e,(hl)
E74B: 23      		inc	hl
E74C: 56      		ld	d,(hl)		;now (de) contain the desired address.
E74D: EB      		ex	de,hl
E74E: E9      		jp	(hl)
              	;
              	;   block move. (de) to (hl), (c) bytes total.
              	;
E74F: 0C      	de2hl:	inc	c		;is count down to zero?
E750: 0D      	de2hl1:	dec	c
E751: C8      		ret	z		;yes, we are done.
E752: 1A      		ld	a,(de)		;no, move one more byte.
E753: 77      		ld	(hl),a
E754: 13      		inc	de
E755: 23      		inc	hl
E756: C350E7  		jp	de2hl1		;and repeat.
              	;
              	;   select the desired drive.
              	;
E759: 3A42E7  	select:	ld	a,(active)	;get active disk.
E75C: 4F      		ld	c,a
E75D: CDDEF2  		call	seldsk		;select it.
E760: 7C      		ld	a,h		;valid drive?
E761: B5      		or	l		;valid drive?
E762: C8      		ret	z		;return if not.
              	;
              	;   here, the bios returned the address of the parameter block
              	; in (hl). we will extract the necessary pointers and save them.
              	;
E763: 5E      		ld	e,(hl)		;yes, get address of translation table into (de).
E764: 23      		inc	hl
E765: 56      		ld	d,(hl)
E766: 23      		inc	hl
E767: 22B3F1  		ld	(scratch1),hl	;save pointers to scratch areas.
E76A: 23      		inc	hl
E76B: 23      		inc	hl
E76C: 22B5F1  		ld	(scratch2),hl	;ditto.
E76F: 23      		inc	hl
E770: 23      		inc	hl
E771: 22B7F1  		ld	(scratch3),hl	;ditto.
E774: 23      		inc	hl
E775: 23      		inc	hl
E776: EB      		ex	de,hl		;now save the translation table address.
E777: 22D0F1  		ld	(xlate),hl
E77A: 21B9F1  		ld	hl,dirbuf	;put the next 8 bytes here.
E77D: 0E08    		ld	c,8		;they consist of the directory buffer
E77F: CD4FE7  		call	de2hl		;pointer, parameter block pointer,
E782: 2ABBF1  		ld	hl,(diskpb)	;check and allocation vectors.
E785: EB      		ex	de,hl
E786: 21C1F1  		ld	hl,sectors	;move parameter block into our ram.
E789: 0E0F    		ld	c,15		;it is 15 bytes long.
E78B: CD4FE7  		call	de2hl
E78E: 2AC6F1  		ld	hl,(dsksize)	;check disk size.
E791: 7C      		ld	a,h		;more than 256 blocks on this?
E792: 21DDF1  		ld	hl,bigdisk
E795: 36FF    		ld	(hl),0ffh	;set to samll.
E797: B7      		or	a
E798: CA9DE7  		jp	z,select1
E79B: 3600    		ld	(hl),0		;wrong, set to large.
E79D: 3EFF    	select1:ld	a,0ffh		;clear the zero flag.
E79F: B7      		or	a
E7A0: C9      		ret	
              	;
              	;   routine to home the disk track head and clear pointers.
              	;
E7A1: CDD9F2  	homedrv:call	home		;home the head.
E7A4: AF      		xor	a
E7A5: 2AB5F1  		ld	hl,(scratch2)	;set our track pointer also.
E7A8: 77      		ld	(hl),a
E7A9: 23      		inc	hl
E7AA: 77      		ld	(hl),a
E7AB: 2AB7F1  		ld	hl,(scratch3)	;and our sector pointer.
E7AE: 77      		ld	(hl),a
E7AF: 23      		inc	hl
E7B0: 77      		ld	(hl),a
E7B1: C9      		ret	
              	;
              	;   do the actual disk read and check the error return status.
              	;
E7B2: CD0AF3  	doread:	call	read
E7B5: C3BBE7  		jp	ioret
              	;
              	;   do the actual disk write and handle any bios error.
              	;
E7B8: CD0EF3  	dowrite:call	write
E7BB: B7      	ioret:	or	a
E7BC: C8      		ret	z		;return unless an error occured.
E7BD: 2109E4  		ld	hl,badsctr	;bad read/write on this sector.
E7C0: C34AE7  		jp	jumphl
              	;
              	;   routine to select the track and sector that the desired
              	; block number falls in.
              	;
E7C3: 2AEAF1  	trksec:	ld	hl,(filepos)	;get position of last accessed file
E7C6: 0E02    		ld	c,2		;in directory and compute sector #.
E7C8: CDEAE8  		call	shiftr		;sector #=file-position/4.
E7CB: 22E5F1  		ld	(blknmbr),hl	;save this as the block number of interest.
E7CE: 22ECF1  		ld	(cksumtbl),hl	;what's it doing here too?
              	;
              	;   if the sector number has already been set (blknmbr), enter
              	; at this point.
              	;
E7D1: 21E5F1  	trksec1:ld	hl,blknmbr
E7D4: 4E      		ld	c,(hl)		;move sector number into (bc).
E7D5: 23      		inc	hl
E7D6: 46      		ld	b,(hl)
E7D7: 2AB7F1  		ld	hl,(scratch3)	;get current sector number and
E7DA: 5E      		ld	e,(hl)		;move this into (de).
E7DB: 23      		inc	hl
E7DC: 56      		ld	d,(hl)
E7DD: 2AB5F1  		ld	hl,(scratch2)	;get current track number.
E7E0: 7E      		ld	a,(hl)		;and this into (hl).
E7E1: 23      		inc	hl
E7E2: 66      		ld	h,(hl)
E7E3: 6F      		ld	l,a
E7E4: 79      	trksec2:ld	a,c		;is desired sector before current one?
E7E5: 93      		sub	e
E7E6: 78      		ld	a,b
E7E7: 9A      		sbc	a,d
E7E8: D2FAE7  		jp	nc,trksec3
E7EB: E5      		push	hl		;yes, decrement sectors by one track.
E7EC: 2AC1F1  		ld	hl,(sectors)	;get sectors per track.
E7EF: 7B      		ld	a,e
E7F0: 95      		sub	l
E7F1: 5F      		ld	e,a
E7F2: 7A      		ld	a,d
E7F3: 9C      		sbc	a,h
E7F4: 57      		ld	d,a		;now we have backed up one full track.
E7F5: E1      		pop	hl
E7F6: 2B      		dec	hl		;adjust track counter.
E7F7: C3E4E7  		jp	trksec2
E7FA: E5      	trksec3:push	hl		;desired sector is after current one.
E7FB: 2AC1F1  		ld	hl,(sectors)	;get sectors per track.
E7FE: 19      		add	hl,de		;bump sector pointer to next track.
E7FF: DA0FE8  		jp	c,trksec4
E802: 79      		ld	a,c		;is desired sector now before current one?
E803: 95      		sub	l
E804: 78      		ld	a,b
E805: 9C      		sbc	a,h
E806: DA0FE8  		jp	c,trksec4
E809: EB      		ex	de,hl		;not yes, increment track counter
E80A: E1      		pop	hl		;and continue until it is.
E80B: 23      		inc	hl
E80C: C3FAE7  		jp	trksec3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
E80F: E1      	trksec4:pop	hl		;get track number (hl).
E810: C5      		push	bc
E811: D5      		push	de
E812: E5      		push	hl
E813: EB      		ex	de,hl
E814: 2ACEF1  		ld	hl,(offset)	;adjust for first track offset.
E817: 19      		add	hl,de
E818: 44      		ld	b,h
E819: 4D      		ld	c,l
E81A: CDFCF2  		call	settrk		;select this track.
E81D: D1      		pop	de		;reset current track pointer.
E81E: 2AB5F1  		ld	hl,(scratch2)
E821: 73      		ld	(hl),e
E822: 23      		inc	hl
E823: 72      		ld	(hl),d
E824: D1      		pop	de
E825: 2AB7F1  		ld	hl,(scratch3)	;reset the first sector on this track.
E828: 73      		ld	(hl),e
E829: 23      		inc	hl
E82A: 72      		ld	(hl),d
E82B: C1      		pop	bc
E82C: 79      		ld	a,c		;now subtract the desired one.
E82D: 93      		sub	e		;to make it relative (1-# sectors/track).
E82E: 4F      		ld	c,a
E82F: 78      		ld	a,b
E830: 9A      		sbc	a,d
E831: 47      		ld	b,a
E832: 2AD0F1  		ld	hl,(xlate)	;translate this sector according to this table.
E835: EB      		ex	de,hl
E836: CD15F3  		call	sectrn		;let the bios translate it.
E839: 4D      		ld	c,l
E83A: 44      		ld	b,h
E83B: C300F3  		jp	setsec		;and select it.
              	;
              	;   compute block number from record number (savnrec) and
              	; extent number (savext).
              	;
E83E: 21C3F1  	getblock: ld	hl,blkshft	;get logical to physical conversion.
E841: 4E      		ld	c,(hl)		;note that this is base 2 log of ratio.
E842: 3AE3F1  		ld	a,(savnrec)	;get record number.
E845: B7      	getblk1:or	a		;compute (a)=(a)/2^blkshft.
E846: 1F      		rra	
E847: 0D      		dec	c
E848: C245E8  		jp	nz,getblk1
E84B: 47      		ld	b,a		;save result in (b).
E84C: 3E08    		ld	a,8
E84E: 96      		sub	(hl)
E84F: 4F      		ld	c,a		;compute (c)=8-blkshft.
E850: 3AE2F1  		ld	a,(savext)
E853: 0D      	getblk2:dec	c		;compute (a)=savext*2^(8-blkshft).
E854: CA5CE8  		jp	z,getblk3
E857: B7      		or	a
E858: 17      		rla	
E859: C353E8  		jp	getblk2
E85C: 80      	getblk3:add	a,b
E85D: C9      		ret	
              	;
              	;   routine to extract the (bc) block byte from the fcb pointed
              	; to by (params). if this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; number is returned in (hl).
              	;
E85E: 2A43E7  	extblk:	ld	hl,(params)	;get fcb address.
E861: 111000  		ld	de,16		;block numbers start 16 bytes into fcb.
E864: 19      		add	hl,de
E865: 09      		add	hl,bc
E866: 3ADDF1  		ld	a,(bigdisk)	;are we using a big-disk?
E869: B7      		or	a
E86A: CA71E8  		jp	z,extblk1
E86D: 6E      		ld	l,(hl)		;no, extract an 8 bit number from the fcb.
E86E: 2600    		ld	h,0
E870: C9      		ret	
E871: 09      	extblk1:add	hl,bc		;yes, extract a 16 bit number.
E872: 5E      		ld	e,(hl)
E873: 23      		inc	hl
E874: 56      		ld	d,(hl)
E875: EB      		ex	de,hl		;return in (hl).
E876: C9      		ret	
              	;
              	;   compute block number.
              	;
E877: CD3EE8  	comblk:	call	getblock
E87A: 4F      		ld	c,a
E87B: 0600    		ld	b,0
E87D: CD5EE8  		call	extblk
E880: 22E5F1  		ld	(blknmbr),hl
E883: C9      		ret	
              	;
              	;   check for a zero block number (unused).
              	;
E884: 2AE5F1  	chkblk:	ld	hl,(blknmbr)
E887: 7D      		ld	a,l		;is it zero?
E888: B4      		or	h
E889: C9      		ret	
              	;
              	;   adjust physical block (blknmbr) and convert to logical
              	; sector (logsect). this is the starting sector of this block.
              	; the actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (blknmbr). this
              	; will still have to be adjusted for the track number.
              	;
E88A: 3AC3F1  	logical:ld	a,(blkshft)	;get log2(physical/logical sectors).
E88D: 2AE5F1  		ld	hl,(blknmbr)	;get physical sector desired.
E890: 29      	logicl1:add	hl,hl		;compute logical sector number.
E891: 3D      		dec	a		;note logical sectors are 128 bytes long.
E892: C290E8  		jp	nz,logicl1
E895: 22E7F1  		ld	(logsect),hl	;save logical sector.
E898: 3AC4F1  		ld	a,(blkmask)	;get block mask.
E89B: 4F      		ld	c,a
E89C: 3AE3F1  		ld	a,(savnrec)	;get next sector to access.
E89F: A1      		and	c		;extract the relative position within physical block.
E8A0: B5      		or	l		;and add it too logical sector.
E8A1: 6F      		ld	l,a
E8A2: 22E5F1  		ld	(blknmbr),hl	;and store.
E8A5: C9      		ret	
              	;
              	;   set (hl) to point to extent byte in fcb.
              	;
E8A6: 2A43E7  	setext:	ld	hl,(params)
E8A9: 110C00  		ld	de,12		;it is the twelth byte.
E8AC: 19      		add	hl,de
E8AD: C9      		ret	
              	;
              	;   set (hl) to point to record count byte in fcb and (de) to
              	; next record number byte.
              	;
E8AE: 2A43E7  	sethlde:ld	hl,(params)
E8B1: 110F00  		ld	de,15		;record count byte (#15).
E8B4: 19      		add	hl,de
E8B5: EB      		ex	de,hl
E8B6: 211100  		ld	hl,17		;next record number (#32).
E8B9: 19      		add	hl,de
E8BA: C9      		ret	
              	;
              	;   save current file data from fcb.
              	;
E8BB: CDAEE8  	strdata:call	sethlde
E8BE: 7E      		ld	a,(hl)		;get and store record count byte.
E8BF: 32E3F1  		ld	(savnrec),a
E8C2: EB      		ex	de,hl
E8C3: 7E      		ld	a,(hl)		;get and store next record number byte.
E8C4: 32E1F1  		ld	(savnxt),a
E8C7: CDA6E8  		call	setext		;point to extent byte.
E8CA: 3AC5F1  		ld	a,(extmask)	;get extent mask.
E8CD: A6      		and	(hl)
E8CE: 32E2F1  		ld	(savext),a	;and save extent here.
E8D1: C9      		ret	
              	;
              	;   set the next record to access. if (mode) is set to 2, then
              	; the last record byte (savnrec) has the correct number to access.
              	; for sequential access, (mode) will be equal to 1.
              	;
E8D2: CDAEE8  	setnrec:call	sethlde
E8D5: 3AD5F1  		ld	a,(mode)	;get sequential flag (=1).
E8D8: FE02    		cp	2		;a 2 indicates that no adder is needed.
E8DA: C2DEE8  		jp	nz,stnrec1
E8DD: AF      		xor	a		;clear adder (random access?).
E8DE: 4F      	stnrec1:ld	c,a
E8DF: 3AE3F1  		ld	a,(savnrec)	;get last record number.
E8E2: 81      		add	a,c		;increment record count.
E8E3: 77      		ld	(hl),a		;and set fcb's next record byte.
E8E4: EB      		ex	de,hl
E8E5: 3AE1F1  		ld	a,(savnxt)	;get next record byte from storage.
E8E8: 77      		ld	(hl),a		;and put this into fcb as number of records used.
E8E9: C9      		ret	
              	;
              	;   shift (hl) right (c) bits.
              	;
E8EA: 0C      	shiftr:	inc	c
E8EB: 0D      	shiftr1:dec	c
E8EC: C8      		ret	z
E8ED: 7C      		ld	a,h
E8EE: B7      		or	a
E8EF: 1F      		rra	
E8F0: 67      		ld	h,a
E8F1: 7D      		ld	a,l
E8F2: 1F      		rra	
E8F3: 6F      		ld	l,a
E8F4: C3EBE8  		jp	shiftr1
              	;
              	;   compute the check-sum for the directory buffer. return
              	; integer sum in (a).
              	;
E8F7: 0E80    	checksum: ld	c,128		;length of buffer.
E8F9: 2AB9F1  		ld	hl,(dirbuf)	;get its location.
E8FC: AF      		xor	a		;clear summation byte.
E8FD: 86      	chksum1:add	a,(hl)		;and compute sum ignoring carries.
E8FE: 23      		inc	hl
E8FF: 0D      		dec	c
E900: C2FDE8  		jp	nz,chksum1
E903: C9      		ret	
              	;
              	;   shift (hl) left (c) bits.
              	;
E904: 0C      	shiftl:	inc	c
E905: 0D      	shiftl1:dec	c
E906: C8      		ret	z
E907: 29      		add	hl,hl		;shift left 1 bit.
E908: C305E9  		jp	shiftl1
              	;
              	;   routine to set a bit in a 16 bit value contained in (bc).
              	; the bit set depends on the current drive selection.
              	;
E90B: C5      	setbit:	push	bc		;save 16 bit word.
E90C: 3A42E7  		ld	a,(active)	;get active drive.
E90F: 4F      		ld	c,a
E910: 210100  		ld	hl,1
E913: CD04E9  		call	shiftl		;shift bit 0 into place.
E916: C1      		pop	bc		;now 'or' this with the original word.
E917: 79      		ld	a,c
E918: B5      		or	l
E919: 6F      		ld	l,a		;low byte done, do high byte.
E91A: 78      		ld	a,b
E91B: B4      		or	h
E91C: 67      		ld	h,a
E91D: C9      		ret	
              	;
              	;   extract the write protect status bit for the current drive.
              	; the result is returned in (a), bit 0.
              	;
E91E: 2AADF1  	getwprt:ld	hl,(wrtprt)	;get status bytes.
E921: 3A42E7  		ld	a,(active)	;which drive is current?
E924: 4F      		ld	c,a
E925: CDEAE8  		call	shiftr		;shift status such that bit 0 is the
E928: 7D      		ld	a,l		;one of interest for this drive.
E929: E601    		and	01h		;and isolate it.
E92B: C9      		ret	
              	;
              	;   function to write protect the current disk.
              	;
E92C: 21ADF1  	wrtprtd:ld	hl,wrtprt	;point to status word.
E92F: 4E      		ld	c,(hl)		;set (bc) equal to the status.
E930: 23      		inc	hl
E931: 46      		ld	b,(hl)
E932: CD0BE9  		call	setbit		;and set this bit according to current drive.
E935: 22ADF1  		ld	(wrtprt),hl	;then save.
E938: 2AC8F1  		ld	hl,(dirsize)	;now save directory size limit.
E93B: 23      		inc	hl		;remember the last one.
E93C: EB      		ex	de,hl
E93D: 2AB3F1  		ld	hl,(scratch1)	;and store it here.
E940: 73      		ld	(hl),e		;put low byte.
E941: 23      		inc	hl
E942: 72      		ld	(hl),d		;then high byte.
E943: C9      		ret	
              	;
              	;   check for a read only file.
              	;
E944: CD5EE9  	chkrofl:call	fcb2hl		;set (hl) to file entry in directory buffer.
E947: 110900  	ckrof1:	ld	de,9		;look at bit 7 of the ninth byte.
E94A: 19      		add	hl,de
E94B: 7E      		ld	a,(hl)
E94C: 17      		rla	
E94D: D0      		ret	nc		;return if ok.
E94E: 210FE4  		ld	hl,rofile	;else, print error message and terminate.
E951: C34AE7  		jp	jumphl
              	;
              	;   check the write protect status of the active disk.
              	;
E954: CD1EE9  	chkwprt:call	getwprt
E957: C8      		ret	z		;return if ok.
E958: 210DE4  		ld	hl,rodisk	;else print message and terminate.
E95B: C34AE7  		jp	jumphl
              	;
              	;   routine to set (hl) pointing to the proper entry in the
              	; directory buffer.
              	;
E95E: 2AB9F1  	fcb2hl:	ld	hl,(dirbuf)	;get address of buffer.
E961: 3AE9F1  		ld	a,(fcbpos)	;relative position of file.
              	;
              	;   routine to add (a) to (hl).
              	;
E964: 85      	adda2hl:add	a,l
E965: 6F      		ld	l,a
E966: D0      		ret	nc
E967: 24      		inc	h		;take care of any carry.
E968: C9      		ret	
              	;
              	;   routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
E969: 2A43E7  	gets2:	ld	hl,(params)	;get address of fcb.
E96C: 110E00  		ld	de,14		;relative position of 's2'.
E96F: 19      		add	hl,de
E970: 7E      		ld	a,(hl)		;extract this byte.
E971: C9      		ret	
              	;
              	;   clear the 's2' byte in the fcb.
              	;
E972: CD69E9  	clears2:call	gets2		;this sets (hl) pointing to it.
E975: 3600    		ld	(hl),0		;now clear it.
E977: C9      		ret	
              	;
              	;   set bit 7 in the 's2' byte of the fcb.
              	;
E978: CD69E9  	sets2b7:call	gets2		;get the byte.
E97B: F680    		or	80h		;and set bit 7.
E97D: 77      		ld	(hl),a		;then store.
E97E: C9      		ret	
              	;
              	;   compare (filepos) with (scratch1) and set flags based on
              	; the difference. this checks to see if there are more file
              	; names in the directory. we are at (filepos) and there are
              	; (scratch1) of them to check.
              	;
E97F: 2AEAF1  	morefls:ld	hl,(filepos)	;we are here.
E982: EB      		ex	de,hl
E983: 2AB3F1  		ld	hl,(scratch1)	;and don't go past here.
E986: 7B      		ld	a,e		;compute difference but don't keep.
E987: 96      		sub	(hl)
E988: 23      		inc	hl
E989: 7A      		ld	a,d
E98A: 9E      		sbc	a,(hl)		;set carry if no more names.
E98B: C9      		ret	
              	;
              	;   call this routine to prevent (scratch1) from being greater
              	; than (filepos).
              	;
E98C: CD7FE9  	chknmbr:call	morefls		;scratch1 too big?
E98F: D8      		ret	c
E990: 13      		inc	de		;yes, reset it to (filepos).
E991: 72      		ld	(hl),d
E992: 2B      		dec	hl
E993: 73      		ld	(hl),e
E994: C9      		ret	
              	;
              	;   compute (hl)=(de)-(hl)
              	;
E995: 7B      	subhl:	ld	a,e		;compute difference.
E996: 95      		sub	l
E997: 6F      		ld	l,a		;store low byte.
E998: 7A      		ld	a,d
E999: 9C      		sbc	a,h
E99A: 67      		ld	h,a		;and then high byte.
E99B: C9      		ret	
              	;
              	;   set the directory checksum byte.
              	;
E99C: 0EFF    	setdir:	ld	c,0ffh
              	;
              	;   routine to set or compare the directory checksum byte. if
              	; (c)=0ffh, then this will set the checksum byte. else the byte
              	; will be checked. if the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
E99E: 2AECF1  	checkdir: ld	hl,(cksumtbl)
E9A1: EB      		ex	de,hl
E9A2: 2ACCF1  		ld	hl,(alloc1)
E9A5: CD95E9  		call	subhl
E9A8: D0      		ret	nc		;ok if (cksumtbl) > (alloc1), so return.
E9A9: C5      		push	bc
E9AA: CDF7E8  		call	checksum	;else compute checksum.
E9AD: 2ABDF1  		ld	hl,(chkvect)	;get address of checksum table.
E9B0: EB      		ex	de,hl
E9B1: 2AECF1  		ld	hl,(cksumtbl)
E9B4: 19      		add	hl,de		;set (hl) to point to byte for this drive.
E9B5: C1      		pop	bc
E9B6: 0C      		inc	c		;set or check ?
E9B7: CAC4E9  		jp	z,chkdir1
E9BA: BE      		cp	(hl)		;check them.
E9BB: C8      		ret	z		;return if they are the same.
E9BC: CD7FE9  		call	morefls		;not the same, do we care?
E9BF: D0      		ret	nc
E9C0: CD2CE9  		call	wrtprtd		;yes, mark this as write protected.
E9C3: C9      		ret	
E9C4: 77      	chkdir1:ld	(hl),a		;just set the byte.
E9C5: C9      		ret	
              	;
              	;   do a write to the directory of the current disk.
              	;
E9C6: CD9CE9  	dirwrite: call	setdir		;set checksum byte.
E9C9: CDE0E9  		call	dirdma		;set directory dma address.
E9CC: 0E01    		ld	c,1		;tell the bios to actually write.
E9CE: CDB8E7  		call	dowrite		;then do the write.
E9D1: C3DAE9  		jp	defdma
              	;
              	;   read from the directory.
              	;
E9D4: CDE0E9  	dirread:call	dirdma		;set the directory dma address.
E9D7: CDB2E7  		call	doread		;and read it.
              	;
              	;   routine to set the dma address to the users choice.
              	;
E9DA: 21B1F1  	defdma:	ld	hl,userdma	;reset the default dma address and return.
E9DD: C3E3E9  		jp	dirdma1
              	;
              	;   routine to set the dma address for directory work.
              	;
E9E0: 21B9F1  	dirdma:	ld	hl,dirbuf
              	;
              	;   set the dma address. on entry, (hl) points to
              	; word containing the desired dma address.
              	;
E9E3: 4E      	dirdma1:ld	c,(hl)
E9E4: 23      		inc	hl
E9E5: 46      		ld	b,(hl)		;setup (bc) and go to the bios to set it.
E9E6: C304F3  		jp	setdma
              	;
              	;   move the directory buffer into user's dma space.
              	;
E9E9: 2AB9F1  	movedir:ld	hl,(dirbuf)	;buffer is located here, and
E9EC: EB      		ex	de,hl
E9ED: 2AB1F1  		ld	hl,(userdma)	; put it here.
E9F0: 0E80    		ld	c,128		;this is its length.
E9F2: C34FE7  		jp	de2hl		;move it now and return.
              	;
              	;   check (filepos) and set the zero flag if it equals 0ffffh.
              	;
E9F5: 21EAF1  	ckfilpos: ld	hl,filepos
E9F8: 7E      		ld	a,(hl)
E9F9: 23      		inc	hl
E9FA: BE      		cp	(hl)		;are both bytes the same?
E9FB: C0      		ret	nz
E9FC: 3C      		inc	a		;yes, but are they each 0ffh?
E9FD: C9      		ret	
              	;
              	;   set location (filepos) to 0ffffh.
              	;
E9FE: 21FFFF  	stfilpos: ld	hl,0ffffh
EA01: 22EAF1  		ld	(filepos),hl
EA04: C9      		ret	
              	;
              	;   move on to the next file position within the current
              	; directory buffer. if no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. enter with (c)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
EA05: 2AC8F1  	nxentry:ld	hl,(dirsize)	;get directory entry size limit.
EA08: EB      		ex	de,hl
EA09: 2AEAF1  		ld	hl,(filepos)	;get current count.
EA0C: 23      		inc	hl		;go on to the next one.
EA0D: 22EAF1  		ld	(filepos),hl
EA10: CD95E9  		call	subhl		;(hl)=(dirsize)-(filepos)
EA13: D219EA  		jp	nc,nxent1	;is there more room left?
EA16: C3FEE9  		jp	stfilpos	;no. set this flag and return.
EA19: 3AEAF1  	nxent1:	ld	a,(filepos)	;get file position within directory.
EA1C: E603    		and	03h		;only look within this sector (only 4 entries fit).
EA1E: 0605    		ld	b,5		;convert to relative position (32 bytes each).
EA20: 87      	nxent2:	add	a,a		;note that this is not efficient code.
EA21: 05      		dec	b		;5 'add a's would be better.
EA22: C220EA  		jp	nz,nxent2
EA25: 32E9F1  		ld	(fcbpos),a	;save it as position of fcb.
EA28: B7      		or	a
EA29: C0      		ret	nz		;return if we are within buffer.
EA2A: C5      		push	bc
EA2B: CDC3E7  		call	trksec		;we need the next directory sector.
EA2E: CDD4E9  		call	dirread
EA31: C1      		pop	bc
EA32: C39EE9  		jp	checkdir
              	;
              	;   routine to to get a bit from the disk space allocation
              	; map. it is returned in (a), bit position 0. on entry to here,
              	; set (bc) to the block number on the disk to check.
              	; on return, (d) will contain the original bit position for
              	; this block number and (hl) will point to the address for it.
              	;
EA35: 79      	ckbitmap: ld	a,c		;determine bit number of interest.
EA36: E607    		and	07h		;compute (d)=(e)=(c and 7)+1.
EA38: 3C      		inc	a
EA39: 5F      		ld	e,a		;save particular bit number.
EA3A: 57      		ld	d,a
              	;
              	;   compute (bc)=(bc)/8.
              	;
EA3B: 79      		ld	a,c
EA3C: 0F      		rrca			;now shift right 3 bits.
EA3D: 0F      		rrca	
EA3E: 0F      		rrca	
EA3F: E61F    		and	1fh		;and clear bits 7,6,5.
EA41: 4F      		ld	c,a
EA42: 78      		ld	a,b
EA43: 87      		add	a,a		;now shift (b) into bits 7,6,5.
EA44: 87      		add	a,a
EA45: 87      		add	a,a
EA46: 87      		add	a,a
EA47: 87      		add	a,a
EA48: B1      		or	c		;and add in (c).
EA49: 4F      		ld	c,a		;ok, (c) ha been completed.
EA4A: 78      		ld	a,b		;is there a better way of doing this?
EA4B: 0F      		rrca	
EA4C: 0F      		rrca	
EA4D: 0F      		rrca	
EA4E: E61F    		and	1fh
EA50: 47      		ld	b,a		;and now (b) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
EA51: 2ABFF1  		ld	hl,(alocvect)
EA54: 09      		add	hl,bc
EA55: 7E      		ld	a,(hl)		;now get correct byte.
EA56: 07      	ckbmap1:rlca			;get correct bit into position 0.
EA57: 1D      		dec	e
EA58: C256EA  		jp	nz,ckbmap1
EA5B: C9      		ret	
              	;
              	;   set or clear the bit map such that block number (bc) will be marked
              	; as used. on entry, if (e)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
EA5C: D5      	stbitmap: push	de
EA5D: CD35EA  		call	ckbitmap	;get the byte of interest.
EA60: E6FE    		and	0feh		;clear the affected bit.
EA62: C1      		pop	bc
EA63: B1      		or	c		;and now set it acording to (c).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (a) contains the value, (d) contains the bit
              	; position (1-8), and (hl) points to the address within the
              	; space allocation table for this byte.
              	;
EA64: 0F      	stbmap1:rrca			;restore original bit position.
EA65: 15      		dec	d
EA66: C264EA  		jp	nz,stbmap1
EA69: 77      		ld	(hl),a		;and stor byte in table.
EA6A: C9      		ret	
              	;
              	;   set/clear space used bits in allocation map for this file.
              	; on entry, (c)=1 to set the map and (c)=0 to clear it.
              	;
EA6B: CD5EE9  	setfile:call	fcb2hl		;get address of fcb
EA6E: 111000  		ld	de,16
EA71: 19      		add	hl,de		;get to block number bytes.
EA72: C5      		push	bc
EA73: 0E11    		ld	c,17		;check all 17 bytes (max) of table.
EA75: D1      	setfl1:	pop	de
EA76: 0D      		dec	c		;done all bytes yet?
EA77: C8      		ret	z
EA78: D5      		push	de
EA79: 3ADDF1  		ld	a,(bigdisk)	;check disk size for 16 bit block numbers.
EA7C: B7      		or	a
EA7D: CA88EA  		jp	z,setfl2
EA80: C5      		push	bc		;only 8 bit numbers. set (bc) to this one.
EA81: E5      		push	hl
EA82: 4E      		ld	c,(hl)		;get low byte from table, always
EA83: 0600    		ld	b,0		;set high byte to zero.
EA85: C38EEA  		jp	setfl3
EA88: 0D      	setfl2:	dec	c		;for 16 bit block numbers, adjust counter.
EA89: C5      		push	bc
EA8A: 4E      		ld	c,(hl)		;now get both the low and high bytes.
EA8B: 23      		inc	hl
EA8C: 46      		ld	b,(hl)
EA8D: E5      		push	hl
EA8E: 79      	setfl3:	ld	a,c		;block used?
EA8F: B0      		or	b
EA90: CA9DEA  		jp	z,setfl4
EA93: 2AC6F1  		ld	hl,(dsksize)	;is this block number within the
EA96: 7D      		ld	a,l		;space on the disk?
EA97: 91      		sub	c
EA98: 7C      		ld	a,h
EA99: 98      		sbc	a,b
EA9A: D45CEA  		call	nc,stbitmap	;yes, set the proper bit.
EA9D: E1      	setfl4:	pop	hl		;point to next block number in fcb.
EA9E: 23      		inc	hl
EA9F: C1      		pop	bc
EAA0: C375EA  		jp	setfl1
              	;
              	;   construct the space used allocation bit map for the active
              	; drive. if a file name starts with '$' and it is under the
              	; current user number, then (status) is set to minus 1. otherwise
              	; it is not set at all.
              	;
EAA3: 2AC6F1  	bitmap:	ld	hl,(dsksize)	;compute size of allocation table.
EAA6: 0E03    		ld	c,3
EAA8: CDEAE8  		call	shiftr		;(hl)=(hl)/8.
EAAB: 23      		inc	hl		;at lease 1 byte.
EAAC: 44      		ld	b,h
EAAD: 4D      		ld	c,l		;set (bc) to the allocation table length.
              	;
              	;   initialize the bitmap for this drive. right now, the first
              	; two bytes are specified by the disk parameter block. however
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. for example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
EAAE: 2ABFF1  		ld	hl,(alocvect)	;now zero out the table now.
EAB1: 3600    	bitmap1:ld	(hl),0
EAB3: 23      		inc	hl
EAB4: 0B      		dec	bc
EAB5: 78      		ld	a,b
EAB6: B1      		or	c
EAB7: C2B1EA  		jp	nz,bitmap1
EABA: 2ACAF1  		ld	hl,(alloc0)	;get initial space used by directory.
EABD: EB      		ex	de,hl
EABE: 2ABFF1  		ld	hl,(alocvect)	;and put this into map.
EAC1: 73      		ld	(hl),e
EAC2: 23      		inc	hl
EAC3: 72      		ld	(hl),d
              	;
              	;   end of initialization portion.
              	;
EAC4: CDA1E7  		call	homedrv		;now home the drive.
EAC7: 2AB3F1  		ld	hl,(scratch1)
EACA: 3603    		ld	(hl),3		;force next directory request to read
EACC: 23      		inc	hl		;in a sector.
EACD: 3600    		ld	(hl),0
EACF: CDFEE9  		call	stfilpos	;clear initial file position also.
EAD2: 0EFF    	bitmap2:ld	c,0ffh		;read next file name in directory
EAD4: CD05EA  		call	nxentry		;and set checksum byte.
EAD7: CDF5E9  		call	ckfilpos	;is there another file?
EADA: C8      		ret	z
EADB: CD5EE9  		call	fcb2hl		;yes, get its address.
EADE: 3EE5    		ld	a,0e5h
EAE0: BE      		cp	(hl)		;empty file entry?
EAE1: CAD2EA  		jp	z,bitmap2
EAE4: 3A41E7  		ld	a,(userno)	;no, correct user number?
EAE7: BE      		cp	(hl)
EAE8: C2F6EA  		jp	nz,bitmap3
EAEB: 23      		inc	hl
EAEC: 7E      		ld	a,(hl)		;yes, does name start with a '$'?
EAED: D624    		sub	'$'
EAEF: C2F6EA  		jp	nz,bitmap3
EAF2: 3D      		dec	a		;yes, set atatus to minus one.
EAF3: 3245E7  		ld	(status),a
EAF6: 0E01    	bitmap3:ld	c,1		;now set this file's space as used in bit map.
EAF8: CD6BEA  		call	setfile
EAFB: CD8CE9  		call	chknmbr		;keep (scratch1) in bounds.
EAFE: C3D2EA  		jp	bitmap2
              	;
              	;   set the status (status) and return.
              	;
EB01: 3AD4F1  	ststatus: ld	a,(fndstat)
EB04: C301E7  		jp	setstat
              	;
              	;   check extents in (a) and (c). set the zero flag if they
              	; are the same. the number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (extmask+1).
              	; no registers are modified.
              	;
EB07: C5      	samext:	push	bc
EB08: F5      		push	af
EB09: 3AC5F1  		ld	a,(extmask)	;get extent mask and use it to
EB0C: 2F      		cpl			;to compare both extent numbers.
EB0D: 47      		ld	b,a		;save resulting mask here.
EB0E: 79      		ld	a,c		;mask first extent and save in (c).
EB0F: A0      		and	b
EB10: 4F      		ld	c,a
EB11: F1      		pop	af		;now mask second extent and compare
EB12: A0      		and	b		;with the first one.
EB13: 91      		sub	c
EB14: E61F    		and	1fh		;(* only check buts 0-4 *)
EB16: C1      		pop	bc		;the zero flag is set if they are the same.
EB17: C9      		ret			;restore (bc) and return.
              	;
              	;   search for the first occurence of a file name. on entry,
              	; register (c) should contain the number of bytes of the fcb
              	; that must match.
              	;
EB18: 3EFF    	findfst:ld	a,0ffh
EB1A: 32D4F1  		ld	(fndstat),a
EB1D: 21D8F1  		ld	hl,counter	;save character count.
EB20: 71      		ld	(hl),c
EB21: 2A43E7  		ld	hl,(params)	;get filename to match.
EB24: 22D9F1  		ld	(savefcb),hl	;and save.
EB27: CDFEE9  		call	stfilpos	;clear initial file position (set to 0ffffh).
EB2A: CDA1E7  		call	homedrv		;home the drive.
              	;
              	;   entry to locate the next occurence of a filename within the
              	; directory. the disk is not expected to have been changed. if
              	; it was, then it will be write protected.
              	;
EB2D: 0E00    	findnxt:ld	c,0		;write protect the disk if changed.
EB2F: CD05EA  		call	nxentry		;get next filename entry in directory.
EB32: CDF5E9  		call	ckfilpos	;is file position = 0ffffh?
EB35: CA94EB  		jp	z,fndnxt6	;yes, exit now then.
EB38: 2AD9F1  		ld	hl,(savefcb)	;set (de) pointing to filename to match.
EB3B: EB      		ex	de,hl
EB3C: 1A      		ld	a,(de)
EB3D: FEE5    		cp	0e5h		;empty directory entry?
EB3F: CA4AEB  		jp	z,fndnxt1	;(* are we trying to reserect erased entries? *)
EB42: D5      		push	de
EB43: CD7FE9  		call	morefls		;more files in directory?
EB46: D1      		pop	de
EB47: D294EB  		jp	nc,fndnxt6	;no more. exit now.
EB4A: CD5EE9  	fndnxt1:call	fcb2hl		;get address of this fcb in directory.
EB4D: 3AD8F1  		ld	a,(counter)	;get number of bytes (characters) to check.
EB50: 4F      		ld	c,a
EB51: 0600    		ld	b,0		;initialize byte position counter.
EB53: 79      	fndnxt2:ld	a,c		;are we done with the compare?
EB54: B7      		or	a
EB55: CA83EB  		jp	z,fndnxt5
EB58: 1A      		ld	a,(de)		;no, check next byte.
EB59: FE3F    		cp	'?'		;don't care about this character?
EB5B: CA7CEB  		jp	z,fndnxt4
EB5E: 78      		ld	a,b		;get bytes position in fcb.
EB5F: FE0D    		cp	13		;don't care about the thirteenth byte either.
EB61: CA7CEB  		jp	z,fndnxt4
EB64: FE0C    		cp	12		;extent byte?
EB66: 1A      		ld	a,(de)
EB67: CA73EB  		jp	z,fndnxt3
EB6A: 96      		sub	(hl)		;otherwise compare characters.
EB6B: E67F    		and	7fh
EB6D: C22DEB  		jp	nz,findnxt	;not the same, check next entry.
EB70: C37CEB  		jp	fndnxt4		;so far so good, keep checking.
EB73: C5      	fndnxt3:push	bc		;check the extent byte here.
EB74: 4E      		ld	c,(hl)
EB75: CD07EB  		call	samext
EB78: C1      		pop	bc
EB79: C22DEB  		jp	nz,findnxt	;not the same, look some more.
              	;
              	;   so far the names compare. bump pointers to the next byte
              	; and continue until all (c) characters have been checked.
              	;
EB7C: 13      	fndnxt4:inc	de		;bump pointers.
EB7D: 23      		inc	hl
EB7E: 04      		inc	b
EB7F: 0D      		dec	c		;adjust character counter.
EB80: C353EB  		jp	fndnxt2
EB83: 3AEAF1  	fndnxt5:ld	a,(filepos)	;return the position of this entry.
EB86: E603    		and	03h
EB88: 3245E7  		ld	(status),a
EB8B: 21D4F1  		ld	hl,fndstat
EB8E: 7E      		ld	a,(hl)
EB8F: 17      		rla	
EB90: D0      		ret	nc
EB91: AF      		xor	a
EB92: 77      		ld	(hl),a
EB93: C9      		ret	
              	;
              	;   filename was not found. set appropriate status.
              	;
EB94: CDFEE9  	fndnxt6:call	stfilpos	;set (filepos) to 0ffffh.
EB97: 3EFF    		ld	a,0ffh		;say not located.
EB99: C301E7  		jp	setstat
              	;
              	;   erase files from the directory. only the first byte of the
              	; fcb will be affected. it is set to (e5).
              	;
EB9C: CD54E9  	erafile:call	chkwprt		;is disk write protected?
EB9F: 0E0C    		ld	c,12		;only compare file names.
EBA1: CD18EB  		call	findfst		;get first file name.
EBA4: CDF5E9  	erafil1:call	ckfilpos	;any found?
EBA7: C8      		ret	z		;nope, we must be done.
EBA8: CD44E9  		call	chkrofl		;is file read only?
EBAB: CD5EE9  		call	fcb2hl		;nope, get address of fcb and
EBAE: 36E5    		ld	(hl),0e5h	;set first byte to 'empty'.
EBB0: 0E00    		ld	c,0		;clear the space from the bit map.
EBB2: CD6BEA  		call	setfile
EBB5: CDC6E9  		call	dirwrite	;now write the directory sector back out.
EBB8: CD2DEB  		call	findnxt		;find the next file name.
EBBB: C3A4EB  		jp	erafil1		;and repeat process.
              	;
              	;   look through the space allocation map (bit map) for the
              	; next available block. start searching at block number (bc-1).
              	; the search procedure is to look for an empty block that is
              	; before the starting block. if not empty, look at a later
              	; block number. in this way, we return the closest empty block
              	; on either side of the 'target' block number. this will speed
              	; access on random devices. for serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   on return, (de)= block number that is empty and (hl) =0
              	; if no empry block was found.
              	;
EBBE: 50      	fndspace: ld	d,b		;set (de) as the block that is checked.
EBBF: 59      		ld	e,c
              	;
              	;   look before target block. registers (bc) are used as the lower
              	; pointer and (de) as the upper pointer.
              	;
EBC0: 79      	fndspa1:ld	a,c		;is block 0 specified?
EBC1: B0      		or	b
EBC2: CAD1EB  		jp	z,fndspa2
EBC5: 0B      		dec	bc		;nope, check previous block.
EBC6: D5      		push	de
EBC7: C5      		push	bc
EBC8: CD35EA  		call	ckbitmap
EBCB: 1F      		rra			;is this block empty?
EBCC: D2ECEB  		jp	nc,fndspa3	;yes. use this.
              	;
              	;   note that the above logic gets the first block that it finds
              	; that is empty. thus a file could be written 'backward' making
              	; it very slow to access. this could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; this should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
EBCF: C1      		pop	bc		;nope, check some more.
EBD0: D1      		pop	de
              	;
              	;   now look after target block.
              	;
EBD1: 2AC6F1  	fndspa2:ld	hl,(dsksize)	;is block (de) within disk limits?
EBD4: 7B      		ld	a,e
EBD5: 95      		sub	l
EBD6: 7A      		ld	a,d
EBD7: 9C      		sbc	a,h
EBD8: D2F4EB  		jp	nc,fndspa4
EBDB: 13      		inc	de		;yes, move on to next one.
EBDC: C5      		push	bc
EBDD: D5      		push	de
EBDE: 42      		ld	b,d
EBDF: 4B      		ld	c,e
EBE0: CD35EA  		call	ckbitmap	;check it.
EBE3: 1F      		rra			;empty?
EBE4: D2ECEB  		jp	nc,fndspa3
EBE7: D1      		pop	de		;nope, continue searching.
EBE8: C1      		pop	bc
EBE9: C3C0EB  		jp	fndspa1
              	;
              	;   empty block found. set it as used and return with (hl)
              	; pointing to it (true?).
              	;
EBEC: 17      	fndspa3:rla			;reset byte.
EBED: 3C      		inc	a		;and set bit 0.
EBEE: CD64EA  		call	stbmap1		;update bit map.
EBF1: E1      		pop	hl		;set return registers.
EBF2: D1      		pop	de
EBF3: C9      		ret	
              	;
              	;   free block was not found. if (bc) is not zero, then we have
              	; not checked all of the disk space.
              	;
EBF4: 79      	fndspa4:ld	a,c
EBF5: B0      		or	b
EBF6: C2C0EB  		jp	nz,fndspa1
EBF9: 210000  		ld	hl,0		;set 'not found' status.
EBFC: C9      		ret	
              	;
              	;   move a complete fcb entry into the directory and write it.
              	;
EBFD: 0E00    	fcbset:	ld	c,0
EBFF: 1E20    		ld	e,32		;length of each entry.
              	;
              	;   move (e) bytes from the fcb pointed to by (params) into
              	; fcb in directory starting at relative byte (c). this updated
              	; directory buffer is then written to the disk.
              	;
EC01: D5      	update:	push	de
EC02: 0600    		ld	b,0		;set (bc) to relative byte position.
EC04: 2A43E7  		ld	hl,(params)	;get address of fcb.
EC07: 09      		add	hl,bc		;compute starting byte.
EC08: EB      		ex	de,hl
EC09: CD5EE9  		call	fcb2hl		;get address of fcb to update in directory.
EC0C: C1      		pop	bc		;set (c) to number of bytes to change.
EC0D: CD4FE7  		call	de2hl
EC10: CDC3E7  	update1:call	trksec		;determine the track and sector affected.
EC13: C3C6E9  		jp	dirwrite	;then write this sector out.
              	;
              	;   routine to change the name of all files on the disk with a
              	; specified name. the fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
EC16: CD54E9  	chgnames: call	chkwprt		;check for a write protected disk.
EC19: 0E0C    		ld	c,12		;match first 12 bytes of fcb only.
EC1B: CD18EB  		call	findfst		;get first name.
EC1E: 2A43E7  		ld	hl,(params)	;get address of fcb.
EC21: 7E      		ld	a,(hl)		;get user number.
EC22: 111000  		ld	de,16		;move over to desired name.
EC25: 19      		add	hl,de
EC26: 77      		ld	(hl),a		;keep same user number.
EC27: CDF5E9  	chgnam1:call	ckfilpos	;any matching file found?
EC2A: C8      		ret	z		;no, we must be done.
EC2B: CD44E9  		call	chkrofl		;check for read only file.
EC2E: 0E10    		ld	c,16		;start 16 bytes into fcb.
EC30: 1E0C    		ld	e,12		;and update the first 12 bytes of directory.
EC32: CD01EC  		call	update
EC35: CD2DEB  		call	findnxt		;get te next file name.
EC38: C327EC  		jp	chgnam1		;and continue.
              	;
              	;   update a files attributes. the procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). no other changes
              	; are made.
              	;
EC3B: 0E0C    	saveattr: ld	c,12		;match first 12 bytes.
EC3D: CD18EB  		call	findfst		;look for first filename.
EC40: CDF5E9  	savatr1:call	ckfilpos	;was one found?
EC43: C8      		ret	z		;nope, we must be done.
EC44: 0E00    		ld	c,0		;yes, update the first 12 bytes now.
EC46: 1E0C    		ld	e,12
EC48: CD01EC  		call	update		;update filename and write directory.
EC4B: CD2DEB  		call	findnxt		;and get the next file.
EC4E: C340EC  		jp	savatr1		;then continue until done.
              	;
              	;  open a file (name specified in fcb).
              	;
EC51: 0E0F    	openit:	ld	c,15		;compare the first 15 bytes.
EC53: CD18EB  		call	findfst		;get the first one in directory.
EC56: CDF5E9  		call	ckfilpos	;any at all?
EC59: C8      		ret	z
EC5A: CDA6E8  	openit1:call	setext		;point to extent byte within users fcb.
EC5D: 7E      		ld	a,(hl)		;and get it.
EC5E: F5      		push	af		;save it and address.
EC5F: E5      		push	hl
EC60: CD5EE9  		call	fcb2hl		;point to fcb in directory.
EC63: EB      		ex	de,hl
EC64: 2A43E7  		ld	hl,(params)	;this is the users copy.
EC67: 0E20    		ld	c,32		;move it into users space.
EC69: D5      		push	de
EC6A: CD4FE7  		call	de2hl
EC6D: CD78E9  		call	sets2b7		;set bit 7 in 's2' byte (unmodified).
EC70: D1      		pop	de		;now get the extent byte from this fcb.
EC71: 210C00  		ld	hl,12
EC74: 19      		add	hl,de
EC75: 4E      		ld	c,(hl)		;into (c).
EC76: 210F00  		ld	hl,15		;now get the record count byte into (b).
EC79: 19      		add	hl,de
EC7A: 46      		ld	b,(hl)
EC7B: E1      		pop	hl		;keep the same extent as the user had originally.
EC7C: F1      		pop	af
EC7D: 77      		ld	(hl),a
EC7E: 79      		ld	a,c		;is it the same as in the directory fcb?
EC7F: BE      		cp	(hl)
EC80: 78      		ld	a,b		;if yes, then use the same record count.
EC81: CA8BEC  		jp	z,openit2
EC84: 3E00    		ld	a,0		;if the user specified an extent greater than
EC86: DA8BEC  		jp	c,openit2	;the one in the directory, then set record count to 0.
EC89: 3E80    		ld	a,128		;otherwise set to maximum.
EC8B: 2A43E7  	openit2:ld	hl,(params)	;set record count in users fcb to (a).
EC8E: 110F00  		ld	de,15
EC91: 19      		add	hl,de		;compute relative position.
EC92: 77      		ld	(hl),a		;and set the record count.
EC93: C9      		ret	
              	;
              	;   move two bytes from (de) to (hl) if (and only if) (hl)
              	; point to a zero value (16 bit).
              	;   return with zero flag set it (de) was moved. registers (de)
              	; and (hl) are not changed. however (a) is.
              	;
EC94: 7E      	moveword: ld	a,(hl)		;check for a zero word.
EC95: 23      		inc	hl
EC96: B6      		or	(hl)		;both bytes zero?
EC97: 2B      		dec	hl
EC98: C0      		ret	nz		;nope, just return.
EC99: 1A      		ld	a,(de)		;yes, move two bytes from (de) into
EC9A: 77      		ld	(hl),a		;this zero space.
EC9B: 13      		inc	de
EC9C: 23      		inc	hl
EC9D: 1A      		ld	a,(de)
EC9E: 77      		ld	(hl),a
EC9F: 1B      		dec	de		;don't disturb these registers.
ECA0: 2B      		dec	hl
ECA1: C9      		ret	
              	;
              	;   get here to close a file specified by (fcb).
              	;
ECA2: AF      	closeit:xor	a		;clear status and file position bytes.
ECA3: 3245E7  		ld	(status),a
ECA6: 32EAF1  		ld	(filepos),a
ECA9: 32EBF1  		ld	(filepos+1),a
ECAC: CD1EE9  		call	getwprt		;get write protect bit for this drive.
ECAF: C0      		ret	nz		;just return if it is set.
ECB0: CD69E9  		call	gets2		;else get the 's2' byte.
ECB3: E680    		and	80h		;and look at bit 7 (file unmodified?).
ECB5: C0      		ret	nz		;just return if set.
ECB6: 0E0F    		ld	c,15		;else look up this file in directory.
ECB8: CD18EB  		call	findfst
ECBB: CDF5E9  		call	ckfilpos	;was it found?
ECBE: C8      		ret	z		;just return if not.
ECBF: 011000  		ld	bc,16		;set (hl) pointing to records used section.
ECC2: CD5EE9  		call	fcb2hl
ECC5: 09      		add	hl,bc
ECC6: EB      		ex	de,hl
ECC7: 2A43E7  		ld	hl,(params)	;do the same for users specified fcb.
ECCA: 09      		add	hl,bc
ECCB: 0E10    		ld	c,16		;this many bytes are present in this extent.
ECCD: 3ADDF1  	closeit1: ld	a,(bigdisk)	;8 or 16 bit record numbers?
ECD0: B7      		or	a
ECD1: CAE8EC  		jp	z,closeit4
ECD4: 7E      		ld	a,(hl)		;just 8 bit. get one from users fcb.
ECD5: B7      		or	a
ECD6: 1A      		ld	a,(de)		;now get one from directory fcb.
ECD7: C2DBEC  		jp	nz,closeit2
ECDA: 77      		ld	(hl),a		;users byte was zero. update from directory.
ECDB: B7      	closeit2: or	a
ECDC: C2E1EC  		jp	nz,closeit3
ECDF: 7E      		ld	a,(hl)		;directories byte was zero, update from users fcb.
ECE0: 12      		ld	(de),a
ECE1: BE      	closeit3: cp	(hl)		;if neither one of these bytes were zero,
ECE2: C21FED  		jp	nz,closeit7	;then close error if they are not the same.
ECE5: C3FDEC  		jp	closeit5	;ok so far, get to next byte in fcbs.
ECE8: CD94EC  	closeit4: call	moveword	;update users fcb if it is zero.
ECEB: EB      		ex	de,hl
ECEC: CD94EC  		call	moveword	;update directories fcb if it is zero.
ECEF: EB      		ex	de,hl
ECF0: 1A      		ld	a,(de)		;if these two values are no different,
ECF1: BE      		cp	(hl)		;then a close error occured.
ECF2: C21FED  		jp	nz,closeit7
ECF5: 13      		inc	de		;check second byte.
ECF6: 23      		inc	hl
ECF7: 1A      		ld	a,(de)
ECF8: BE      		cp	(hl)
ECF9: C21FED  		jp	nz,closeit7
ECFC: 0D      		dec	c		;remember 16 bit values.
ECFD: 13      	closeit5: inc	de		;bump to next item in table.
ECFE: 23      		inc	hl
ECFF: 0D      		dec	c		;there are 16 entries only.
ED00: C2CDEC  		jp	nz,closeit1	;continue if more to do.
ED03: 01ECFF  		ld	bc,0ffech	;backup 20 places (extent byte).
ED06: 09      		add	hl,bc
ED07: EB      		ex	de,hl
ED08: 09      		add	hl,bc
ED09: 1A      		ld	a,(de)
ED0A: BE      		cp	(hl)		;directory's extent already greater than the
ED0B: DA17ED  		jp	c,closeit6	;users extent?
ED0E: 77      		ld	(hl),a		;no, update directory extent.
ED0F: 010300  		ld	bc,3		;and update the record count byte in
ED12: 09      		add	hl,bc		;directories fcb.
ED13: EB      		ex	de,hl
ED14: 09      		add	hl,bc
ED15: 7E      		ld	a,(hl)		;get from user.
ED16: 12      		ld	(de),a		;and put in directory.
ED17: 3EFF    	closeit6: ld	a,0ffh		;set 'was open and is now closed' byte.
ED19: 32D2F1  		ld	(closeflg),a
ED1C: C310EC  		jp	update1		;update the directory now.
ED1F: 2145E7  	closeit7: ld	hl,status	;set return status and then return.
ED22: 35      		dec	(hl)
ED23: C9      		ret	
              	;
              	;   routine to get the next empty space in the directory. it
              	; will then be cleared for use.
              	;
ED24: CD54E9  	getempty: call	chkwprt		;make sure disk is not write protected.
ED27: 2A43E7  		ld	hl,(params)	;save current parameters (fcb).
ED2A: E5      		push	hl
ED2B: 21ACF1  		ld	hl,emptyfcb	;use special one for empty space.
ED2E: 2243E7  		ld	(params),hl
ED31: 0E01    		ld	c,1		;search for first empty spot in directory.
ED33: CD18EB  		call	findfst		;(* only check first byte *)
ED36: CDF5E9  		call	ckfilpos	;none?
ED39: E1      		pop	hl
ED3A: 2243E7  		ld	(params),hl	;restore original fcb address.
ED3D: C8      		ret	z		;return if no more space.
ED3E: EB      		ex	de,hl
ED3F: 210F00  		ld	hl,15		;point to number of records for this file.
ED42: 19      		add	hl,de
ED43: 0E11    		ld	c,17		;and clear all of this space.
ED45: AF      		xor	a
ED46: 77      	getmt1:	ld	(hl),a
ED47: 23      		inc	hl
ED48: 0D      		dec	c
ED49: C246ED  		jp	nz,getmt1
ED4C: 210D00  		ld	hl,13		;clear the 's1' byte also.
ED4F: 19      		add	hl,de
ED50: 77      		ld	(hl),a
ED51: CD8CE9  		call	chknmbr		;keep (scratch1) within bounds.
ED54: CDFDEB  		call	fcbset		;write out this fcb entry to directory.
ED57: C378E9  		jp	sets2b7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   routine to close the current extent and open the next one
              	; for reading.
              	;
ED5A: AF      	getnext:xor	a
ED5B: 32D2F1  		ld	(closeflg),a	;clear close flag.
ED5E: CDA2EC  		call	closeit		;close this extent.
ED61: CDF5E9  		call	ckfilpos
ED64: C8      		ret	z		;not there???
ED65: 2A43E7  		ld	hl,(params)	;get extent byte.
ED68: 010C00  		ld	bc,12
ED6B: 09      		add	hl,bc
ED6C: 7E      		ld	a,(hl)		;and increment it.
ED6D: 3C      		inc	a
ED6E: E61F    		and	1fh		;keep within range 0-31.
ED70: 77      		ld	(hl),a
ED71: CA83ED  		jp	z,gtnext1	;overflow?
ED74: 47      		ld	b,a		;mask extent byte.
ED75: 3AC5F1  		ld	a,(extmask)
ED78: A0      		and	b
ED79: 21D2F1  		ld	hl,closeflg	;check close flag (0ffh is ok).
ED7C: A6      		and	(hl)
ED7D: CA8EED  		jp	z,gtnext2	;if zero, we must read in next extent.
ED80: C3ACED  		jp	gtnext3		;else, it is already in memory.
ED83: 010200  	gtnext1:ld	bc,2		;point to the 's2' byte.
ED86: 09      		add	hl,bc
ED87: 34      		inc	(hl)		;and bump it.
ED88: 7E      		ld	a,(hl)		;too many extents?
ED89: E60F    		and	0fh
ED8B: CAB6ED  		jp	z,gtnext5	;yes, set error code.
              	;
              	;   get here to open the next extent.
              	;
ED8E: 0E0F    	gtnext2:ld	c,15		;set to check first 15 bytes of fcb.
ED90: CD18EB  		call	findfst		;find the first one.
ED93: CDF5E9  		call	ckfilpos	;none available?
ED96: C2ACED  		jp	nz,gtnext3
ED99: 3AD3F1  		ld	a,(rdwrtflg)	;no extent present. can we open an empty one?
ED9C: 3C      		inc	a		;0ffh means reading (so not possible).
ED9D: CAB6ED  		jp	z,gtnext5	;or an error.
EDA0: CD24ED  		call	getempty	;we are writing, get an empty entry.
EDA3: CDF5E9  		call	ckfilpos	;none?
EDA6: CAB6ED  		jp	z,gtnext5	;error if true.
EDA9: C3AFED  		jp	gtnext4		;else we are almost done.
EDAC: CD5AEC  	gtnext3:call	openit1		;open this extent.
EDAF: CDBBE8  	gtnext4:call	strdata		;move in updated data (rec #, extent #, etc.)
EDB2: AF      		xor	a		;clear status and return.
EDB3: C301E7  		jp	setstat
              	;
              	;   error in extending the file. too many extents were needed
              	; or not enough space on the disk.
              	;
EDB6: CD05E7  	gtnext5:call	ioerr1		;set error code, clear bit 7 of 's2'
EDB9: C378E9  		jp	sets2b7		;so this is not written on a close.
              	;
              	;   read a sequential file.
              	;
EDBC: 3E01    	rdseq:	ld	a,1		;set sequential access mode.
EDBE: 32D5F1  		ld	(mode),a
EDC1: 3EFF    	rdseq1:	ld	a,0ffh		;don't allow reading unwritten space.
EDC3: 32D3F1  		ld	(rdwrtflg),a
EDC6: CDBBE8  		call	strdata		;put rec# and ext# into fcb.
EDC9: 3AE3F1  		ld	a,(savnrec)	;get next record to read.
EDCC: 21E1F1  		ld	hl,savnxt	;get number of records in extent.
EDCF: BE      		cp	(hl)		;within this extent?
EDD0: DAE6ED  		jp	c,rdseq2
EDD3: FE80    		cp	128		;no. is this extent fully used?
EDD5: C2FBED  		jp	nz,rdseq3	;no. end-of-file.
EDD8: CD5AED  		call	getnext		;yes, open the next one.
EDDB: AF      		xor	a		;reset next record to read.
EDDC: 32E3F1  		ld	(savnrec),a
EDDF: 3A45E7  		ld	a,(status)	;check on open, successful?
EDE2: B7      		or	a
EDE3: C2FBED  		jp	nz,rdseq3	;no, error.
EDE6: CD77E8  	rdseq2:	call	comblk		;ok. compute block number to read.
EDE9: CD84E8  		call	chkblk		;check it. within bounds?
EDEC: CAFBED  		jp	z,rdseq3	;no, error.
EDEF: CD8AE8  		call	logical		;convert (blknmbr) to logical sector (128 byte).
EDF2: CDD1E7  		call	trksec1		;set the track and sector for this block #.
EDF5: CDB2E7  		call	doread		;and read it.
EDF8: C3D2E8  		jp	setnrec		;and set the next record to be accessed.
              	;
              	;   read error occured. set status and return.
              	;
EDFB: C305E7  	rdseq3:	jp	ioerr1
              	;
              	;   write the next sequential record.
              	;
EDFE: 3E01    	wtseq:	ld	a,1		;set sequential access mode.
EE00: 32D5F1  		ld	(mode),a
EE03: 3E00    	wtseq1:	ld	a,0		;allow an addition empty extent to be opened.
EE05: 32D3F1  		ld	(rdwrtflg),a
EE08: CD54E9  		call	chkwprt		;check write protect status.
EE0B: 2A43E7  		ld	hl,(params)
EE0E: CD47E9  		call	ckrof1		;check for read only file, (hl) already set to fcb.
EE11: CDBBE8  		call	strdata		;put updated data into fcb.
EE14: 3AE3F1  		ld	a,(savnrec)	;get record number to write.
EE17: FE80    		cp	128		;within range?
EE19: D205E7  		jp	nc,ioerr1	;no, error(?).
EE1C: CD77E8  		call	comblk		;compute block number.
EE1F: CD84E8  		call	chkblk		;check number.
EE22: 0E00    		ld	c,0		;is there one to write to?
EE24: C26EEE  		jp	nz,wtseq6	;yes, go do it.
EE27: CD3EE8  		call	getblock	;get next block number within fcb to use.
EE2A: 32D7F1  		ld	(relblock),a	;and save.
EE2D: 010000  		ld	bc,0		;start looking for space from the start
EE30: B7      		or	a		;if none allocated as yet.
EE31: CA3BEE  		jp	z,wtseq2
EE34: 4F      		ld	c,a		;extract previous block number from fcb
EE35: 0B      		dec	bc		;so we can be closest to it.
EE36: CD5EE8  		call	extblk
EE39: 44      		ld	b,h
EE3A: 4D      		ld	c,l
EE3B: CDBEEB  	wtseq2:	call	fndspace	;find the next empty block nearest number (bc).
EE3E: 7D      		ld	a,l		;check for a zero number.
EE3F: B4      		or	h
EE40: C248EE  		jp	nz,wtseq3
EE43: 3E02    		ld	a,2		;no more space?
EE45: C301E7  		jp	setstat
EE48: 22E5F1  	wtseq3:	ld	(blknmbr),hl	;save block number to access.
EE4B: EB      		ex	de,hl		;put block number into (de).
EE4C: 2A43E7  		ld	hl,(params)	;now we must update the fcb for this
EE4F: 011000  		ld	bc,16		;newly allocated block.
EE52: 09      		add	hl,bc
EE53: 3ADDF1  		ld	a,(bigdisk)	;8 or 16 bit block numbers?
EE56: B7      		or	a
EE57: 3AD7F1  		ld	a,(relblock)	;(* update this entry *)
EE5A: CA64EE  		jp	z,wtseq4	;zero means 16 bit ones.
EE5D: CD64E9  		call	adda2hl		;(hl)=(hl)+(a)
EE60: 73      		ld	(hl),e		;store new block number.
EE61: C36CEE  		jp	wtseq5
EE64: 4F      	wtseq4:	ld	c,a		;compute spot in this 16 bit table.
EE65: 0600    		ld	b,0
EE67: 09      		add	hl,bc
EE68: 09      		add	hl,bc
EE69: 73      		ld	(hl),e		;stuff block number (de) there.
EE6A: 23      		inc	hl
EE6B: 72      		ld	(hl),d
EE6C: 0E02    	wtseq5:	ld	c,2		;set (c) to indicate writing to un-used disk space.
EE6E: 3A45E7  	wtseq6:	ld	a,(status)	;are we ok so far?
EE71: B7      		or	a
EE72: C0      		ret	nz
EE73: C5      		push	bc		;yes, save write flag for bios (register c).
EE74: CD8AE8  		call	logical		;convert (blknmbr) over to loical sectors.
EE77: 3AD5F1  		ld	a,(mode)	;get access mode flag (1=sequential,
EE7A: 3D      		dec	a		;0=random, 2=special?).
EE7B: 3D      		dec	a
EE7C: C2BBEE  		jp	nz,wtseq9
              	;
              	;   special random i/o from function #40. maybe for m/pm, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
EE7F: C1      		pop	bc
EE80: C5      		push	bc
EE81: 79      		ld	a,c		;get write status flag (2=writing unused space).
EE82: 3D      		dec	a
EE83: 3D      		dec	a
EE84: C2BBEE  		jp	nz,wtseq9
EE87: E5      		push	hl
EE88: 2AB9F1  		ld	hl,(dirbuf)	;zero out the directory buffer.
EE8B: 57      		ld	d,a		;note that (a) is zero here.
EE8C: 77      	wtseq7:	ld	(hl),a
EE8D: 23      		inc	hl
EE8E: 14      		inc	d		;do 128 bytes.
EE8F: F28CEE  		jp	p,wtseq7
EE92: CDE0E9  		call	dirdma		;tell the bios the dma address for directory access.
EE95: 2AE7F1  		ld	hl,(logsect)	;get sector that starts current block.
EE98: 0E02    		ld	c,2		;set 'writing to unused space' flag.
EE9A: 22E5F1  	wtseq8:	ld	(blknmbr),hl	;save sector to write.
EE9D: C5      		push	bc
EE9E: CDD1E7  		call	trksec1		;determine its track and sector numbers.
EEA1: C1      		pop	bc
EEA2: CDB8E7  		call	dowrite		;now write out 128 bytes of zeros.
EEA5: 2AE5F1  		ld	hl,(blknmbr)	;get sector number.
EEA8: 0E00    		ld	c,0		;set normal write flag.
EEAA: 3AC4F1  		ld	a,(blkmask)	;determine if we have written the entire
EEAD: 47      		ld	b,a		;physical block.
EEAE: A5      		and	l
EEAF: B8      		cp	b
EEB0: 23      		inc	hl		;prepare for the next one.
EEB1: C29AEE  		jp	nz,wtseq8	;continue until (blkmask+1) sectors written.
EEB4: E1      		pop	hl		;reset next sector number.
EEB5: 22E5F1  		ld	(blknmbr),hl
EEB8: CDDAE9  		call	defdma		;and reset dma address.
              	;
              	;   normal disk write. set the desired track and sector then
              	; do the actual write.
              	;
EEBB: CDD1E7  	wtseq9:	call	trksec1		;determine track and sector for this write.
EEBE: C1      		pop	bc		;get write status flag.
EEBF: C5      		push	bc
EEC0: CDB8E7  		call	dowrite		;and write this out.
EEC3: C1      		pop	bc
EEC4: 3AE3F1  		ld	a,(savnrec)	;get number of records in file.
EEC7: 21E1F1  		ld	hl,savnxt	;get last record written.
EECA: BE      		cp	(hl)
EECB: DAD2EE  		jp	c,wtseq10
EECE: 77      		ld	(hl),a		;we have to update record count.
EECF: 34      		inc	(hl)
EED0: 0E02    		ld	c,2
              	;
              	;*   this area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the bios.
              	;
EED2: 00      	wtseq10:nop			;was 'dcr c'
EED3: 00      		nop			;was 'dcr c'
EED4: 210000  		ld	hl,0		;was 'jnz wtseq99'
              	;
              	; *   end of patch.
              	;
EED7: F5      		push	af
EED8: CD69E9  		call	gets2		;set 'extent written to' flag.
EEDB: E67F    		and	7fh		;(* clear bit 7 *)
EEDD: 77      		ld	(hl),a
EEDE: F1      		pop	af		;get record count for this extent.
EEDF: FE7F    	wtseq99:cp	127		;is it full?
EEE1: C200EF  		jp	nz,wtseq12
EEE4: 3AD5F1  		ld	a,(mode)	;yes, are we in sequential mode?
EEE7: FE01    		cp	1
EEE9: C200EF  		jp	nz,wtseq12
EEEC: CDD2E8  		call	setnrec		;yes, set next record number.
EEEF: CD5AED  		call	getnext		;and get next empty space in directory.
EEF2: 2145E7  		ld	hl,status	;ok?
EEF5: 7E      		ld	a,(hl)
EEF6: B7      		or	a
EEF7: C2FEEE  		jp	nz,wtseq11
EEFA: 3D      		dec	a		;yes, set record count to -1.
EEFB: 32E3F1  		ld	(savnrec),a
EEFE: 3600    	wtseq11:ld	(hl),0		;clear status.
EF00: C3D2E8  	wtseq12:jp	setnrec		;set next record to access.
              	;
              	;   for random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. these bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   on entry, register (c) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. otherwise,
              	; another extent will be opened (for writing) if required.
              	;
EF03: AF      	position: xor	a		;set random i/o flag.
EF04: 32D5F1  		ld	(mode),a
              	;
              	;   special entry (function #40). m/pm ?
              	;
EF07: C5      	positn1:push	bc		;save read/write flag.
EF08: 2A43E7  		ld	hl,(params)	;get address of fcb.
EF0B: EB      		ex	de,hl
EF0C: 212100  		ld	hl,33		;now get byte 'r0'.
EF0F: 19      		add	hl,de
EF10: 7E      		ld	a,(hl)
EF11: E67F    		and	7fh		;keep bits 0-6 for the record number to access.
EF13: F5      		push	af
EF14: 7E      		ld	a,(hl)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
EF15: 17      		rla	
EF16: 23      		inc	hl
EF17: 7E      		ld	a,(hl)
EF18: 17      		rla	
EF19: E61F    		and	1fh		;and save this in bits 0-4 of (c).
EF1B: 4F      		ld	c,a		;this is the extent byte.
EF1C: 7E      		ld	a,(hl)		;now get the extra extent byte.
EF1D: 1F      		rra	
EF1E: 1F      		rra	
EF1F: 1F      		rra	
EF20: 1F      		rra	
EF21: E60F    		and	0fh
EF23: 47      		ld	b,a		;and save it in (b).
EF24: F1      		pop	af		;get record number back to (a).
EF25: 23      		inc	hl		;check overflow byte 'r2'.
EF26: 6E      		ld	l,(hl)
EF27: 2C      		inc	l
EF28: 2D      		dec	l
EF29: 2E06    		ld	l,6		;prepare for error.
EF2B: C28BEF  		jp	nz,positn5	;out of disk space error.
EF2E: 212000  		ld	hl,32		;store record number into fcb.
EF31: 19      		add	hl,de
EF32: 77      		ld	(hl),a
EF33: 210C00  		ld	hl,12		;and now check the extent byte.
EF36: 19      		add	hl,de
EF37: 79      		ld	a,c
EF38: 96      		sub	(hl)		;same extent as before?
EF39: C247EF  		jp	nz,positn2
EF3C: 210E00  		ld	hl,14		;yes, check extra extent byte 's2' also.
EF3F: 19      		add	hl,de
EF40: 78      		ld	a,b
EF41: 96      		sub	(hl)
EF42: E67F    		and	7fh
EF44: CA7FEF  		jp	z,positn3	;same, we are almost done then.
              	;
              	;  get here when another extent is required.
              	;
EF47: C5      	positn2:push	bc
EF48: D5      		push	de
EF49: CDA2EC  		call	closeit		;close current extent.
EF4C: D1      		pop	de
EF4D: C1      		pop	bc
EF4E: 2E03    		ld	l,3		;prepare for error.
EF50: 3A45E7  		ld	a,(status)
EF53: 3C      		inc	a
EF54: CA84EF  		jp	z,positn4	;close error.
EF57: 210C00  		ld	hl,12		;put desired extent into fcb now.
EF5A: 19      		add	hl,de
EF5B: 71      		ld	(hl),c
EF5C: 210E00  		ld	hl,14		;and store extra extent byte 's2'.
EF5F: 19      		add	hl,de
EF60: 70      		ld	(hl),b
EF61: CD51EC  		call	openit		;try and get this extent.
EF64: 3A45E7  		ld	a,(status)	;was it there?
EF67: 3C      		inc	a
EF68: C27FEF  		jp	nz,positn3
EF6B: C1      		pop	bc		;no. can we create a new one (writing?).
EF6C: C5      		push	bc
EF6D: 2E04    		ld	l,4		;prepare for error.
EF6F: 0C      		inc	c
EF70: CA84EF  		jp	z,positn4	;nope, reading unwritten space error.
EF73: CD24ED  		call	getempty	;yes we can, try to find space.
EF76: 2E05    		ld	l,5		;prepare for error.
EF78: 3A45E7  		ld	a,(status)
EF7B: 3C      		inc	a
EF7C: CA84EF  		jp	z,positn4	;out of space?
              	;
              	;   normal return location. clear error code and return.
              	;
EF7F: C1      	positn3:pop	bc		;restore stack.
EF80: AF      		xor	a		;and clear error code byte.
EF81: C301E7  		jp	setstat
              	;
              	;   error. set the 's2' byte to indicate this (why?).
              	;
EF84: E5      	positn4:push	hl
EF85: CD69E9  		call	gets2
EF88: 36C0    		ld	(hl),0c0h
EF8A: E1      		pop	hl
              	;
              	;   return with error code (presently in l).
              	;
EF8B: C1      	positn5:pop	bc
EF8C: 7D      		ld	a,l		;get error code.
EF8D: 3245E7  		ld	(status),a
EF90: C378E9  		jp	sets2b7
              	;
              	;   read a random record.
              	;
EF93: 0EFF    	readran:ld	c,0ffh		;set 'read' status.
EF95: CD03EF  		call	position	;position the file to proper record.
EF98: CCC1ED  		call	z,rdseq1	;and read it as usual (if no errors).
EF9B: C9      		ret	
              	;
              	;   write to a random record.
              	;
EF9C: 0E00    	writeran: ld	c,0		;set 'writing' flag.
EF9E: CD03EF  		call	position	;position the file to proper record.
EFA1: CC03EE  		call	z,wtseq1	;and write as usual (if no errors).
EFA4: C9      		ret	
              	;
              	;   compute the random record number. enter with (hl) pointing
              	; to a fcb an (de) contains a relative location of a record
              	; number. on exit, (c) contains the 'r0' byte, (b) the 'r1'
              	; byte, and (a) the 'r2' byte.
              	;
              	;   on return, the zero flag is set if the record is within
              	; bounds. otherwise, an overflow occured.
              	;
EFA5: EB      	comprand: ex	de,hl		;save fcb pointer in (de).
EFA6: 19      		add	hl,de		;compute relative position of record #.
EFA7: 4E      		ld	c,(hl)		;get record number into (bc).
EFA8: 0600    		ld	b,0
EFAA: 210C00  		ld	hl,12		;now get extent.
EFAD: 19      		add	hl,de
EFAE: 7E      		ld	a,(hl)		;compute (bc)=(record #)+(extent)*128.
EFAF: 0F      		rrca			;move lower bit into bit 7.
EFB0: E680    		and	80h		;and ignore all other bits.
EFB2: 81      		add	a,c		;add to our record number.
EFB3: 4F      		ld	c,a
EFB4: 3E00    		ld	a,0		;take care of any carry.
EFB6: 88      		adc	a,b
EFB7: 47      		ld	b,a
EFB8: 7E      		ld	a,(hl)		;now get the upper bits of extent into
EFB9: 0F      		rrca			;bit positions 0-3.
EFBA: E60F    		and	0fh		;and ignore all others.
EFBC: 80      		add	a,b		;add this in to 'r1' byte.
EFBD: 47      		ld	b,a
EFBE: 210E00  		ld	hl,14		;get the 's2' byte (extra extent).
EFC1: 19      		add	hl,de
EFC2: 7E      		ld	a,(hl)
EFC3: 87      		add	a,a		;and shift it left 4 bits (bits 4-7).
EFC4: 87      		add	a,a
EFC5: 87      		add	a,a
EFC6: 87      		add	a,a
EFC7: F5      		push	af		;save carry flag (bit 0 of flag byte).
EFC8: 80      		add	a,b		;now add extra extent into 'r1'.
EFC9: 47      		ld	b,a
EFCA: F5      		push	af		;and save carry (overflow byte 'r2').
EFCB: E1      		pop	hl		;bit 0 of (l) is the overflow indicator.
EFCC: 7D      		ld	a,l
EFCD: E1      		pop	hl		;and same for first carry flag.
EFCE: B5      		or	l		;either one of these set?
EFCF: E601    		and	01h		;only check the carry flags.
EFD1: C9      		ret	
              	;
              	;   routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; this reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. this is used to compute the space used
              	; by a random file.
              	;
EFD2: 0E0C    	ransize:ld	c,12		;look thru directory for first entry with
EFD4: CD18EB  		call	findfst		;this name.
EFD7: 2A43E7  		ld	hl,(params)	;zero out the 'r0, r1, r2' bytes.
EFDA: 112100  		ld	de,33
EFDD: 19      		add	hl,de
EFDE: E5      		push	hl
EFDF: 72      		ld	(hl),d		;note that (d)=0.
EFE0: 23      		inc	hl
EFE1: 72      		ld	(hl),d
EFE2: 23      		inc	hl
EFE3: 72      		ld	(hl),d
EFE4: CDF5E9  	ransiz1:call	ckfilpos	;is there an extent to process?
EFE7: CA0CF0  		jp	z,ransiz3	;no, we are done.
EFEA: CD5EE9  		call	fcb2hl		;set (hl) pointing to proper fcb in dir.
EFED: 110F00  		ld	de,15		;point to last record in extent.
EFF0: CDA5EF  		call	comprand	;and compute random parameters.
EFF3: E1      		pop	hl
EFF4: E5      		push	hl		;now check these values against those
EFF5: 5F      		ld	e,a		;already in fcb.
EFF6: 79      		ld	a,c		;the carry flag will be set if those
EFF7: 96      		sub	(hl)		;in the fcb represent a larger size than
EFF8: 23      		inc	hl		;this extent does.
EFF9: 78      		ld	a,b
EFFA: 9E      		sbc	a,(hl)
EFFB: 23      		inc	hl
EFFC: 7B      		ld	a,e
EFFD: 9E      		sbc	a,(hl)
EFFE: DA06F0  		jp	c,ransiz2
F001: 73      		ld	(hl),e		;we found a larger (in size) extent.
F002: 2B      		dec	hl		;stuff these values into fcb.
F003: 70      		ld	(hl),b
F004: 2B      		dec	hl
F005: 71      		ld	(hl),c
F006: CD2DEB  	ransiz2:call	findnxt		;now get the next extent.
F009: C3E4EF  		jp	ransiz1		;continue til all done.
F00C: E1      	ransiz3:pop	hl		;we are done, restore the stack and
F00D: C9      		ret			;return.
              	;
              	;   function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
F00E: 2A43E7  	setran:	ld	hl,(params)	;point to fcb.
F011: 112000  		ld	de,32		;and to last used record.
F014: CDA5EF  		call	comprand	;compute random position.
F017: 212100  		ld	hl,33		;now stuff these values into fcb.
F01A: 19      		add	hl,de
F01B: 71      		ld	(hl),c		;move 'r0'.
F01C: 23      		inc	hl
F01D: 70      		ld	(hl),b		;and 'r1'.
F01E: 23      		inc	hl
F01F: 77      		ld	(hl),a		;and lastly 'r2'.
F020: C9      		ret	
              	;
              	;   this routine select the drive specified in (active) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
F021: 2AAFF1  	logindrv: ld	hl,(login)	;get the login vector.
F024: 3A42E7  		ld	a,(active)	;get the default drive.
F027: 4F      		ld	c,a
F028: CDEAE8  		call	shiftr		;position active bit for this drive
F02B: E5      		push	hl		;into bit 0.
F02C: EB      		ex	de,hl
F02D: CD59E7  		call	select		;select this drive.
F030: E1      		pop	hl
F031: CC47E7  		call	z,slcterr	;valid drive?
F034: 7D      		ld	a,l		;is this a newly activated drive?
F035: 1F      		rra	
F036: D8      		ret	c
F037: 2AAFF1  		ld	hl,(login)	;yes, update the login vector.
F03A: 4D      		ld	c,l
F03B: 44      		ld	b,h
F03C: CD0BE9  		call	setbit
F03F: 22AFF1  		ld	(login),hl	;and save.
F042: C3A3EA  		jp	bitmap		;now update the bitmap.
              	;
              	;   function to set the active disk number.
              	;
F045: 3AD6F1  	setdsk:	ld	a,(eparam)	;get parameter passed and see if this
F048: 2142E7  		ld	hl,active	;represents a change in drives.
F04B: BE      		cp	(hl)
F04C: C8      		ret	z
F04D: 77      		ld	(hl),a		;yes it does, log it in.
F04E: C321F0  		jp	logindrv
              	;
              	;   this is the 'auto disk select' routine. the firsst byte
              	; of the fcb is examined for a drive specification. if non
              	; zero then the drive will be selected and loged in.
              	;
F051: 3EFF    	autosel:ld	a,0ffh		;say 'auto-select activated'.
F053: 32DEF1  		ld	(auto),a
F056: 2A43E7  		ld	hl,(params)	;get drive specified.
F059: 7E      		ld	a,(hl)
F05A: E61F    		and	1fh		;look at lower 5 bits.
F05C: 3D      		dec	a		;adjust for (1=a, 2=b) etc.
F05D: 32D6F1  		ld	(eparam),a	;and save for the select routine.
F060: FE1E    		cp	1eh		;check for 'no change' condition.
F062: D275F0  		jp	nc,autosl1	;yes, don't change.
F065: 3A42E7  		ld	a,(active)	;we must change, save currently active
F068: 32DFF1  		ld	(olddrv),a	;drive.
F06B: 7E      		ld	a,(hl)		;and save first byte of fcb also.
F06C: 32E0F1  		ld	(autoflag),a	;this must be non-zero.
F06F: E6E0    		and	0e0h		;whats this for (bits 6,7 are used for
F071: 77      		ld	(hl),a		;something)?
F072: CD45F0  		call	setdsk		;select and log in this drive.
F075: 3A41E7  	autosl1:ld	a,(userno)	;move user number into fcb.
F078: 2A43E7  		ld	hl,(params)	;(* upper half of first byte *)
F07B: B6      		or	(hl)
F07C: 77      		ld	(hl),a
F07D: C9      		ret			;and return (all done).
              	;
              	;   function to return the current cp/m version number.
              	;
F07E: 3E22    	getver:	ld	a,022h		;version 2.2
F080: C301E7  		jp	setstat
              	;
              	;   function to reset the disk system.
              	;
F083: 210000  	rstdsk:	ld	hl,0		;clear write protect status and log
F086: 22ADF1  		ld	(wrtprt),hl	;in vector.
F089: 22AFF1  		ld	(login),hl
F08C: AF      		xor	a		;select drive 'a'.
F08D: 3242E7  		ld	(active),a
F090: 218000  		ld	hl,tbuff	;setup default dma address.
F093: 22B1F1  		ld	(userdma),hl
F096: CDDAE9  		call	defdma
F099: C321F0  		jp	logindrv	;now log in drive 'a'.
              	;
              	;   function to open a specified file.
              	;
F09C: CD72E9  	openfil:call	clears2		;clear 's2' byte.
F09F: CD51F0  		call	autosel		;select proper disk.
F0A2: C351EC  		jp	openit		;and open the file.
              	;
              	;   function to close a specified file.
              	;
F0A5: CD51F0  	closefil: call	autosel		;select proper disk.
F0A8: C3A2EC  		jp	closeit		;and close the file.
              	;
              	;   function to return the first occurence of a specified file
              	; name. if the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
F0AB: 0E00    	getfst:	ld	c,0		;prepare for special search.
F0AD: EB      		ex	de,hl
F0AE: 7E      		ld	a,(hl)		;is first byte a '?'?
F0AF: FE3F    		cp	'?'
F0B1: CAC2F0  		jp	z,getfst1	;yes, just get very first entry (zero length match).
F0B4: CDA6E8  		call	setext		;get the extension byte from fcb.
F0B7: 7E      		ld	a,(hl)		;is it '?'? if yes, then we want
F0B8: FE3F    		cp	'?'		;an entry with a specific 's2' byte.
F0BA: C472E9  		call	nz,clears2	;otherwise, look for a zero 's2' byte.
F0BD: CD51F0  		call	autosel		;select proper drive.
F0C0: 0E0F    		ld	c,15		;compare bytes 0-14 in fcb (12&13 excluded).
F0C2: CD18EB  	getfst1:call	findfst		;find an entry and then move it into
F0C5: C3E9E9  		jp	movedir		;the users dma space.
              	;
              	;   function to return the next occurence of a file name.
              	;
F0C8: 2AD9F1  	getnxt:	ld	hl,(savefcb)	;restore pointers. note that no
F0CB: 2243E7  		ld	(params),hl	;other dbos calls are allowed.
F0CE: CD51F0  		call	autosel		;no error will be returned, but the
F0D1: CD2DEB  		call	findnxt		;results will be wrong.
F0D4: C3E9E9  		jp	movedir
              	;
              	;   function to delete a file by name.
              	;
F0D7: CD51F0  	delfile:call	autosel		;select proper drive.
F0DA: CD9CEB  		call	erafile		;erase the file.
F0DD: C301EB  		jp	ststatus	;set status and return.
              	;
              	;   function to execute a sequential read of the specified
              	; record number.
              	;
F0E0: CD51F0  	readseq:call	autosel		;select proper drive then read.
F0E3: C3BCED  		jp	rdseq
              	;
              	;   function to write the net sequential record.
              	;
F0E6: CD51F0  	wrtseq:	call	autosel		;select proper drive then write.
F0E9: C3FEED  		jp	wtseq
              	;
              	;   create a file function.
              	;
F0EC: CD72E9  	fcreate:call	clears2		;clear the 's2' byte on all creates.
F0EF: CD51F0  		call	autosel		;select proper drive and get the next
F0F2: C324ED  		jp	getempty	;empty directory space.
              	;
              	;   function to rename a file.
              	;
F0F5: CD51F0  	renfile:call	autosel		;select proper drive and then switch
F0F8: CD16EC  		call	chgnames	;file names.
F0FB: C301EB  		jp	ststatus
              	;
              	;   function to return the login vector.
              	;
F0FE: 2AAFF1  	getlog:	ld	hl,(login)
F101: C329F1  		jp	getprm1
              	;
              	;   function to return the current disk assignment.
              	;
F104: 3A42E7  	getcrnt:ld	a,(active)
F107: C301E7  		jp	setstat
              	;
              	;   function to set the dma address.
              	;
F10A: EB      	putdma:	ex	de,hl
F10B: 22B1F1  		ld	(userdma),hl	;save in our space and then get to
F10E: C3DAE9  		jp	defdma		;the bios with this also.
              	;
              	;   function to return the allocation vector.
              	;
F111: 2ABFF1  	getaloc:ld	hl,(alocvect)
F114: C329F1  		jp	getprm1
              	;
              	;   function to return the read-only status vector.
              	;
F117: 2AADF1  	getrov:	ld	hl,(wrtprt)
F11A: C329F1  		jp	getprm1
              	;
              	;   function to set the file attributes (read-only, system).
              	;
F11D: CD51F0  	setattr:call	autosel		;select proper drive then save attributes.
F120: CD3BEC  		call	saveattr
F123: C301EB  		jp	ststatus
              	;
              	;   function to return the address of the disk parameter block
              	; for the current drive.
              	;
F126: 2ABBF1  	getparm:ld	hl,(diskpb)
F129: 2245E7  	getprm1:ld	(status),hl
F12C: C9      		ret	
              	;
              	;   function to get or set the user number. if (e) was (ff)
              	; then this is a request to return the current user number.
              	; else set the user number from (e).
              	;
F12D: 3AD6F1  	getuser:ld	a,(eparam)	;get parameter.
F130: FEFF    		cp	0ffh		;get user number?
F132: C23BF1  		jp	nz,setuser
F135: 3A41E7  		ld	a,(userno)	;yes, just do it.
F138: C301E7  		jp	setstat
F13B: E61F    	setuser:and	1fh		;no, we should set it instead. keep low
F13D: 3241E7  		ld	(userno),a	;bits (0-4) only.
F140: C9      		ret	
              	;
              	;   function to read a random record from a file.
              	;
F141: CD51F0  	rdrandom: call	autosel		;select proper drive and read.
F144: C393EF  		jp	readran
              	;
              	;   function to compute the file size for random files.
              	;
F147: CD51F0  	wtrandom: call	autosel		;select proper drive and write.
F14A: C39CEF  		jp	writeran
              	;
              	;   function to compute the size of a random file.
              	;
F14D: CD51F0  	filesize: call	autosel		;select proper drive and check file length
F150: C3D2EF  		jp	ransize
              	;
              	;   function #37. this allows a program to log off any drives.
              	; on entry, set (de) to contain a word with bits set for those
              	; drives that are to be logged off. the log-in vector and the
              	; write protect vector will be updated. this must be a m/pm
              	; special function.
              	;
F153: 2A43E7  	logoff:	ld	hl,(params)	;get drives to log off.
F156: 7D      		ld	a,l		;for each bit that is set, we want
F157: 2F      		cpl			;to clear that bit in (login)
F158: 5F      		ld	e,a		;and (wrtprt).
F159: 7C      		ld	a,h
F15A: 2F      		cpl	
F15B: 2AAFF1  		ld	hl,(login)	;reset the login vector.
F15E: A4      		and	h
F15F: 57      		ld	d,a
F160: 7D      		ld	a,l
F161: A3      		and	e
F162: 5F      		ld	e,a
F163: 2AADF1  		ld	hl,(wrtprt)
F166: EB      		ex	de,hl
F167: 22AFF1  		ld	(login),hl	;and save.
F16A: 7D      		ld	a,l		;now do the write protect vector.
F16B: A3      		and	e
F16C: 6F      		ld	l,a
F16D: 7C      		ld	a,h
F16E: A2      		and	d
F16F: 67      		ld	h,a
F170: 22ADF1  		ld	(wrtprt),hl	;and save. all done.
F173: C9      		ret	
              	;
              	;   get here to return to the user.
              	;
F174: 3ADEF1  	goback:	ld	a,(auto)	;was auto select activated?
F177: B7      		or	a
F178: CA91F1  		jp	z,goback1
F17B: 2A43E7  		ld	hl,(params)	;yes, but was a change made?
F17E: 3600    		ld	(hl),0		;(* reset first byte of fcb *)
F180: 3AE0F1  		ld	a,(autoflag)
F183: B7      		or	a
F184: CA91F1  		jp	z,goback1
F187: 77      		ld	(hl),a		;yes, reset first byte properly.
F188: 3ADFF1  		ld	a,(olddrv)	;and get the old drive and select it.
F18B: 32D6F1  		ld	(eparam),a
F18E: CD45F0  		call	setdsk
F191: 2A0FE7  	goback1:ld	hl,(usrstack)	;reset the users stack pointer.
F194: F9      		ld	sp,hl
F195: 2A45E7  		ld	hl,(status)	;get return status.
F198: 7D      		ld	a,l		;force version 1.4 compatability.
F199: 44      		ld	b,h
F19A: C9      		ret			;and go back to user.
              	;
              	;   function #40. this is a special entry to do random i/o.
              	; for the case where we are writing to unused disk space, this
              	; space will be zeroed out first. this must be a m/pm special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
F19B: CD51F0  	wtspecl:call	autosel		;select proper drive.
F19E: 3E02    		ld	a,2		;use special write mode.
F1A0: 32D5F1  		ld	(mode),a
F1A3: 0E00    		ld	c,0		;set write indicator.
F1A5: CD07EF  		call	positn1		;position the file.
F1A8: CC03EE  		call	z,wtseq1	;and write (if no errors).
F1AB: C9      		ret	
              	;
              	;**************************************************************
              	;*
              	;*     bdos data storage pool.
              	;*
              	;**************************************************************
              	;
F1AC: E5      	emptyfcb: defb	0e5h		;empty directory segment indicator.
F1AD: 0000    	wrtprt:	defw	0		;write protect status for all 16 drives.
F1AF: 0000    	login:	defw	0		;drive active word (1 bit per drive).
F1B1: 8000    	userdma:defw	080h		;user's dma address (defaults to 80h).
              	;
              	;   scratch areas from parameter block.
              	;
F1B3: 0000    	scratch1: defw	0		;relative position within dir segment for file (0-3).
F1B5: 0000    	scratch2: defw	0		;last selected track number.
F1B7: 0000    	scratch3: defw	0		;last selected sector number.
              	;
              	;   disk storage areas from parameter block.
              	;
F1B9: 0000    	dirbuf:	defw	0		;address of directory buffer to use.
F1BB: 0000    	diskpb:	defw	0		;contains address of disk parameter block.
F1BD: 0000    	chkvect:defw	0		;address of check vector.
F1BF: 0000    	alocvect: defw	0		;address of allocation vector (bit map).
              	;
              	;   parameter block returned from the bios.
              	;
F1C1: 0000    	sectors:defw	0		;sectors per track from bios.
F1C3: 00      	blkshft:defb	0		;block shift.
F1C4: 00      	blkmask:defb	0		;block mask.
F1C5: 00      	extmask:defb	0		;extent mask.
F1C6: 0000    	dsksize:defw	0		;disk size from bios (number of blocks-1).
F1C8: 0000    	dirsize:defw	0		;directory size.
F1CA: 0000    	alloc0:	defw	0		;storage for first bytes of bit map (dir space used).
F1CC: 0000    	alloc1:	defw	0
F1CE: 0000    	offset:	defw	0		;first usable track number.
F1D0: 0000    	xlate:	defw	0		;sector translation table address.
              	;
              	;
F1D2: 00      	closeflg: defb	0		;close flag (=0ffh is extent written ok).
F1D3: 00      	rdwrtflg: defb	0		;read/write flag (0ffh=read, 0=write).
F1D4: 00      	fndstat:defb	0		;filename found status (0=found first entry).
F1D5: 00      	mode:	defb	0		;i/o mode select (0=random, 1=sequential, 2=special random).
F1D6: 00      	eparam:	defb	0		;storage for register (e) on entry to bdos.
F1D7: 00      	relblock: defb	0		;relative position within fcb of block number written.
F1D8: 00      	counter:defb	0		;byte counter for directory name searches.
F1D9: 00000000	savefcb:defw	0,0		;save space for address of fcb (for directory searches).
F1DD: 00      	bigdisk:defb	0		;if =0 then disk is > 256 blocks long.
F1DE: 00      	auto:	defb	0		;if non-zero, then auto select activated.
F1DF: 00      	olddrv:	defb	0		;on auto select, storage for previous drive.
F1E0: 00      	autoflag: defb	0		;if non-zero, then auto select changed drives.
F1E1: 00      	savnxt:	defb	0		;storage for next record number to access.
F1E2: 00      	savext:	defb	0		;storage for extent number of file.
F1E3: 0000    	savnrec:defw	0		;storage for number of records in file.
F1E5: 0000    	blknmbr:defw	0		;block number (physical sector) used within a file or logical sect
F1E7: 0000    	logsect:defw	0		;starting logical (128 byte) sector of block (physical sector).
F1E9: 00      	fcbpos:	defb	0		;relative position within buffer for fcb of file of interest.
F1EA: 0000    	filepos:defw	0		;files position within directory (0 to max entries -1).
              	;
              	;   disk directory buffer checksum bytes. one for each of the
              	; 16 possible drives.
              	;
F1EC: 00000000	cksumtbl: defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F1F0: 00...   	
              	
F1FC: 00000000		defb	0,0,0,0
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	
              	#include "../bios.asm"
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   B O O T   R O U T I N E S
              	;*
              	;**************************************************************
              	;
              	
              	;
              	;**************************************************************
              	;*
              	;*          B I O S   J U M P   T A B L E
              	;*
              	;*    This isn't actually used by the BDOS, but
              	;*    some applications (*cough* MBASIC) use it
              	;*    to directly address BIOS calls to get around
              	;*    the BDOS.
              	;*
              	;**************************************************************
              	;
F200: C333F2  		jp	boot
F203: C346F2  	wbootin:jp	wboot	; Indirection to wboot, used by MBASIC
F206: C3A0F2  		jp	const
F209: C3ABF2  		jp	conin
F20C: C3B7F2  		jp	conout
F20F: C3C3F2  		jp	list
F212: C3C7F2  		jp	punch
F215: C3CBF2  		jp	reader
F218: C3D9F2  		jp	home
F21B: C3DEF2  		jp	seldsk
F21E: C3FCF2  		jp	settrk
F221: C300F3  		jp	setsec
F224: C304F3  		jp	setdma
F227: C30AF3  		jp	read
F22A: C30EF3  		jp	write
F22D: C312F3  		jp	prstat
F230: C315F3  		jp	sectrn
              	
              	; Cold boot entry
              	; Sets up some lower CP/M memory areas, and tells the INIT
              	; program to run on CP/M startup.
F233: 3100DC  	boot:	ld	sp,cbase
              	
              		; Run the warm boot common code
F236: CD5DF2  		call	wbootr
              		
              		; Special conditions for a cold boot
F239: CD5EF3  		call	cbinit
              	
              		; Jump to CP/M
F23C: 0E00    		ld	c,default
F23E: C300DC  		jp	cbase
              	
              	
              	; Error boot entry
              	; Kinda like warm boot, but drive is reset to default
F241: 3E00    	eboot:	ld	a,default
F243: 320400  		ld	(tdrive),a
              	
              	; Warm boot entry
              	; Mainly just calls wbootr and manages IOBYTE
F246: 3100DC  	wboot:	ld	sp,cbase
              	
              		; Save current drive + user
F249: 3A0400  		ld	a,(tdrive)
F24C: F5      		push	af
              	
              		; Save IOBYTE
F24D: 3A0300  		ld	a,(iobyte)
F250: F5      		push	af
              	
              		; Warm boot
F251: CD5DF2  		call	wbootr
              		
              		; Restore IOBYTE
F254: F1      		pop	af
F255: 320300  		ld	(iobyte),a
              		
              		; Restore tdrive and warm boot
F258: F1      		pop	af
F259: 4F      		ld	c,a
F25A: C300DC  		jp	cbase
              	
              	; Warm boot routine
              	; Sends init signal to device bus, loads CCP, and inits CP/M
              	; Does not actually jump to CP/M just yet
F25D: F3      	wbootr:	di
              		
              		; Zero out BSS
F25E: AF      		xor	a
F25F: 21C5FA  		ld	hl,_TEXT_end
F262: 77      		ld	(hl),a
F263: 11C6FA  		ld	de,_TEXT_end+1
F266: 017201  		ld	bc,_BSS_size
F269: EDB0    		ldir
              	
              		; Send init signals to all devices
F26B: 0600    		ld	b,0
F26D: C5      	wboot0:	push	bc
F26E: 216EF3  		ld	hl,bdevsw
F271: 78      		ld	a,b
F272: CD2DF3  		call	swindir
F275: AF      		xor	a
F276: 14      		inc	d
F277: CC4AF3  		call	z,callmj
F27A: C1      		pop	bc
F27B: 04      		inc	b
F27C: 3E14    		ld	a,20
F27E: B8      		cp	b
F27F: 20EC    		jr	nz,wboot0
              	
              		; Turn off batch mode
F281: 3E00    		ld	a,0
F283: 32E8DC  		ld	(batch),a
              	
              		; Load the CCP
F286: CD68F3  		call	resccp
              	
              		; Call config init
F289: CD4FF3  		call	wbinit
              		
              		; Set up lower memory
F28C: 2198F2  		ld	hl,cpmlow
F28F: 110000  		ld	de,0
F292: 010800  		ld	bc,8
F295: EDB0    		ldir
              	
              	
              		; Return
F297: C9      		ret
              	
              	
              	; This is not a true function, but a block of code to be copied
              	; to CP/M lower memory
F298: C303F2  	cpmlow:	jp	wbootin	; Call jump table version instead
F29B: 81      		defb	0x81	; Default IOBYTE
F29C: 00      		defb	0	; Default drive
F29D: C306E4  		jp	fbase	; BDOS entry 
              	
              	
              	; Console status
              	;
              	; Returns a=0xFF if there is a character
              	; uses: all
              	; Defaults to device 0 right now
F2A0: 0600    	const:	ld	b,0
F2A2: CD1EF3  		call	cdindir
F2A5: 14      		inc	d
F2A6: C0      		ret	nz
F2A7: 3C      		inc	a
F2A8: C34AF3  		jp	callmj
              		
              	; Console read
              	;
              	; Returns character in a
              	; uses: all
              	; Defaults to device 0 right now
F2AB: 0600    	conin:	ld	b,0
F2AD: CD1EF3  		call	cdindir
F2B0: 14      		inc	d
F2B1: C0      		ret	nz
F2B2: 3E02    		ld	a,2
F2B4: C34AF3  		jp	callmj
              		
              	; Console write
              	; c = Character to display
              	;
              	; uses: all
              	; Defaults to device 0 right now
F2B7: 0600    	conout:	ld	b,0
F2B9: CD1EF3  	chrout:	call	cdindir
F2BC: 14      		inc	d
F2BD: C0      		ret	nz
F2BE: 3E03    		ld	a,3
F2C0: C34AF3  		jp	callmj
              		
              	; Printer write
              	; c = Character to print
              	;
              	; uses: all
F2C3: 0606    	list:	ld	b,6
F2C5: 18F2    		jr	chrout
              	
              	; Punch (or auxiliary) write
              	; c = Character to punch
              	;
F2C7: 0604    	punch:	ld	b,4
F2C9: 18EE    		jr	chrout
              	
              	; Reader (or auxiliary) read
              	;
              	; Returns character in a, or a=0x1A
F2CB: 0602    	reader:	ld	b,2
F2CD: CD1EF3  		call	cdindir
F2D0: 14      		inc	d
F2D1: 3E1A    		ld	a,0x1A
F2D3: C0      		ret	nz
F2D4: 3E02    		ld	a,2
F2D6: C34AF3  		jp	callmj
              		
              	; Move the current drive to track 0
              	;
              	; uses: all
F2D9: 3E01    	home:	ld	a,1
F2DB: C3F6F2  		jp	callbd
              		
              	; Selects a block device
              	; c = Device to select
              	; e = Disk logging status
              	;
              	; return hl=0 if device not valid
              	; uses: all
F2DE: 79      	seldsk:	ld	a,c
F2DF: 43      		ld	b,e
F2E0: 216EF3  		ld	hl,bdevsw
F2E3: CD2DF3  		call	swindir
F2E6: 22F7F2  		ld	(callbd+1),hl
F2E9: 210000  		ld	hl,0
F2EC: 14      		inc	d
F2ED: C0      		ret	nz
F2EE: 2A4BF3  		ld	hl,(callmj+1)
F2F1: 22FAF2  		ld	(callbd+4),hl
F2F4: 3E02    		ld	a,2
              		; Pass b = logging status, c = device #
              		
              	; Small stub to jump to the currently selected block device
              	; Also records hl as argument
              	;
              	; We love self-modfiying code!
F2F6: 21      	callbd:	defb	0x21
F2F7: 0000    		defw	0
F2F9: C3      		defb	0xC3
F2FA: 0000    		defw	0
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	;
              	; uses: all
F2FC: 3E03    	settrk:	ld	a,3
F2FE: 18F6    		jr	callbd
              		
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	;
              	; uses: all
F300: 3E04    	setsec:	ld	a,4
F302: 18F2    		jr	callbd
              	
              	; Sets the DMA address of the selected block device
              	; bc = DMA address
              	;
              	; uses: all
F304: 60      	setdma:	ld	h,b
F305: 69      		ld	l,c
F306: 224DF3  		ld	(biodma),hl
F309: C9      		ret
              		
              	; Reads the configured block from the selected block device
              	;
              	; uses: all
F30A: 3E05    	read:	ld	a,5
F30C: 18E8    		jr	callbd
              	
              	; Writes the configured block to the selected block device
              	; c = Deferred mode
              	;
              	; uses: all
F30E: 3E06    	write:	ld	a,6
F310: 18E4    		jr	callbd
              		
              	; "Printer" is always read for bytes
              	; Maybe in the future we will implement this, but for now
              	; this will do.
              	;
              	; Returns a=0xFF
F312: 3EFF    	prstat:	ld	a,0xFF
F314: C9      		ret
              		
              	; Provides sector translation
              	; Returns no translation for all devices
F315: 60      	sectrn:	ld	h,b
F316: 69      		ld	l,c
F317: C9      		ret
              		
              	
              	; BDOS -> BIOS system hook
              	; stubs some stuff out, and then jumps to the config system hook
F318: 32DEF1  	bshook:	ld	(auto),a
F31B: C367F3  		jp	syshook
              		
              	; Character device switch indirection
              	; Obtains device by doing IOBYTE indirection
              	; Sets hl to cdevsw and jumps to swindir
F31E: 04      	cdindir:inc	b
F31F: 3A0300  		ld	a,(iobyte)
F322: 05      	cdindi0:dec	b
F323: 2803    		jr	z,cdindi1
F325: 1F      		rra
F326: 18FA    		jr	cdindi0
F328: E603    	cdindi1:and	0x03
F32A: 21AEF3  		ld	hl,cdevsw
              	
              	; Switch indirect helper function
              	; a = Device
              	; hl = Start of switch
              	;
              	; returns d=255 if device found, hl as argument
              	; uses: af, de, hl
F32D: 110400  	swindir:ld	de,4
F330: B7      		or	a
F331: 2804    	swindi0:jr	z,swindi1
F333: 19      		add	hl,de
F334: 3D      		dec	a
F335: 18FA    		jr	swindi0
F337: 7E      	swindi1:ld	a,(hl)
F338: 324BF3  		ld	(callmj+1),a
F33B: 23      		inc	hl
F33C: B6      		or	(hl)
F33D: C8      		ret	z
F33E: 7E      		ld	a,(hl)
F33F: 324CF3  		ld	(callmj+2),a
F342: 23      		inc	hl
F343: 7E      		ld	a,(hl)
F344: 23      		inc	hl
F345: 66      		ld	h,(hl)
F346: 6F      		ld	l,a
F347: 16FF    		ld	d,255
F349: C9      	nulldev:ret		; Just points to a return
              	
              	; Small stub to jump to the memory jump register
F34A: C3      	callmj: defb	0xC3
F34B: 0000    		defw	0
              	
              	
              	
              	; Variables
F34D: 0000    	biodma:	defw	0	; Block device DMA address
              	
              	;
              	;**************************************************************
              	;*
              	;*        W A R M   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function is called at the end of a warm boot
              	;*    to set up hardware-specific stuff.
              	;*
              	;**************************************************************
              	;
              	
F34F: 3E01    	wbinit:	ld	a,0x01		; Bank out ROM
F351: D300    		out	(0x00),a
              	
              		; Turn on batch mode
F353: 3EFF    		ld	a,0xFF
F355: 32E8DC  		ld	(batch),a
              		
              		; Also set interrupt mode 2 stuff
F358: ED47    		ld	i,a
F35A: ED5E    		im	2		; Start interrupts
F35C: FB      		ei
              		
F35D: C9      		ret
              		
              	;
              	;**************************************************************
              	;*
              	;*        C O L D   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function will run once during the intial cold
              	;*    boot. It is the last task to run before control is
              	;*    given to the CCP. This function is run after wbinit
              	;*
              	;**************************************************************
              	;
              	
F35E: 3E06    	cbinit:	ld	a,6	; Enable INIT to run
F360: 3207DC  		ld	(inbuff+1),a
F363: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*            I N T E R R U P T   H A N D L I N G
              	;*
              	;*     This function will be called in order to handle an
              	;*     interrupt if the need arises. Hooking drivers up to
              	;*     this code may be a little bit more involved.
              	;*
              	;**************************************************************
              	;
              	
F364: FB      	cfirq:	ei
F365: ED4D    		reti
              	
              	;
              	;**************************************************************
              	;*
              	;*              B D O S   C A L L   H O O K
              	;*
              	;*     This function is called everytime a BDOS call occurs.
              	;*     It can be used by specialized drivers to either inject
              	;*     new BDOS calls, or intercept existing ones.
              	;*
              	;*     Registers 'bc' and 'e' must be preserved if a call is
              	;*     going to be forwarded to the system. Register 'c' will
              	;*     contain BDOS call number.
              	;*       
              	;*
              	;**************************************************************
              	;
              	
F367: C9      	syshook:ret
              	
              	
              	;**************************************************************
              	;*
              	;*           B L O C K   D E V I C E   S W I T C H
              	;*
              	;*       IshkurCP/M can support up to 16 logical disks
              	;*       A single driver can be mapped to a number of
              	;*       these disks. Each logical disk is defined by a
              	;*       4-byte record. The first 2 bytes are a pointer
              	;*       to the device entry, and the last 2 are passed
              	;*       as an argument to the device. Usually this 
              	;*       takes the form of a minor number for indexing
              	;*       sub-disks on the same driver
              	;*
              	;*
              	;**************************************************************
              	;
              		
              	; One of the block devices needs to have the responsibiliy
              	; of loading the CCP into memory. Define the jump vector here
F368: C33FF8  	resccp:	jp	nd_ccp
              	
              	; Additionally, if Ishkur is using a graphical device, that
              	; device may temporarily need to access the Graphical Resource
              	; Block (GRB) to load in fonts and such. This is up to 2k in
              	; size, and goes in the location that the CCP resides
F36B: C344F8  	resgrb:	jp	nd_grb
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
F36E: 7DF70000	bdevsw:	defw	ndkdev,	0	; 'A'
F372: 7DF70100		defw	ndkdev,	1	; 'B'
F376: 00000000		defw	0,	0	; 'C'
F37A: 00000000		defw	0,	0	; 'D'
F37E: 00000000		defw	0,	0	; 'E'
F382: 00000000		defw	0,	0	; 'F'
F386: 00000000		defw	0,	0	; 'G'
F38A: 00000000		defw	0,	0	; 'H'
F38E: 00000000		defw	0,	0	; 'I'
F392: 00000000		defw	0,	0	; 'J'
F396: 00000000		defw	0,	0	; 'K'
F39A: 00000000		defw	0,	0	; 'L'
F39E: 00000000		defw	0,	0	; 'M'
F3A2: 00000000		defw	0,	0	; 'N'
F3A6: 00000000		defw	0,	0	; 'O'
F3AA: 00000000		defw	0,	0	; 'P'
              	
              	;
              	; Character device switch MUST come directly after in memory!
              	;
              	;**************************************************************
              	;*
              	;*        C H A R A C T E R   D E V I C E   S W I T C H
              	;*
              	;*      Currently, 4 character devices are supported. These
              	;*      devices are the console, the printer, and two "punches"
              	;*      (can be thought of as an auxillary serial device).
              	;*      All character devices use the same interface, which
              	;*      allows for easy indireciton. 
              	;*
              	;*	Device switch logic works about the same of the block
              	;*	devices.
              	;*
              	;**************************************************************
              	;
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
F3AE: 37FA0000	cdevsw:	defw	siodev,	0	; TTY device
F3B2: BEF30000		defw	vdpdev,	0	; Console device
F3B6: 0DFA0000		defw	prtdev,	0	; Aux I/O device #1 (LPT)
F3BA: 00000000		defw	0,	0	; Aux I/O device #2 (GEN)
              	
              	;
              	;**************************************************************
              	;*
              	;*        D E V I C E   D R I V E R   I N C L U D E S
              	;*
              	;**************************************************************
              	;
              	
              	#include "../dev/nabu_vdp.asm"
              	;
              	;**************************************************************
              	;*
              	;*      T M S 9 9 1 8   C H A R A C T E R   D E V I C E
              	;*
              	;*      This device emulated a VT52 terminal using the
              	;*      TMS9918A graphics chip. The 2kb font record is
              	;*      not resident is memory, and must be provided by
              	;*      a compatable block I/O device.
              	;*
              	;*      F18A style 80 column mode is supported
              	;*
              	;*      This specific version uses the NABU keyboard as
              	;*      an input to the emulated termina 
              	;*
              	;*      Device requires 48 bytes of bss space (tm_bss)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
FAC5: 00      	tm_outc:defs	1	; Output character
FAC6: 00      	tm_scro:defs	1	; Scroll width
FAC7: 00      	tm_escs:defs	1	; Escape state
FAC8: 00      	tm_last:defs	1	; Last character read
FAC9: 00000000	tm_cbuf:defs	40	; 40 byte character buffer
FACD: 00...   	
              	.area	_TEXT
              	
              	; TMS9918 Configuration
00A0:         	tm_data	equ	0xA0	; TMS9918 data register (mode=0)
00A1:         	tm_latc	equ	0xA1	; TMS9918 latch register (mode=1)
              	
0090:         	tm_keyd	equ	0x90	; Keyboard data register
0091:         	tm_keys	equ	0x91	; Keyboard status register
              	
0040:         	tm_ayda	equ	0x40	; AY-3-8910 data port
0041:         	tm_atla	equ	0x41	; AY-3-8910 latch port
              	
              	; --- VRAM MAP ---
              	; 0x0000 - 0x07FF: Font
              	; 0x0800 - 0x0BFF: 40 column screen buffer
              	; 0x0C00 - 0x0FFF: Unused
              	; 0x1000 - 0x17FF: 80 column screen buffer
              	;
              	; Serial #
              	; 0x17FE: 0xE5
              	; 0x17FF: 0x81
              	
              	
              	; Driver jump table
F3BE: B7      	vdpdev:	or	a
F3BF: 2845    		jr	z,tm_init
F3C1: 3D      		dec	a
F3C2: 2819    		jr	z,tm_stat
F3C4: 3D      		dec	a
F3C5: CAA8F4  		jp	z,tm_read
F3C8: C306F5  		jp	tm_writ
              	
              	; A slower version of the OTIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
F3CB: F5      	tm_otir:push	af
F3CC: 7E      	tm_oti0:ld	a,(hl)
F3CD: ED79    		out	(c),a
F3CF: 23      		inc	hl
F3D0: 10FA    		djnz	tm_oti0
F3D2: F1      		pop	af
F3D3: C9      		ret
              		
              	; A slower version of the INIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
F3D4: F5      	tm_inir:push	af
F3D5: ED78    	tm_inr0:in	a,(c)
F3D7: 77      		ld	(hl),a
F3D8: 23      		inc	hl
F3D9: 10FA    		djnz	tm_inr0
F3DB: F1      		pop	af
F3DC: C9      		ret
              	
              	
              	; Gets the status of the keyboard
              	;
              	; Returns a=0xFF if there is a key to read 
              	; uses: af, bc, de, hl
F3DD: CD2BF7  	tm_stat:call	tm_dint
F3E0: CDE9F3  		call	tm_sta0
F3E3: F5      		push	af
F3E4: CD3BF7  		call	tm_eint
F3E7: F1      		pop	af
F3E8: C9      		ret 
F3E9: 3AC8FA  	tm_sta0:ld	a,(tm_last)
F3EC: FEE4    		cp	0xE4
F3EE: 2871    		jr	z,tm_scri
F3F0: FEE5    		cp	0xE5
F3F2: 287F    		jr	z,tm_sclf
F3F4: 3AC5FA  	tm_sta1:ld	a,(tm_outc)
F3F7: 3C      		inc	a
F3F8: 3EFF    		ld	a,0xFF
F3FA: C0      		ret	nz
F3FB: CD3AF6  		call	tm_getc
F3FE: 32C5FA  		ld	(tm_outc),a
F401: 3C      		inc	a
F402: C8      		ret	z
F403: 3EFF    		ld	a,0xFF
F405: C9      		ret
              	
              	; TMS9918 init
              	; Load font record, set up terminal
F406: CD6BF3  	tm_init:call	resgrb
              	
              		; Set up registers
F409: CD7DF4  		call	tm_setp
              		
              		; Set up interrupt vectors (if needed)
F40C: 2125F7  		ld	hl,tm_virq
F40F: 2206FF  		ld	(intvec+6),hl
F412: 2158F6  		ld	hl,tm_kirq
F415: 2204FF  		ld	(intvec+4),hl
              		
              		; Set TMS pattern generator block to 0
F418: DBA1    		in	a,(tm_latc)
F41A: AF      		xor	a
F41B: D3A1    		out	(tm_latc),a
F41D: 3E84    		ld	a,0x84
F41F: D3A1    		out	(tm_latc),a
              		
              		; Write the GRB
F421: 010040  		ld	bc,0x4000
F424: CD1AF7  		call	tm_addr
F427: 2100DC  		ld	hl,cbase
F42A: 0EA0    		ld	c,tm_data
F42C: 3E08    		ld	a,8	; Transfer 8*256 = 2048
F42E: 0600    	tm_ini0:ld	b,0
F430: CDCBF3  		call	tm_otir
F433: 3D      		dec	a
F434: 20F8    		jr	nz,tm_ini0
              		
              		; Cold boot?
F436: 3A4DF7  		ld	a,(tm_cold)
F439: B7      		or	a
F43A: 2012    		jr	nz,tm_ini1
              		
              		; Check serial #
F43C: 01FE17  		ld	bc,0x17FE
F43F: CD1AF7  		call	tm_addr
F442: ED78    		in	a,(c)
F444: FEE5    		cp	0xE5
F446: 2006    		jr	nz,tm_ini1
F448: ED78    		in	a,(c)
F44A: FE81    		cp	0x81
F44C: 280D    		jr	z,tm_cloc
              		
              		; Reset the terminal
F44E: CDFDF6  	tm_ini1:call	tm_cls
F451: AF      		xor	a
F452: 324BF7  		ld	(tm_curx),a
F455: 324CF7  		ld	(tm_cury),a
F458: 324DF7  		ld	(tm_cold),a
              		
              		; Fall to tm_cloc
              		
              	; Clear the output character
              	;
              	; uses: af
F45B: 3EFF    	tm_cloc:ld	a,0xFF
F45D: 32C5FA  		ld	(tm_outc),a
              	
F460: C9      		ret
              		
              	; Scroll left / scroll right
              	;
              	; uses: af, bc, de, hl
F461: 3AC6FA  	tm_scri:ld	a,(tm_scro)
F464: B7      		or	a
F465: FE28    		cp	40
F467: 2808    		jr	z,tm_scr1
F469: C604    		add	a,4
F46B: 32C6FA  	tm_scr0:ld	(tm_scro),a
F46E: CDDAF6  		call	tm_usco
F471: 1881    	tm_scr1:jr	tm_sta1
F473: 3AC6FA  	tm_sclf:ld	a,(tm_scro)
F476: B7      		or	a
F477: 28F8    		jr	z,tm_scr1
F479: D604    		sub	4
F47B: 18EE    		jr	tm_scr0
              	
              	; Sets up registers depending on mode
              	; used to change between 40-col and 80-col
              	;
              	; uses: af, hl
F47D: 2A46F7  	tm_setp:ld	hl,(tm_mode)
              	
              		; Set TMS to text mode
F480: DBA1    		in	a,(tm_latc)
F482: 7C      		ld	a,h
F483: D3A1    		out	(tm_latc),a
F485: 3E80    		ld	a,0x80
F487: D3A1    		out	(tm_latc),a
F489: DBA1    		in	a,(tm_latc)
F48B: 3EF0    		ld	a,0xF0
F48D: D3A1    		out	(tm_latc),a
F48F: 3E81    		ld	a,0x81
F491: D3A1    		out	(tm_latc),a
              		
              		; Set TMS color
F493: DBA1    		in	a,(tm_latc)
F495: 3A48F7  		ld	a,(tm_colr)
F498: D3A1    		out	(tm_latc),a
F49A: 3E87    		ld	a,0x87
F49C: D3A1    		out	(tm_latc),a
              		
              		; Set TMS name table to 0x0800
F49E: DBA1    		in	a,(tm_latc)
F4A0: 7D      		ld	a,l
F4A1: D3A1    		out	(tm_latc),a
F4A3: 3E82    		ld	a,0x82
F4A5: D3A1    		out	(tm_latc),a
F4A7: C9      		ret
              	
              	; Waits for the user to press a key, and returns it
              	;
              	; Returns ASCII key in A
              	; uses: af, bc, de, hl
F4A8: CD2BF7  	tm_read:call	tm_dint
F4AB: CDB4F4  		call	tm_rea0
F4AE: F5      		push	af
F4AF: CD3BF7  		call	tm_eint
F4B2: F1      		pop	af
F4B3: C9      		ret 
F4B4: 3A4BF7  	tm_rea0:ld	a,(tm_curx)
F4B7: 4F      		ld	c,a
F4B8: 3A4CF7  		ld	a,(tm_cury)
F4BB: 57      		ld	d,a
F4BC: 210010  		ld	hl,0x1000
F4BF: 3E50    		ld	a,80
F4C1: CDB6F6  		call	tm_chat
F4C4: DBA0    		in	a,(tm_data)	; char is in A
F4C6: 57      		ld	d,a		; char key
F4C7: 5F      		ld	e,a		; blinking char
F4C8: 0601    		ld	b,1
              		
F4CA: D5      	tm_rea1:push	de
F4CB: CDE9F3  		call	tm_sta0		; No interrupts!
F4CE: D1      		pop	de
F4CF: 3C      		inc	a
F4D0: 200D    		jr	nz,tm_rea2
F4D2: 5A      		ld	e,d
F4D3: CDEFF4  		call	tm_rea3
F4D6: 3AC5FA  		ld	a,(tm_outc)
F4D9: 47      		ld	b,a
F4DA: CD5BF4  		call	tm_cloc
F4DD: 78      		ld	a,b
F4DE: C9      		ret
              		
F4DF: CDFDF4  	tm_rea2:call	tm_stal
F4E2: 10E6    		djnz	tm_rea1
F4E4: 3E80    		ld	a,0x80
F4E6: AB      		xor	e
F4E7: 5F      		ld	e,a
F4E8: CDEFF4  		call	tm_rea3
F4EB: 06BE    		ld	b,190
F4ED: 18DB    		jr	tm_rea1
              	
              	
F4EF: D5      	tm_rea3:push	de
F4F0: 3A4BF7  		ld	a,(tm_curx)
F4F3: 4F      		ld	c,a
F4F4: 3A4CF7  		ld	a,(tm_cury)
F4F7: 57      		ld	d,a
F4F8: CD92F6  		call	tm_putc
F4FB: D1      		pop	de
F4FC: C9      		ret
              	
              	; Stalls out for a little bit
              	;
              	; uses: none
F4FD: C5      	tm_stal:push	bc
F4FE: 06FF    		ld	b,255
F500: C5      	tm_sta2:push	bc
F501: C1      		pop	bc
F502: 10FC    		djnz	tm_sta2
F504: C1      		pop	bc
F505: C9      		ret
              	
              	
              	; Writes a character to the screen
              	; c = Character to write
              	;
              	; Returns c,b as next position 
              	; uses: af, bc, de, hl
F506: CD2BF7  	tm_writ:call	tm_dint
F509: 59      		ld	e,c
F50A: 3A4BF7  		ld	a,(tm_curx)
F50D: 4F      		ld	c,a
F50E: 3A4CF7  		ld	a,(tm_cury)
F511: 57      		ld	d,a
F512: CD21F5  		call	tm_wri0
F515: 78      		ld	a,b
F516: 324CF7  		ld	(tm_cury),a
F519: 79      		ld	a,c
F51A: 324BF7  		ld	(tm_curx),a
F51D: CD3BF7  		call	tm_eint
F520: C9      		ret
              		
              	; Write helper routine
              	; c = X position
              	; d = Y position
              	; e = Character
              	;
              	; Returns c,b as next position
F521: 42      	tm_wri0:ld	b,d		; c = X, b = Y
F522: 3AC7FA  		ld	a,(tm_escs)
F525: B7      		or	a		; Process escape code
F526: C28EF5  		jp	nz,tm_esc
F529: 3E1F    		ld	a,0x1F
F52B: BB      		cp	e
F52C: D260F5  		jp	nc,tm_wri1	; Process control code
F52F: C5      		push	bc
F530: CD92F6  		call	tm_putc		; Write character
F533: C1      		pop	bc
              		
              		; Increment character
F534: 0C      	tm_ri	inc	c
F535: 3E50    		ld	a,80
F537: B9      		cp	c
F538: C0      		ret	nz
F539: AF      		xor	a
F53A: 4F      		ld	c,a
F53B: 04      	tm_lf:  inc	b	; Line feed
F53C: 3E18    		ld	a,24
F53E: B8      		cp	b
F53F: C0      		ret	nz
F540: C5      		push	bc
F541: CD14F6  		call	tm_dsco
F544: C1      		pop	bc
F545: 05      		dec	b
F546: C9      		ret
F547: AF      	tm_cr:	xor	a	; Carriage return
F548: 4F      		ld	c,a
F549: C9      		ret
F54A: 0D      	tm_bs:	dec	c	; Backspace 
F54B: F0      		ret	p
F54C: 0E4F    		ld	c,79
F54E: 05      		dec	b
F54F: F0      		ret	p
F550: AF      		xor	a
F551: 47      		ld	b,a
F552: 4F      		ld	c,a
F553: C9      		ret
F554: AF      	tm_up:	xor	a	; Move up
F555: B8      		cp	b
F556: C8      		ret	z
F557: 05      		dec	b
F558: C9      		ret
F559: CDFDF6  	tm_cshm:call	tm_cls
F55C: AF      	tm_home:xor	a
F55D: 47      		ld	b,a
F55E: 4F      		ld	c,a
F55F: C9      		ret
              	
F560: 7B      	tm_wri1:ld	a,e
F561: FE08    		cp	0x08	; '\b' (Cursor left)
F563: 28E5    		jr	z,tm_bs
F565: FE12    		cp	0x12	; Cursor right
F567: 28CB    		jr	z,tm_ri
F569: FE0A    		cp	0x0A	; '\n' (Cursor down)
F56B: 28CE    		jr	z,tm_lf
F56D: FE0B    		cp	0x0B	; Cursor up
F56F: 28E3    		jr	z,tm_up
F571: FE0D    		cp	0x0D	; '\r' 
F573: 28D2    		jr	z,tm_cr
F575: FE17    		cp	0x17	; Clear end of screen
F577: 2856    		jr	z,tm_cles
F579: FE18    		cp	0x18	; Clear end of line
F57B: 2854    		jr	z,tm_clea
F57D: FE1A    		cp	0x1A	; Clear screen, home cursor
F57F: 28D8    		jr	z,tm_cshm
F581: FE1E    		cp	0x1E	; Home cursor
F583: 28D7    		jr	z,tm_home
F585: FE1B    		cp	0x1B	; Escape
F587: C0      		ret	nz
F588: 3E01    		ld	a,1
F58A: 32C7FA  		ld	(tm_escs),a
F58D: C9      		ret
              		
              		; Handle escape sequence
F58E: 3D      	tm_esc:	dec	a
F58F: 280E    		jr	z,tm_esc0
F591: 3D      		dec	a
F592: 2825    		jr	z,tm_esc1
F594: 3D      		dec	a
F595: 282D    		jr	z,tm_esc2
F597: 3D      		dec	a
F598: 2871    		jr	z,tm_updc
F59A: AF      	tm_escd:xor	a	; Escape done
F59B: 32C7FA  	tm_escr:ld	(tm_escs),a
F59E: C9      		ret
F59F: 3EFF    	tm_esc0:ld	a,0xFF	; Do 40-col
F5A1: BB      		cp	e
F5A2: 2850    		jr	z,tm_40c
F5A4: 3EFE    		ld	a,0xFE	; Do 80-col
F5A6: BB      		cp	e
F5A7: 2858    		jr	z,tm_80c
F5A9: 3EFD    		ld	a,0xFD	; Set color
F5AB: BB      		cp	e
F5AC: 2859    		jr	z,tm_scol
F5AE: 3E3D    		ld	a,0x3D	; '='
F5B0: BB      		cp	e
F5B1: 20E7    		jr	nz,tm_escd
F5B3: 3AC7FA  	tm_esci:ld	a,(tm_escs)
F5B6: 3C      		inc	a
F5B7: 18E2    		jr	tm_escr
F5B9: 7B      	tm_esc1:ld	a,e
F5BA: 1E20    		ld	e,0x20
F5BC: 93      		sub	e
F5BD: FE18    		cp	24
F5BF: 30D9    		jr	nc,tm_escd
F5C1: 47      		ld	b,a
F5C2: 18EF    		jr	tm_esci
F5C4: 7B      	tm_esc2:ld	a,e
F5C5: 1E20    		ld	e,0x20
F5C7: 93      		sub	e
F5C8: FE50    		cp	80
F5CA: 30CE    		jr	nc,tm_escd
F5CC: 4F      		ld	c,a
F5CD: 18CB    		jr	tm_escd
              		
              		; Clear segment
              		; B = ending line
F5CF: 0617    	tm_cles:ld	b,23
F5D1: 04      	tm_clea:inc	b
F5D2: 1E00    		ld	e,0
F5D4: C5      		push	bc
F5D5: D5      		push	de
F5D6: 3E50    		ld	a,80
F5D8: 210050  		ld	hl,0x5000
F5DB: CDB6F6  		call	tm_chat
F5DE: D1      		pop	de
F5DF: C1      		pop	bc
F5E0: AF      	tm_cle0:xor	a
F5E1: D3A0    		out	(tm_data),a
F5E3: 0C      		inc	c
F5E4: 3E50    		ld	a,80
F5E6: B9      		cp	c
F5E7: 20F7    		jr	nz,tm_cle0
F5E9: 14      		inc	d
F5EA: AF      		xor	a
F5EB: 4F      		ld	c,a
F5EC: 7A      		ld	a,d
F5ED: B8      		cp	b
F5EE: 20F0    		jr	nz,tm_cle0
F5F0: D1      		pop	de	; Do not update character
F5F1: C3DAF6  		jp	tm_usco
              		
F5F4: E5      	tm_40c:	push	hl
F5F5: 210200  		ld	hl,0x0002
F5F8: 2246F7  	tm_cupd:ld	(tm_mode),hl
F5FB: CD7DF4  		call	tm_setp
F5FE: E1      		pop	hl
F5FF: 1899    		jr	tm_escd
              		
F601: E5      	tm_80c:	push	hl
F602: 210704  		ld	hl,0x0407
F605: 18F1    		jr	tm_cupd
              		
              		; Set color command
F607: 3E04    	tm_scol:ld	a,4
F609: 1890    		jr	tm_escr
              		
              		; Update color here
F60B: 7B      	tm_updc:ld	a,e
F60C: 3248F7  		ld	(tm_colr),a
F60F: CD7DF4  		call	tm_setp
F612: 1886    		jr	tm_escd
              		
              		
              		
              	; Scroll both frame buffers down one
              	;
              	; uses: af, bc, de, hl
F614: 212808  	tm_dsco:ld	hl,0x0800+40
F617: 110048  		ld	de,0x4800
F61A: 0618    		ld	b,24
F61C: CD27F6  		call	tm_dsc0
F61F: 215010  		ld	hl,0x1000+80
F622: 110050  		ld	de,0x5000
F625: 0630    		ld	b,48
F627: C5      	tm_dsc0:push	bc
F628: D5      		push	de
F629: E5      		push	hl
F62A: CDC2F6  		call	tm_vcpy
F62D: E1      		pop	hl
F62E: D1      		pop	de
F62F: 012800  		ld	bc,40
F632: 09      		add	hl,bc
F633: EB      		ex	de,hl
F634: 09      		add	hl,bc
F635: EB      		ex	de,hl
F636: C1      		pop	bc
F637: 10EE    		djnz	tm_dsc0
F639: C9      		ret
              		
              	
              	; Grabs the latest key pressed by the keyboard
              	; Discard keyboard errors
              	; Returns key in A, or 0xFF if none
              	;
              	; uses: af, bc, de, hl
F63A: 3A4AF7  	tm_getc:ld	a,(tm_inf)
F63D: B7      		or	a
F63E: 3E00    		ld	a,0
F640: 324AF7  		ld	(tm_inf),a
F643: 3A49F7  		ld	a,(tm_inb)
F646: 2008    		jr	nz,tm_get0
              	
F648: DB91    		in	a,(tm_keys)
F64A: E602    		and	2
F64C: 3D      		dec	a
F64D: F8      		ret	m
              		
              		; Grab the key
F64E: DB90    		in	a,(tm_keyd)
F650: 32C8FA  	tm_get0:ld	(tm_last),a
F653: CD66F6  		call	tm_map
F656: 79      		ld	a,c
F657: C9      		ret
              		
              	; Handles a keyboard interrupt for the VDP terminal driver
              	; Keypress stored in tm_inb and tm_inf flag is set
              	; 
              	; uses: none
F658: F5      	tm_kirq:push	af
F659: DB90    		in	a,(tm_keyd)
F65B: 3249F7  		ld	(tm_inb),a
F65E: 3E01    		ld	a,1
F660: 324AF7  		ld	(tm_inf),a
F663: F1      		pop	af
F664: FB      		ei
F665: C9      		ret
              		
              		
              	; Maps keyboard input to ASCII
              	; a = Key to map
              	;
              	; Returns mapped key in c
              	; uses: af, c
F666: 4F      	tm_map:	ld	c,a
              		
              		; Mapping function
F667: 217DF6  		ld	hl,tm_mapt
F66A: 7E      	tm_map0:ld	a,(hl)
F66B: B7      		or	a
F66C: 2808    		jr	z,tm_map2
F66E: B9      		cp	c
F66F: 23      		inc	hl
F670: 7E      		ld	a,(hl)
F671: 23      		inc	hl
F672: 20F6    		jr	nz,tm_map0
F674: 4F      		ld	c,a
F675: C9      		ret
              		
              		
              		; Filter non-ASCII
F676: 79      	tm_map2:ld	a,c
F677: E680    		and	0x80	
F679: C8      		ret	z
F67A: 0EFF    		ld	c,0xFF
F67C: C9      		ret
              		
              	; Map table
F67D: 7F08    	tm_mapt:defb	0x7F,0x08	; DEL -> BS
F67F: E108    		defb	0xE1,0x08	; '<-' -> BS
F681: EA7F    		defb	0xEA,0x7F	; TV -> DEL
F683: E00C    		defb	0xE0,0x0C	; '->' -> Right
F685: E20B    		defb	0xE2,0x0B	; '/\' -> Up
F687: E30A    		defb	0xE3,0x0A	; '\/' -> Linefeed 
F689: E95C    		defb	0xE9,0x5C	; PAUSE -> '\'
F68B: E860    		defb	0xE8,0x60	; SYM -> '@'
F68D: E67C    		defb	0xE6,0x7C	; NO -> '|'
F68F: E77E    		defb	0xE7,0x7E	; YES -> '~'
F691: 00      		defb	0
              	
              	; Puts a character on the screen
              	; c = X position
              	; d = Y position
              	; e = Character to put
              	;
              	; uses: af, bc, de, hl
F692: 210050  	tm_putc:ld	hl,0x5000
F695: 3E50    		ld	a,80
F697: C5      		push	bc
F698: D5      		push	de
F699: CDB6F6  		call	tm_chat	; Place it in the 80 col buffer
F69C: ED59    		out	(c),e
F69E: D1      		pop	de
F69F: C1      		pop	bc
F6A0: 3AC6FA  	tm_putf:ld	a,(tm_scro)	; Place into frame buffer
F6A3: 47      		ld	b,a
F6A4: 79      		ld	a,c
F6A5: 90      		sub	b	; If character is less than scroll...
F6A6: 4F      		ld	c,a
F6A7: F8      		ret	m
F6A8: FE28    		cp	40	; If desired position is 40 or more
F6AA: D0      		ret	nc
F6AB: 210048  		ld	hl,0x4800
F6AE: 3E28    		ld	a,40
F6B0: CDB6F6  		call	tm_chat	; Place it in the 40 col screen buffer
F6B3: ED59    		out	(c),e
F6B5: C9      		ret
              	
              	; Sets the TMS address to a character at x,y
              	; a = Line width
              	; c = X position
              	; d = Y position
              	; hl = Buffer address
              	;
              	; uses: af, bc, d, hl
F6B6: 0600    	tm_chat:ld	b,0
F6B8: 09      		add	hl,bc
F6B9: 4F      		ld	c,a
F6BA: AF      		xor	a
F6BB: BA      		cp	d
F6BC: 285A    	tm_cha0:jr	z,tm_addh
F6BE: 09      		add	hl,bc
F6BF: 15      		dec	d
F6C0: 18FA    		jr	tm_cha0
              	
              	; Copies VRAM from one location to another
              	; Transfers occur in blocks of 40 bytes
              	; de = destination address
              	; hl = source location
              	;
              	; b = 0 on return
              	; uses: af, bc, de, hl
F6C2: CD18F7  	tm_vcpy:call	tm_addh
F6C5: 0628    		ld	b,40
F6C7: 21C9FA  		ld	hl,tm_cbuf
F6CA: CDD4F3  		call	tm_inir
F6CD: EB      		ex	de,hl
F6CE: CD18F7  		call	tm_addh
F6D1: 0628    		ld	b,40
F6D3: 21C9FA  		ld	hl,tm_cbuf
F6D6: CDCBF3  		call	tm_otir
F6D9: C9      		ret
              		
              	; Updates the frame buffer based on the scroll position
              	;
              	; uses: af, bc, de, hl
F6DA: 210010  	tm_usco:ld	hl,0x1000
F6DD: 110048  		ld	de,0x4800
F6E0: 3AC6FA  		ld	a,(tm_scro)
F6E3: 0600    		ld	b,0
F6E5: 4F      		ld	c,a
F6E6: 09      		add	hl,bc
F6E7: 0618    		ld	b,24
F6E9: C5      	tm_usc0:push	bc
F6EA: D5      		push	de
F6EB: E5      		push	hl
F6EC: CDC2F6  		call	tm_vcpy
F6EF: E1      		pop	hl
F6F0: D1      		pop	de
F6F1: 0E50    		ld	c,80
F6F3: 09      		add	hl,bc
F6F4: EB      		ex	de,hl
F6F5: 0E28    		ld	c,40
F6F7: 09      		add	hl,bc
F6F8: EB      		ex	de,hl
F6F9: C1      		pop	bc
F6FA: 10ED    		djnz	tm_usc0
F6FC: C9      		ret
              		
              	
              	; Clears out screen buffer and offscreen buffer
              	; Also includes clear limited function
              	;
              	; uses: af, bc, de
F6FD: 010048  	tm_cls:	ld	bc,0x4800
F700: 11FE0F  		ld	de,0x1000-2
F703: CD1AF7  		call	tm_addr
F706: ED71    	tm_cls0:out	(c),0
F708: 1B      		dec	de
F709: 7A      		ld	a,d
F70A: B3      		or	e
F70B: 20F9    		jr	nz,tm_cls0
              		
              		; Write super special serial #
F70D: 3EE5    		ld	a,0xE5
F70F: ED79    		out	(c),a
F711: F5      		push	af
F712: F1      		pop	af
F713: 3E81    		ld	a,0x81
F715: ED79    		out	(c),a
F717: C9      		ret
              	
              	; Sets the TMS address for either reading or writing
              	; bc = Address 
              	;
              	; Returns tm_data in c
              	; uses: af, bc
F718: 44      	tm_addh:ld	b,h		; Does HL instead of BC
F719: 4D      		ld	c,l
F71A: DBA1    	tm_addr:in	a,(tm_latc)
F71C: 79      		ld	a,c
F71D: D3A1    		out	(tm_latc),a
F71F: 78      		ld	a,b
F720: D3A1    		out	(tm_latc),a
F722: 0EA0    		ld	c,tm_data
F724: C9      		ret
              		
              	; Handles a TMS9918 irq
F725: F5      	tm_virq:push	af
F726: DBA1    		in	a,(tm_latc)
F728: F1      		pop	af
F729: FB      		ei
F72A: C9      		ret
              		
              		
              	; Disables all interrupts while VDP operations occur
              	;
              	; uses: a
F72B: 3EC9    	tm_dint:ld	a,0xC9
F72D: 323800  		ld	(0x38),a
F730: ED56    		im	1
F732: 3E0E    		ld	a,0x0E
F734: D341    		out	(tm_atla),a	; AY register = 14
F736: 3E00    		ld	a,0x00
F738: D340    		out	(tm_ayda),a	
F73A: C9      		ret
              		
              	; Enables interrupts again
              	;
              	; uses: a
F73B: 3E0E    	tm_eint:ld	a,0x0E
F73D: D341    		out	(tm_atla),a	; AY register = 14
F73F: 3EB0    		ld	a,0xB0
F741: D340    		out	(tm_ayda),a
F743: ED5E    		im	2
F745: C9      		ret
              		
              	; Variables
F746: 0200    	tm_mode:defw	0x0002
F748: E1      	tm_colr:defb	0xE1
F749: 00      	tm_inb:	defb	0
F74A: 00      	tm_inf:	defb	0
F74B: 00      	tm_curx:defb	0
F74C: 00      	tm_cury:defb	0
F74D: 01      	tm_cold:defb	1
              	#include "../dev/nabu_ndsk.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   N H A C P   V I R T U A L   D I S K
              	;*
              	;*     This driver allows for IshkurCP/M to access a virtual
              	;*     disk using the NHACP protocol. Indiviual files are 
              	;*     mounted as file systems and accessed like a disk
              	;*     normally would.
              	;*
              	;*     This particular driver uses the Nabu HCCA port to 
              	;*     facilitate communication between it and an adapter
              	;*
              	;*     In order to service CCP and GRB requests, the 
              	;*     following special files must exist:
              	;*
              	;*     '${STORAGE}/CPM22.SYS' <- For CP/M system components
              	;*     '${STORAGE}/FONT.GRB' <- For graphical driver components
              	;*
              	;*
              	;*
              	;*
              	;*     Device requires 384 bytes of bss space (nd_bss)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
FAF1: 00      	nd_tran:defs	1	; Transfer count
FAF2: 00      	nd_csec:defs	1	; Current sector (1b)
FAF3: 0000    	nd_ctrk:defs	2	; Current track (2b)
FAF5: 00000000	nd_buff:defs	64	; Buffer (64b)
FAF9: 00...   	
FB35: 00000000	nd_asva:defs	129	; ASV #1 (129b)
FB39: 00...   	
FBB6: 00000000	nd_asvb:defs	129	; ASV #1 (129b)
FBBA: 00...   	
              	.area	_TEXT
              	
0040:         	nd_ayda	equ	0x40		; AY-3-8910 data port
0041:         	nd_atla	equ	0x41		; AY-3-8910 latch port
0080:         	nd_hcca	equ	0x80		; Modem data port
0000:         	nd_nctl	equ	0x00		; NABU control port
              	
0080:         	nd_fild	equ	0x80		; Default file access desc
              	
              	
              	;
              	;**************************************************************
              	;*
              	;*         D I S K   D R I V E   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Disk A DPH
F74E: 00000000	nd_dpha:defw	0,0,0,0
F752: 00000000	
F756: 10FF    		defw	dircbuf	; DIRBUF
F758: 6EF7    		defw	nd_dpb	; DPB
F75A: 0000    		defw	0	; CSV
F75C: 35FB    		defw	nd_asva	; ALV (129 bytes)
              		
              	; Disk B DPH
F75E: 00000000	nd_dphb:defw	0,0,0,0
F762: 00000000	
F766: 10FF    		defw	dircbuf	; DIRBUF
F768: 6EF7    		defw	nd_dpb	; DPB
F76A: 0000    		defw	0	; CSV
F76C: B6FB    		defw	nd_asvb	; ALV (129 bytes)
              		
              	; NSHD8 format
F76E: 4000    	nd_dpb:	defw	64	; # sectors per track
F770: 06      		defb	6	; BSH
F771: 3F      		defb	63	; BLM
F772: 03      		defb	3	; EXM
F773: FF03    		defw	1023	; DSM
F775: FF00    		defw	255	; DRM
F777: 80      		defb	0x80	; AL0
F778: 00      		defb	0	; AL1
F779: 0000    		defw	0	; Size of directory check vector
F77B: 0000    		defw	0	; Number of reserved tracks at the beginning of disk
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
F77D: B7      	ndkdev:	or	a
F77E: 2815    		jr	z,nd_init
F780: 3D      		dec	a
F781: 2813    		jr	z,nd_home
F783: 3D      		dec	a
F784: 2817    		jr	z,nd_sel
F786: 3D      		dec	a
F787: CAC7F7  		jp	z,nd_strk
F78A: 3D      		dec	a
F78B: CACDF7  		jp	z,nd_ssec
F78E: 3D      		dec	a
F78F: CAD2F7  		jp	z,nd_read
F792: C3E3F7  		jp	nd_writ
              		
              	; Inits the device
              	; Not really needed atm
              	; hl = Call argument
              	;
              	; uses: none
F795: C9      	nd_init:ret
              	
              	; Sets "track" back to zero
              	;
              	; uses: none
F796: 210000  	nd_home:ld	hl,0
F799: 22F3FA  		ld	(nd_ctrk),hl
F79C: C9      		ret
              	
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses: hl
F79D: E5      	nd_sel:	push	hl
F79E: CD04F8  		call	nd_hini
F7A1: E1      		pop	hl
F7A2: E5      		push	hl
F7A3: 7D      		ld	a,l
F7A4: C641    		add	a,0x41		; Convert to ASCII
F7A6: 32CFF9  		ld	(nd_p2im),a
F7A9: 21CAF9  		ld	hl,nd_p2
F7AC: 11DEF9  		ld	de,nd_m0na
F7AF: 010B00  		ld	bc,11
F7B2: EDB0    		ldir
F7B4: CD68F8  		call	nd_open		; Open the file
F7B7: E1      		pop	hl		; Select DPH
F7B8: 7D      		ld	a,l
F7B9: B7      		or	a
F7BA: 214EF7  		ld	hl,nd_dpha
F7BD: C8      		ret	z
F7BE: 3D      		dec	a
F7BF: 215EF7  		ld	hl,nd_dphb
F7C2: C8      		ret	z
F7C3: 210000  		ld	hl,0
F7C6: C9      		ret
              		
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	; hl = Call argument
              	;
              	; uses: nonoe
F7C7: 60      	nd_strk:ld	h,b
F7C8: 69      		ld	l,c
F7C9: 22F3FA  		ld	(nd_ctrk),hl
F7CC: C9      		ret
              	
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	; hl = Call argument
              	;
              	; uses: none
F7CD: 79      	nd_ssec:ld	a,c
F7CE: 32F2FA  		ld	(nd_csec),a
F7D1: C9      		ret
              	
              	; Reads a sector and DMA transfers it to memory
              	;
              	; uses: af
F7D2: CD04F8  	nd_read:call	nd_hini
F7D5: CDF4F7  		call	nd_gbno
F7D8: 2A4DF3  		ld	hl,(biodma)
F7DB: CD85F8  		call	nd_getb
F7DE: 3E01    		ld	a,1
F7E0: D8      		ret	c
F7E1: AF      		xor	a
F7E2: C9      		ret
              		
              	; Write a sector from DMA
              	;
              	; uses: af
F7E3: CD04F8  	nd_writ:call	nd_hini
F7E6: CDF4F7  		call	nd_gbno
F7E9: 2A4DF3  		ld	hl,(biodma)
F7EC: CDC6F8  		call	nd_putb
F7EF: 3E01    		ld	a,1
F7F1: D8      		ret	c
F7F2: AF      		xor	a
F7F3: C9      		ret
              		
              		
              	; Gets the block # for read / write operations
              	;
              	; Returns block # in de
              	; uses: af, de, hl 
F7F4: 2AF3FA  	nd_gbno:ld	hl,(nd_ctrk)
F7F7: 29      		add	hl,hl
F7F8: 29      		add	hl,hl
F7F9: 29      		add	hl,hl
F7FA: 29      		add	hl,hl
F7FB: 29      		add	hl,hl
F7FC: 29      		add	hl,hl
F7FD: 3AF2FA  		ld	a,(nd_csec)
F800: B5      		or	l
F801: 6F      		ld	l,a
F802: EB      		ex	de,hl
F803: C9      		ret
              		
              	
              	; Set up the HCCA modem connection
              	; Configures the AY-3-8910 to monitor correct interrupts
              	; and leaves it in a state where the interrupt port is
              	; exposed
              	;
              	; uses: a, b
F804: 3E07    	nd_hini:ld	a,0x07
F806: D341    		out	(nd_atla),a	; AY register = 7
F808: DB40    		in	a,(nd_ayda)
F80A: E63F    		and	0x3F
F80C: F640    		or	0x40
F80E: D340    		out	(nd_ayda),a	; Configure AY port I/O
              		
              		; Claim interrupt vectors
F810: E5      		push	hl
F811: 215AF9  		ld	hl,nd_rirq
F814: 2200FF  		ld	(intvec),hl
F817: 21A1F9  		ld	hl,nd_wirq
F81A: 2202FF  		ld	(intvec+2),hl
F81D: E1      		pop	hl
              		
              	; Set interrupts to their default state
              	;
              	; uses: a
F81E: 3E0E    	nd_dflt:ld	a,0x0E
F820: D341    		out	(nd_atla),a	; AY register = 14
F822: 3EB0    		ld	a,0xB0
F824: D340    		out	(nd_ayda),a	; Enable HCCA receive and but not send, plus key and VDP
              		
F826: 3E0F    	nd_dfl0:ld	a,0x0F		
F828: D341    		out	(nd_atla),a	; AY register = 15
              		
F82A: C9      		ret
              	
              	; Set receive and send interrupts
              	;
              	; uses: a
F82B: 3E0E    	nd_esnd:ld	a,0x0E
F82D: D341    		out	(nd_atla),a	; AY register = 14
F82F: 3EC0    		ld	a,0xC0
F831: D340    		out	(nd_ayda),a	; Enable HCCA receive and send
F833: 18F1    		jr	nd_dfl0
              		
              	; Set receive but not send interrupt
              	;
              	; uses: a
F835: 3E0E    	nd_dsnd:ld	a,0x0E
F837: D341    		out	(nd_atla),a	; AY register = 14
F839: 3E80    		ld	a,0x80
F83B: D340    		out	(nd_ayda),a	; Enable HCCA receive and but not send
F83D: 18E7    		jr	nd_dfl0
              	
              	
              	; Loads the CCP into the CCP space
F83F: 21B6F9  	nd_ccp:	ld	hl,nd_p0
F842: 1803    		jr	nd_grb0
              		
              	; Loads the GRB into the CCP space
F844: 21C0F9  	nd_grb:	ld	hl,nd_p1
F847: 11DEF9  	nd_grb0:ld	de,nd_m0na
F84A: 010A00  		ld	bc,10
F84D: EDB0    		ldir			; Copy name to file open
F84F: CD04F8  		call	nd_hini		; Go to HCCA mode
F852: 210000  		ld	hl,0x0000	; O_RDONLY
F855: CD6BF8  		call	nd_opef		; Open the file
F858: 110000  		ld	de,0
F85B: 2100DC  		ld	hl,cbase
F85E: CD85F8  	nd_grb1:call	nd_getb
F861: 1C      		inc	e
F862: 3E10    		ld	a,16
F864: BB      		cp	e
F865: 20F7    		jr	nz,nd_grb1
F867: C9      		ret
              		
              	
              	; Open the prepared file
              	; Closes the existing file too
              	;
              	; uses: af, b, hl
F868: 210100  	nd_open:ld	hl,0x0001	; O_RDWR
F86B: 22DBF9  	nd_opef:ld	(nd_m0fl),hl
F86E: 21EDF9  		ld	hl,nd_m1
F871: 0606    		ld	b,6
F873: CD12F9  		call	nd_send
F876: 21D5F9  		ld	hl,nd_m0
F879: 0617    		ld	b,23
F87B: CD12F9  		call	nd_send
F87E: 21F5FA  		ld	hl,nd_buff
F881: CDF4F8  		call	nd_rece
F884: C9      		ret
              		
              	; Gets a block from the currently open file
              	; and places it in (hl)
              	; de = Block to read
              	; hl = Destination for information
              	;
              	; Returns location directly after in hl
              	; Carry flag set on error
              	; uses: af, b, hl
F885: CD8BF8  	nd_getb:call	nd_get0
F888: C31EF8  		jp	nd_dflt
F88B: EB      	nd_get0:ex	de,hl
F88C: 22FBF9  		ld	(nd_m2bn),hl
F88F: EB      		ex	de,hl
F890: E5      		push	hl
F891: 21F5F9  		ld	hl,nd_m2
F894: 060C    		ld	b,12
F896: CD12F9  		call	nd_send
F899: E1      		pop	hl
F89A: D8      		ret	c
F89B: CD1BF9  		call	nd_hcrd
F89E: CD1EF9  		call	nd_hcre
F8A1: D8      		ret	c
F8A2: FE84    		cp	0x84
F8A4: 37      		scf
F8A5: 2017    		jr	nz,nd_get2
F8A7: CD1EF9  		call	nd_hcre
F8AA: 32F1FA  		ld	(nd_tran),a
F8AD: 47      		ld	b,a
F8AE: CD1EF9  		call	nd_hcre
F8B1: 78      		ld	a,b
F8B2: B7      		or	a
F8B3: C8      		ret	z
F8B4: CD1EF9  	nd_get1:call	nd_hcre
F8B7: D8      		ret	c
F8B8: 77      		ld	(hl),a
F8B9: 23      		inc	hl
F8BA: 10F8    		djnz	nd_get1
F8BC: B7      		or	a
F8BD: C9      		ret
F8BE: CD1BF9  	nd_get2:call	nd_hcrd	; Read the error message and exit
F8C1: CD1EF9  		call	nd_hcre
F8C4: 37      		scf
F8C5: C9      		ret
              		
              	; Puts a block into the currently open file
              	; from that location (hl)
              	; de = Block to write
              	; hl = Source of information
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F8C6: CDCCF8  	nd_putb:call	nd_put0
F8C9: C31EF8  		jp	nd_dflt
F8CC: EB      	nd_put0:ex	de,hl
F8CD: 2207FA  		ld	(nd_m3bn),hl
F8D0: EB      		ex	de,hl
F8D1: E5      		push	hl
F8D2: 2101FA  		ld	hl,nd_m3
F8D5: 060C    		ld	b,12
F8D7: CD12F9  		call	nd_send		; Send message precursor
F8DA: E1      		pop	hl
F8DB: D8      		ret	c
F8DC: 0680    		ld	b,128
F8DE: 7E      	nd_put1:ld	a,(hl)		; Send the block
F8DF: CD68F9  		call	nd_hcwr
F8E2: D8      		ret	c
F8E3: 23      		inc	hl
F8E4: 10F8    		djnz	nd_put1
F8E6: 21F5FA  		ld	hl,nd_buff
F8E9: CDF4F8  		call	nd_rece
F8EC: 3AF5FA  		ld	a,(nd_buff)
F8EF: FE81    		cp	0x81
F8F1: C8      		ret	z
F8F2: 37      		scf
F8F3: C9      		ret
              		
              	; Receives a general response from the NHACP server
              	; hl = Destination of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F8F4: CD35F8  	nd_rece:call	nd_dsnd
F8F7: CDFDF8  		call	nd_rec0
F8FA: C31EF8  		jp	nd_dflt
F8FD: CD1EF9  	nd_rec0:call	nd_hcre
F900: D8      		ret	c		; Existing error
F901: 47      		ld	b,a
F902: CD1EF9  		call	nd_hcre
F905: D8      		ret	c		; Existing error
F906: 37      		scf
F907: C0      		ret	nz		; Message too big!
F908: CD1EF9  	nd_rec1:call	nd_hcre
F90B: D8      		ret	c		; Error!
F90C: 77      		ld	(hl),a
F90D: 23      		inc	hl
F90E: 10F8    		djnz	nd_rec1
F910: B7      		or	a
F911: C9      		ret
              		
              	; Write a number of bytes to the HCCA port
              	; b = Bytes to write
              	; hl = Start of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F912: 7E      	nd_send:ld	a,(hl)
F913: 23      		inc	hl
F914: CD68F9  		call	nd_hcwr
F917: D8      		ret	c		; Error!
F918: 10F8    		djnz	nd_send
F91A: C9      		ret
              		
              	; Read from the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	;
              	; Returns result in a
              	; Carry flag set on error
              	; Uses: af
F91B: CD1EF9  	nd_hcrd:call	nd_hcre
F91E: AF      	nd_hcre:xor	a
F91F: 32B5F9  		ld	(nd_inf),a
F922: D5      		push	de
F923: 3E09    		ld	a,0x09
F925: D300    		out	(nd_nctl),a	; Turn on recv light
F927: 11FFFF  		ld	de,0xFFFF
F92A: 3AB5F9  	nd_hcr0:ld	a,(nd_inf)
F92D: B7      		or	a
F92E: 201D    		jr	nz,nd_hcr2
F930: DB40    		in	a,(nd_ayda)
              		;bit	0,a
              		;jr	z,nd_hcr0	; Await an interrupt
              		;bit	1,a
              		;jr	z,nd_hcr1
F932: E60F    		and	0x0F
F934: EE01    		xor	0b00000001
F936: 280C    		jr	z,nd_hcr1
F938: 1B      		dec	de
F939: 7B      		ld	a,e
F93A: B2      		or	d
F93B: 20ED    		jr	nz,nd_hcr0
F93D: 3E01    	nd_hcer:ld	a,0x01
F93F: D300    		out	(nd_nctl),a	; Turn off recv light
F941: 37      		scf
F942: D1      		pop	de
F943: C9      		ret			; Timed out waiting
F944: 3E01    	nd_hcr1:ld	a,0x01
F946: D300    		out	(nd_nctl),a	; Turn off recv light
F948: DB80    		in	a,(nd_hcca)
F94A: D1      		pop	de
F94B: B7      		or	a
F94C: C9      		ret
F94D: 3E01    	nd_hcr2:ld	a,0x01
F94F: D300    		out	(nd_nctl),a	; Turn off recv light
F951: AF      		xor	a
F952: 32B5F9  		ld	(nd_inf),a
F955: 3AB4F9  		ld	a,(nd_inb)
F958: D1      		pop	de
F959: C9      		ret
              		
              	; HCCA read interrupt
              	; Reads from the HCCA, buffers it, and then sets the flag
              	;
              	; uses: none
F95A: F5      	nd_rirq:push	af
F95B: DB80    		in	a,(nd_hcca)
F95D: 32B4F9  		ld	(nd_inb),a
F960: 3E01    		ld	a,1
F962: 32B5F9  		ld	(nd_inf),a
F965: F1      		pop	af
F966: FB      		ei
F967: C9      		ret
              		
              		
              	; Write to the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	; a = Character to write
              	;
              	; Carry flag set on error
              	; Uses: f
F968: D5      	nd_hcwr:push	de
F969: 32B2F9  		ld	(nd_outb),a
F96C: AF      		xor	a
F96D: 32B3F9  		ld	(nd_outf),a
F970: CD2BF8  		call	nd_esnd
F973: 11FFFF  		ld	de,0xFFFF
F976: 3E21    		ld	a,0x21
F978: D300    		out	(nd_nctl),a	; Turn on send light
F97A: 3AB3F9  	nd_hcw0:ld	a,(nd_outf)
F97D: B7      		or	a
F97E: 2017    		jr	nz,nd_hcw2
F980: DB40    		in	a,(nd_ayda)
              		;bit	0,a
              		;jr	z,nd_hcw0	; Await an interrupt
              		;bit	1,a
              		;jr	nz,nd_hcw1
F982: E60F    		and	0x0F
F984: EE03    		xor	0b00000011
F986: 280A    		jr	z,nd_hcw1
F988: 1B      		dec	de
F989: 7B      		ld	a,e
F98A: B2      		or	d
F98B: 20ED    		jr	nz,nd_hcw0
F98D: CD35F8  		call	nd_dsnd
F990: 18AB    		jr	nd_hcer		; Timed out waiting
F992: 3AB2F9  	nd_hcw1:ld	a,(nd_outb)
F995: D380    		out	(nd_hcca),a
F997: D1      	nd_hcw2:pop	de
F998: 3E01    		ld	a,0x01
F99A: D300    		out	(nd_nctl),a	; Turn off send light
F99C: CD35F8  		call	nd_dsnd
F99F: B7      		or	a
F9A0: C9      		ret
              		
              	; HCCA write interrupt
              	; Writes to the HCCA from the buffer, and 
F9A1: F5      	nd_wirq:push	af
F9A2: 3AB2F9  		ld	a,(nd_outb)
F9A5: D380    		out	(nd_hcca),a
F9A7: 3E01    		ld	a,1
F9A9: 32B3F9  		ld	(nd_outf),a
F9AC: CD35F8  		call	nd_dsnd		; Y'all can't behave, turning off
F9AF: F1      		pop	af
F9B0: FB      		ei
F9B1: C9      		ret
              		
              	; Byte to send out of HCCA
F9B2: 00      	nd_outb:defb	0
              	
              	; HCCA output flag
F9B3: 00      	nd_outf:defb	0
              	
              	; Byte received from HCCA
F9B4: 00      	nd_inb:	defb	0
              	
              	; HCCA input flag
F9B5: 00      	nd_inf: defb	0
              		
              	; Path to CP/M image
              	; Total length: 10 bytes
F9B6: 43504D32	nd_p0:	defb	'CPM22.SYS',0
F9BA: 322E5359	
F9BE: 5300    	
              	
              	; Path to GRB image
              	; Total length: 10 bytes
F9C0: 464F4E54	nd_p1:	defb	'FONT.GRB',0,0
F9C4: 2E475242	
F9C8: 0000    	
              	
              	; Path to a generic disk image
              	; Total length: 11
F9CA: 4E44534B	nd_p2:	defb	'NDSK_'
F9CE: 5F      	
F9CF: 3F      	nd_p2im:defb	'?'		; Disk image name
F9D0: 2E494D47		defb	'.IMG',0
F9D4: 00      	
              	
              	; Message prototype to open a file
              	; Total length: 23 bytes
F9D5: 8F00    	nd_m0:	defb	0x8F,0x00
F9D7: 1300    		defw	19		; Message length
F9D9: 01      		defb	0x01		; Cmd: STORAGE-OPEN
F9DA: 80      		defb	nd_fild		; Default file descriptor
F9DB: 0100    	nd_m0fl:defw	0x01		; Read/Write flags
F9DD: 0E      		defb	0x0E		; Message length
F9DE: 58585858	nd_m0na:defb	'XXXXXXXXXXXXXX'; File name field
F9E2: 58...   	
F9EC: 00      		defb	0x00		; Padding
              		
              	; Message prototype to close a file
              	; Total length: 6 bytes
F9ED: 8F00    	nd_m1:	defb	0x8F,0x00
F9EF: 0200    		defw	2		; Message length
F9F1: 05      		defb	0x05		; Cmd: FILE-CLOSE
F9F2: 80      		defb	nd_fild		; Default file descriptor
F9F3: 0000    		defw	0x00		; Magic bytes
              		
              	; Message prototype to read a block
              	; Total length: 12 bytes
F9F5: 8F00    	nd_m2:	defb	0x8F,0x00
F9F7: 0800    		defw	8		; Message length
F9F9: 07      		defb	0x07		; Cmd: STORAGE-GET-BLOCK
F9FA: 80      		defb	nd_fild		; Default file descritor
F9FB: 00000000	nd_m2bn:defw	0x00,0x00	; Block number
F9FF: 8000    		defw	128		; Block length
              		
              	; Message prototype to write a block
              	; Total length: 12 bytes
FA01: 8F00    	nd_m3:	defb	0x8F,0x00
FA03: 8800    		defw	136		; Message length
FA05: 08      		defb	0x08		; Cmd: STORAGE-PUT-BLOCK
FA06: 80      		defb	nd_fild		; Default file descritor
FA07: 00000000	nd_m3bn:defw	0x00,0x00	; Block number
FA0B: 8000    		defw	128		; Block length
              	#include "../dev/nabu_prt.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   P A R A L L E L   O U T P U T
              	;*
              	;*      A simple output-only device driver for the NABU
              	;*      parellel printer port. 
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
0040:         	pr_ayda	equ	0x40		; AY-3-8910 data port
0041:         	pr_atla	equ	0x41		; AY-3-8910 latch port
00B0:         	pr_prnt	equ	0xB0		; Parallel output
0000:         	pr_ctrl	equ	0x00		; Device control register
              	
              	; Driver jump table 
FA0D: B7      	prtdev:	or	a
FA0E: 2808    		jr	z,pr_init
FA10: 3D      		dec	a
FA11: 2806    		jr	z,pr_stat
FA13: 3D      		dec	a
FA14: 2805    		jr	z,pr_read
FA16: 1805    		jr	pr_writ
              		
              	; Device init
              	; Does nothing
              	;
              	; uses: none
FA18: C9      	pr_init:ret
              	
              	; Device status 
              	; There are never any characters to read
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
FA19: AF      	pr_stat:xor	a
FA1A: C9      		ret
              		
              	; Waits for a character to come in and returns it
              	; No characters to read, returns 0
              	;
              	; Returns ASCII key in A
              	; uses: af
FA1B: AF      	pr_read:xor	a
FA1C: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	;
              	; uses: af, bc
FA1D: 3E0F    	pr_writ:ld	a,0x0F
FA1F: D341    		out	(pr_atla),a	; AY register = 15
              		
FA21: DB40    	pr_wri0:in	a,(pr_ayda)	; Wait for not busy
FA23: E610    		and	0x10
FA25: 20FA    		jr	nz,pr_wri0
              		
FA27: 79      		ld	a,c
FA28: D3B0    		out	(pr_prnt),a	; Write data
              		
FA2A: 3E05    		ld	a,0x05		; Strobe
FA2C: D300    		out	(pr_ctrl),a
              		
FA2E: 0620    		ld	b,32		
FA30: 10FE    	pr_wri1:djnz	pr_wri1		; Wait a few cycles
              		
FA32: 3E01    		ld	a,0x01		; Strobe off
FA34: D300    		out	(pr_ctrl),a
              		
FA36: C9      		ret
              		
              	#include "../dev/nabu_sio.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   S E R I A L   O P T I O N   C A R D
              	;*
              	;*      This driver allows the NABU serial option card to be
              	;*      used as a bidirectional Ishkur serial device. It will
              	;*      automatically search for a serial card on init. Serial
              	;*      cards are numbered by order. The first serial card gets
              	;*      a minor # of 0, the second card gets a minor number of
              	;*      1, etc... Up to 4 serial cards are supported.
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
              	
              	
              	; Driver jump table 
FA37: B7      	siodev:	or	a
FA38: 2808    		jr	z,so_init
FA3A: 3D      		dec	a
FA3B: 2833    		jr	z,so_stat
FA3D: 3D      		dec	a
FA3E: 2841    		jr	z,so_read
FA40: 1851    		jr	so_writ
              		
              	; Device init
              	; Tries to find the option card if it is installed
              	; hl = Device options
              	;
              	; uses: none
FA42: 11A7FA  	so_init:ld	de,so_atab
FA45: 45      		ld	b,l
FA46: 04      		inc	b		; Slot 1,2,3,...
FA47: 19      		add	hl,de 		; Get address table entry
FA48: 0ECF    		ld	c,0xCF		; First slot
              		
FA4A: ED78    	so_ini0:in	a,(c)
FA4C: FE08    		cp	0x08
FA4E: 2807    		jr	z,so_ini2
              		
FA50: 3E10    	so_ini1:ld	a,0x10
FA52: 81      		add	c
FA53: F0      		ret	p		; Can't find, failure
FA54: 4F      		ld	c,a
FA55: 18F3    		jr	so_ini0
              		
FA57: 10F7    	so_ini2:djnz	so_ini1		; Repeat if looking for next card
FA59: 79      		ld	a,c
FA5A: D60F    		sub	0x0F
FA5C: 4F      		ld	c,a
FA5D: 71      		ld	(hl),c
FA5E: 11ABFA  		ld	de,so_conf
FA61: 060D    		ld	b,13
              		
              		; Lets set up the serial card for 9600 8N1
              		; First we set up the 8253, then the 8251
FA63: 1A      	so_ini3:ld	a,(de)
FA64: 13      		inc	de
FA65: 86      		add	a,(hl)
FA66: 4F      		ld	c,a
FA67: 1A      		ld	a,(de)
FA68: 13      		inc	de
FA69: ED79    		out	(c),a
FA6B: E5      		push	hl
FA6C: E1      		pop	hl	; Small delay
FA6D: 10F4    		djnz	so_ini3
FA6F: C9      		ret
              	
              	; Device status 
              	; hl = Device options
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
FA70: 11A7FA  	so_stat:ld	de,so_atab
FA73: 19      		add	hl,de
FA74: AF      		xor	a
FA75: BE      		cp	(hl)
FA76: C8      		ret	z	; No device, return 0
FA77: 4E      		ld	c,(hl)
FA78: 0C      		inc	c
FA79: ED78    	so_sta0:in	a,(c)	; Check status register
FA7B: E602    		and	0x02
FA7D: C8      		ret	z
FA7E: 3EFF    		ld	a,0xFF
FA80: C9      		ret
              		
              		
              	; Waits for a character to come in and returns it
              	; hl = Device options
              	;
              	; Returns ASCII key in A
              	; uses: af
FA81: 11A7FA  	so_read:ld	de,so_atab
FA84: 19      		add	hl,de
FA85: AF      		xor	a
FA86: BE      		cp	(hl)
FA87: C8      		ret	z	; No device, return 0
FA88: 4E      		ld	c,(hl)
FA89: 0C      		inc	c
FA8A: CD79FA  	so_rea0:call	so_sta0	; Wait for a character
FA8D: 28FB    		jr	z,so_rea0
FA8F: 0D      		dec	c
FA90: ED78    		in	a,(c)
FA92: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	; hl = Device options
              	;
              	; uses: af, bc
FA93: 41      	so_writ:ld	b,c
FA94: 11A7FA  		ld	de,so_atab
FA97: 19      		add	hl,de
FA98: AF      		xor	a
FA99: BE      		cp	(hl)
FA9A: C8      		ret	z	; No device, return 0
FA9B: 4E      		ld	c,(hl)
FA9C: 0C      		inc	c
FA9D: ED78    	so_wri0:in	a,(c)
FA9F: E601    		and	0x01
FAA1: 28FA    		jr	z,so_wri0
FAA3: 0D      		dec	c
FAA4: ED41    		out	(c),b
FAA6: C9      		ret
              		
              		
              	; Variables
              	; 4 possible slots
FAA7: 00000000	so_atab:defb	0x00,0x00,0x00,0x00
              	
              	; Configuration string
              	; Sets up counters 1 and 2 on the 8523 timer
FAAB: 0737    	so_conf:defb	0x07,0x37	; Counter 1 setup
FAAD: 0412    		defb	0x04,0x12
FAAF: 0400    		defb	0x04,0x00
FAB1: 0777    		defb	0x07,0x77	; Counter 2 setup
FAB3: 0512    		defb	0x05,0x12
FAB5: 0500    		defb	0x05,0x00
              		
FAB7: 0100    		defb	0x01,0x00	; 8251 setup
FAB9: 0100    		defb	0x01,0x00
FABB: 0100    		defb	0x01,0x00
FABD: 0100    		defb	0x01,0x00
FABF: 0140    		defb	0x01,0x40
FAC1: 014E    		defb	0x01,0x4E
FAC3: 0137    		defb	0x01,0x37


; +++ segments +++

#CODE _TEXT        = $DC00 = 56320,  size = $1EC5 =  7877
#DATA _BSS         = $FAC5 = 64197,  size = $0172 =   370
#DATA _JUMP_TABLE  = $FF00 = 65280,  size = $0090 =   144

; +++ global symbols +++

ADDAH            = $DF58 = 57176  _TEXT       zcpr1_ccp.asm:1311
ADVAN            = $DF4B = 57163  _TEXT       zcpr1_ccp.asm:1294
BDOS             = $0005 =     5  _TEXT       zcpr1_ccp.asm:13
BDOSB            = $DE09 = 56841  _TEXT       zcpr1_ccp.asm:985
BDOSJP           = $DE35 = 56885  _TEXT       zcpr1_ccp.asm:1040
BEL              = $0007 =     7  _TEXT       zcpr1_ccp.asm:475
BREAK            = $DF00 = 57088  _TEXT       zcpr1_ccp.asm:1224
BRKBK            = $DF09 = 57097  _TEXT       zcpr1_ccp.asm:1229 (unused)
BUFLEN           = $0050 =    80  _TEXT       zcpr1_ccp.asm:555
CALLPROG         = $E332 = 58162  _TEXT       zcpr1_ccp.asm:2219
CB1              = $DEEF = 57071  _TEXT       zcpr1_ccp.asm:1210
CB2              = $DEF7 = 57079  _TEXT       zcpr1_ccp.asm:1216 (unused)
CBUFF            = $DC07 = 56327  _TEXT       zcpr1_ccp.asm:558
CHRCNT           = $DCBD = 56509  _TEXT       zcpr1_ccp.asm:635
CIBPTR           = $DC59 = 56409  _TEXT       zcpr1_ccp.asm:577
CIBUF            = $DC3E = 56382  _TEXT       zcpr1_ccp.asm:571
CIBUFF           = $DC08 = 56328  _TEXT       zcpr1_ccp.asm:561
CIPTR            = $DC5B = 56411  _TEXT       zcpr1_ccp.asm:579
CLEVEL3          = $00FF =   255  _TEXT       zcpr1_ccp.asm:442
CLOSE            = $DE4B = 56907  _TEXT       zcpr1_ccp.asm:1068
CMDSER           = $E081 = 57473  _TEXT       zcpr1_ccp.asm:1595
CMDTBL           = $DD65 = 56677  _TEXT       zcpr1_ccp.asm:817
CMS1             = $E086 = 57478  _TEXT       zcpr1_ccp.asm:1606
CMS2             = $E08B = 57483  _TEXT       zcpr1_ccp.asm:1609
CMS3             = $E099 = 57497  _TEXT       zcpr1_ccp.asm:1620
CMS4             = $E09C = 57500  _TEXT       zcpr1_ccp.asm:1623
CNVBUF           = $DEEA = 57066  _TEXT       zcpr1_ccp.asm:1206
COM              = $E2F1 = 58097  _TEXT       zcpr1_ccp.asm:2180
COM1             = $E317 = 58135  _TEXT       zcpr1_ccp.asm:2201
COM4             = $E360 = 58208  _TEXT       zcpr1_ccp.asm:2239
COM5             = $E369 = 58217  _TEXT       zcpr1_ccp.asm:2249
COM6             = $E36F = 58223  _TEXT       zcpr1_ccp.asm:2253
COM7             = $E377 = 58231  _TEXT       zcpr1_ccp.asm:2264 (unused)
COMLOG           = $DFF8 = 57336  _TEXT       zcpr1_ccp.asm:1462
COMMSG           = $DC77 = 56439  _TEXT       zcpr1_ccp.asm:588
CONIN            = $DDBB = 56763  _TEXT       zcpr1_ccp.asm:899
CONOUT           = $DDAE = 56750  _TEXT       zcpr1_ccp.asm:886
CPR              = $DCC3 = 56515  _TEXT       zcpr1_ccp.asm:684
CPR1             = $DCBF = 56511  _TEXT       zcpr1_ccp.asm:669
CPRDIR           = $00FF =   255  _TEXT       zcpr1_ccp.asm:356
CPRLST           = $00FF =   255  _TEXT       zcpr1_ccp.asm:355
CPRMPT           = $003E =    62  _TEXT       zcpr1_ccp.asm:462
CPRTYP           = $00FF =   255  _TEXT       zcpr1_ccp.asm:352
CR               = $000D =    13  _TEXT       zcpr1_ccp.asm:471
CRLF             = $DDA7 = 56743  _TEXT       zcpr1_ccp.asm:881
DEFDMA           = $DE2C = 56876  _TEXT       zcpr1_ccp.asm:1032
DEFUSR           = $0000 =     0  _TEXT       zcpr1_ccp.asm:337
DELETE           = $DE65 = 56933  _TEXT       zcpr1_ccp.asm:1092
DFU              = $E2DF = 58079  _TEXT       zcpr1_ccp.asm:2133
DFUSR            = $E3B3 = 58291  _TEXT       zcpr1_ccp.asm:2359
DIR              = $E0A3 = 57507  _TEXT       zcpr1_ccp.asm:1645
DIR10            = $E140 = 57664  _TEXT       zcpr1_ccp.asm:1773
DIR11            = $E14A = 57674  _TEXT       zcpr1_ccp.asm:1778
DIR2             = $E0D2 = 57554  _TEXT       zcpr1_ccp.asm:1670
DIR2A            = $E0D3 = 57555  _TEXT       zcpr1_ccp.asm:1672 (unused)
DIR3             = $E0E1 = 57569  _TEXT       zcpr1_ccp.asm:1691
DIR4             = $E104 = 57604  _TEXT       zcpr1_ccp.asm:1726
DIR5             = $E10C = 57612  _TEXT       zcpr1_ccp.asm:1741
DIR6             = $E10E = 57614  _TEXT       zcpr1_ccp.asm:1743
DIR7             = $E129 = 57641  _TEXT       zcpr1_ccp.asm:1758
DIR8             = $E12B = 57643  _TEXT       zcpr1_ccp.asm:1760
DIR9             = $E13F = 57663  _TEXT       zcpr1_ccp.asm:1771
DIRPR            = $E0D3 = 57555  _TEXT       zcpr1_ccp.asm:1680
DIRPTR           = $DFDB = 57307  _TEXT       zcpr1_ccp.asm:1435
DLOG5            = $DFF5 = 57333  _TEXT       zcpr1_ccp.asm:1458
DLOGIN           = $DFEE = 57326  _TEXT       zcpr1_ccp.asm:1453
DMASET           = $DE2F = 56879  _TEXT       zcpr1_ccp.asm:1034
DRUSER           = $00FF =   255  _TEXT       zcpr1_ccp.asm:348
ENTRY            = $DC00 = 56320  _TEXT       zcpr1_ccp.asm:516
EPRMPT           = $0000 =     0  _TEXT       zcpr1_ccp.asm:350
ERA              = $E154 = 57684  _TEXT       zcpr1_ccp.asm:1801
ERA1             = $E16D = 57709  _TEXT       zcpr1_ccp.asm:1813
ERARJ            = $E167 = 57703  _TEXT       zcpr1_ccp.asm:1810 (unused)
ERR1             = $DF24 = 57124  _TEXT       zcpr1_ccp.asm:1262
ERR2             = $DF17 = 57111  _TEXT       zcpr1_ccp.asm:1253
ERRLOG           = $E3F6 = 58358  _TEXT       zcpr1_ccp.asm:2425
ERROR            = $DF11 = 57105  _TEXT       zcpr1_ccp.asm:1250
EXECADR          = $E385 = 58245  _TEXT       zcpr1_ccp.asm:2273
EXTEST           = $E262 = 57954  _TEXT       zcpr1_ccp.asm:2032
FALSE            = $0000 =     0  _TEXT       zcpr1_ccp.asm:146
FCBCR            = $DCBB = 56507  _TEXT       zcpr1_ccp.asm:628
FCBDM            = $DCAB = 56491  _TEXT       zcpr1_ccp.asm:626
FCBDN            = $DC9B = 56475  _TEXT       zcpr1_ccp.asm:617
FCBFN            = $DC9C = 56476  _TEXT       zcpr1_ccp.asm:619
FCBFT            = $DCA4 = 56484  _TEXT       zcpr1_ccp.asm:621
FENCE            = $007C =   124  _TEXT       zcpr1_ccp.asm:449
FFEED            = $000C =    12  _TEXT       zcpr1_ccp.asm:474
FILLQ            = $E14C = 57676  _TEXT       zcpr1_ccp.asm:1784
FQLP             = $E14E = 57678  _TEXT       zcpr1_ccp.asm:1786
GET              = $E393 = 58259  _TEXT       zcpr1_ccp.asm:2291
GETDRV           = $DE28 = 56872  _TEXT       zcpr1_ccp.asm:1026
GETUSR           = $DE6E = 56942  _TEXT       zcpr1_ccp.asm:1103
GO               = $E2EC = 58092  _TEXT       zcpr1_ccp.asm:2169
GOTSYS           = $E0C6 = 57542  _TEXT       zcpr1_ccp.asm:1662
GRBDOS           = $DE46 = 56902  _TEXT       zcpr1_ccp.asm:1063
HEXNUM           = $DF9B = 57243  _TEXT       zcpr1_ccp.asm:1381
HNUM0            = $DF9E = 57246  _TEXT       zcpr1_ccp.asm:1383
HNUM1            = $DFA6 = 57254  _TEXT       zcpr1_ccp.asm:1387
HNUM2            = $DFBD = 57277  _TEXT       zcpr1_ccp.asm:1400
HNUM3            = $DFD8 = 57304  _TEXT       zcpr1_ccp.asm:1428
INPASS           = $0000 =     0  _TEXT       zcpr1_ccp.asm:346
JUMP             = $E2E7 = 58087  _TEXT       zcpr1_ccp.asm:2149
LC1              = $DDE2 = 56802  _TEXT       zcpr1_ccp.asm:941
LCOUT            = $DDD6 = 56790  _TEXT       zcpr1_ccp.asm:924
LF               = $000A =    10  _TEXT       zcpr1_ccp.asm:472
LIST             = $E17B = 57723  _TEXT       zcpr1_ccp.asm:1846
LOADADR          = $E3D1 = 58321  _TEXT       zcpr1_ccp.asm:2391
LOGIN            = $DE38 = 56888  _TEXT       zcpr1_ccp.asm:1043
LSTOUT           = $DDDD = 56797  _TEXT       zcpr1_ccp.asm:937 (unused)
LTAB             = $E1EA = 57834  _TEXT       zcpr1_ccp.asm:1931
MAXDR            = $0001 =     1  _TEXT       zcpr1_ccp.asm:333 (unused)
MAXDRIV          = $0000 =     0  _TEXT       zcpr1_ccp.asm:330
MAXUSR           = $000F =    15  _TEXT       zcpr1_ccp.asm:326
MBUFF            = $DC06 = 56326  _TEXT       zcpr1_ccp.asm:556
MEMLOAD          = $E39E = 58270  _TEXT       zcpr1_ccp.asm:2308
ML2              = $E3D3 = 58323  _TEXT       zcpr1_ccp.asm:2393
ML3              = $E3EC = 58348  _TEXT       zcpr1_ccp.asm:2408
ML4              = $E3F0 = 58352  _TEXT       zcpr1_ccp.asm:2415
MLA              = $E3AA = 58282  _TEXT       zcpr1_ccp.asm:2318
MLA0             = $E3C1 = 58305  _TEXT       zcpr1_ccp.asm:2374
MLA1             = $E3D0 = 58320  _TEXT       zcpr1_ccp.asm:2390
MLERR            = $E3F3 = 58355  _TEXT       zcpr1_ccp.asm:2419
NCHARS           = $0004 =     4  _TEXT       zcpr1_ccp.asm:812
NCMNDS           = $000B =    11  _TEXT       zcpr1_ccp.asm:871
NLINES           = $0018 =    24  _TEXT       zcpr1_ccp.asm:447
NOBOP            = $E1FA = 57850  _TEXT       zcpr1_ccp.asm:1943
NOECHO           = $DDC9 = 56777  _TEXT       zcpr1_ccp.asm:913
NOHYPH           = $E1D2 = 57810  _TEXT       zcpr1_ccp.asm:1916
NOLOG            = $DCE4 = 56548  _TEXT       zcpr1_ccp.asm:711
NOSLAS           = $E196 = 57750  _TEXT       zcpr1_ccp.asm:1880
NRCMDS           = $0003 =     3  _TEXT       zcpr1_ccp.asm:839 (unused)
NUM0             = $DF73 = 57203  _TEXT       zcpr1_ccp.asm:1341
NUM1             = $DF79 = 57209  _TEXT       zcpr1_ccp.asm:1345
NUM2             = $DF96 = 57238  _TEXT       zcpr1_ccp.asm:1369
NUMBASE          = $0048 =    72  _TEXT       zcpr1_ccp.asm:464
NUMBER           = $DF5D = 57181  _TEXT       zcpr1_ccp.asm:1321
NUMERR           = $DF98 = 57240  _TEXT       zcpr1_ccp.asm:1375
NUMS             = $DF65 = 57189  _TEXT       zcpr1_ccp.asm:1328
NUMS1            = $DF6F = 57199  _TEXT       zcpr1_ccp.asm:1335
OPEN             = $DE44 = 56900  _TEXT       zcpr1_ccp.asm:1060
OPENF            = $DE3D = 56893  _TEXT       zcpr1_ccp.asm:1055
OUTPUT           = $DDB1 = 56753  _TEXT       zcpr1_ccp.asm:889
PAGCNT           = $DCBC = 56508  _TEXT       zcpr1_ccp.asm:633
PGBAK            = $DE02 = 56834  _TEXT       zcpr1_ccp.asm:973
PGDFLG           = $0050 =    80  _TEXT       zcpr1_ccp.asm:452
PGDFLT           = $0000 =     0  _TEXT       zcpr1_ccp.asm:451
PGFLG            = $DDF5 = 56821  _TEXT       zcpr1_ccp.asm:960
PRFLG            = $DDD8 = 56792  _TEXT       zcpr1_ccp.asm:929
PRIN1            = $DE1D = 56861  _TEXT       zcpr1_ccp.asm:1011
PRINT            = $DE15 = 56853  _TEXT       zcpr1_ccp.asm:1000
PRINTC           = $DE10 = 56848  _TEXT       zcpr1_ccp.asm:995
PRNLE            = $E258 = 57944  _TEXT       zcpr1_ccp.asm:2022
PRNNF            = $DD5A = 56666  _TEXT       zcpr1_ccp.asm:804
PRT              = $E1F9 = 57849  _TEXT       zcpr1_ccp.asm:1942
QMCNT            = $DCBE = 56510  _TEXT       zcpr1_ccp.asm:637
RAS              = $0000 =     0  _TEXT       zcpr1_ccp.asm:315
RB1              = $DED4 = 57044  _TEXT       zcpr1_ccp.asm:1185
RCPRNL           = $DD49 = 56649  _TEXT       zcpr1_ccp.asm:793
READ             = $DE07 = 56839  _TEXT       zcpr1_ccp.asm:980
READF            = $DE04 = 56836  _TEXT       zcpr1_ccp.asm:978
REDBUF           = $DE89 = 56969  _TEXT       zcpr1_ccp.asm:1140
REN              = $E291 = 58001  _TEXT       zcpr1_ccp.asm:2063
REN0             = $E298 = 58008  _TEXT       zcpr1_ccp.asm:2068 (unused)
REN1             = $E2AA = 58026  _TEXT       zcpr1_ccp.asm:2076 (unused)
REN2             = $E2C1 = 58049  _TEXT       zcpr1_ccp.asm:2091
REN3             = $E2CF = 58063  _TEXT       zcpr1_ccp.asm:2099 (unused)
REN4             = $E2D2 = 58066  _TEXT       zcpr1_ccp.asm:2101
RESET            = $DE33 = 56883  _TEXT       zcpr1_ccp.asm:1038
RESETUSR         = $DE69 = 56937  _TEXT       zcpr1_ccp.asm:1098
RESTRT           = $DCF8 = 56568  _TEXT       zcpr1_ccp.asm:727
RNGSUB           = $DCE8 = 56552  _TEXT       zcpr1_ccp.asm:714
RS00             = $DD16 = 56598  _TEXT       zcpr1_ccp.asm:750
RS000            = $DD1B = 56603  _TEXT       zcpr1_ccp.asm:756 (unused)
RS1              = $DD1E = 56606  _TEXT       zcpr1_ccp.asm:761
RSTCPR           = $DD46 = 56646  _TEXT       zcpr1_ccp.asm:788
RSTJP            = $E2DC = 58076  _TEXT       zcpr1_ccp.asm:2118
SAVE             = $E20C = 57868  _TEXT       zcpr1_ccp.asm:1976
SAVE0            = $E22C = 57900  _TEXT       zcpr1_ccp.asm:1994
SAVE1            = $E233 = 57907  _TEXT       zcpr1_ccp.asm:1997
SAVE2            = $E24F = 57935  _TEXT       zcpr1_ccp.asm:2014
SAVE3            = $E25F = 57951  _TEXT       zcpr1_ccp.asm:2026
SBLANK           = $DF4F = 57167  _TEXT       zcpr1_ccp.asm:1300
SCAN15           = $E03F = 57407  _TEXT       zcpr1_ccp.asm:1525
SCAN16           = $E042 = 57410  _TEXT       zcpr1_ccp.asm:1530
SCAN17           = $E044 = 57412  _TEXT       zcpr1_ccp.asm:1532
SCAN2            = $E01E = 57374  _TEXT       zcpr1_ccp.asm:1499
SCAN3            = $E024 = 57380  _TEXT       zcpr1_ccp.asm:1503
SCAN4            = $E02A = 57386  _TEXT       zcpr1_ccp.asm:1511
SCANER           = $E002 = 57346  _TEXT       zcpr1_ccp.asm:1482
SCANF            = $E052 = 57426  _TEXT       zcpr1_ccp.asm:1551
SCANF1           = $E063 = 57443  _TEXT       zcpr1_ccp.asm:1560
SCANF2           = $E06A = 57450  _TEXT       zcpr1_ccp.asm:1565
SCANF3           = $E06C = 57452  _TEXT       zcpr1_ccp.asm:1567
SCANF4           = $E073 = 57459  _TEXT       zcpr1_ccp.asm:1575
SCANX            = $E005 = 57349  _TEXT       zcpr1_ccp.asm:1484
SCQ              = $E079 = 57465  _TEXT       zcpr1_ccp.asm:1585
SDELM            = $DF2E = 57134  _TEXT       zcpr1_ccp.asm:1270
SEAR1            = $DE52 = 56914  _TEXT       zcpr1_ccp.asm:1074
SEARF            = $DE4F = 56911  _TEXT       zcpr1_ccp.asm:1072
SEARN            = $DE56 = 56918  _TEXT       zcpr1_ccp.asm:1078
SECTFLG          = $0053 =    83  _TEXT       zcpr1_ccp.asm:467
SECURE           = $0000 =     0  _TEXT       zcpr1_ccp.asm:335
SETTSE           = $E3B8 = 58296  _TEXT       zcpr1_ccp.asm:2366
SETU0D           = $DE83 = 56963  _TEXT       zcpr1_ccp.asm:1130
SETUD            = $DE74 = 56948  _TEXT       zcpr1_ccp.asm:1117
SETUSR           = $DE70 = 56944  _TEXT       zcpr1_ccp.asm:1105
SLOGIN           = $DFE4 = 57316  _TEXT       zcpr1_ccp.asm:1444
SOFLG            = $0053 =    83  _TEXT       zcpr1_ccp.asm:457
SPRMPT           = $0024 =    36  _TEXT       zcpr1_ccp.asm:461
STACK            = $DC77 = 56439  _TEXT       zcpr1_ccp.asm:584
SUBA             = $00FF =   255  _TEXT       zcpr1_ccp.asm:421
SUBFCB           = $DC7A = 56442  _TEXT       zcpr1_ccp.asm:593
SUBFCR           = $DC9A = 56474  _TEXT       zcpr1_ccp.asm:613
SUBFRC           = $DC89 = 56457  _TEXT       zcpr1_ccp.asm:610
SUBFS2           = $DC88 = 56456  _TEXT       zcpr1_ccp.asm:608
SUBKIL           = $DE5A = 56922  _TEXT       zcpr1_ccp.asm:1084
SUPRES           = $0000 =     0  _TEXT       zcpr1_ccp.asm:459
SUSER            = $E2D9 = 58073  _TEXT       zcpr1_ccp.asm:2116
SYSFLG           = $0041 =    65  _TEXT       zcpr1_ccp.asm:455
SYSTST           = $E0F3 = 57587  _TEXT       zcpr1_ccp.asm:1704
TAB              = $0009 =     9  _TEXT       zcpr1_ccp.asm:473
TBUFF            = $0080 =   128  _TEXT       zcpr1_ccp.asm:16
TDRIVE           = $DE84 = 56964  _TEXT       zcpr1_ccp.asm:1131
TEMPDR           = $DFF9 = 57337  _TEXT       zcpr1_ccp.asm:1463
TFCB             = $005C =    92  _TEXT       zcpr1_ccp.asm:15
TMPUSR           = $DE6A = 56938  _TEXT       zcpr1_ccp.asm:1099
TPA              = $0100 =   256  _TEXT       zcpr1_ccp.asm:484
TRUE             = $00FF =   255  _TEXT       zcpr1_ccp.asm:147
TSELUSR          = $E3B5 = 58293  _TEXT       zcpr1_ccp.asm:2361
TWOCOL           = $0000 =     0  _TEXT       zcpr1_ccp.asm:377
TWOPOK           = $E0FB = 57595  _TEXT       zcpr1_ccp.asm:1718 (unused)
TYPE             = $E17F = 57727  _TEXT       zcpr1_ccp.asm:1859
TYPE0            = $E180 = 57728  _TEXT       zcpr1_ccp.asm:1867
TYPE1            = $E1AE = 57774  _TEXT       zcpr1_ccp.asm:1890
TYPE2            = $E1BF = 57791  _TEXT       zcpr1_ccp.asm:1901
TYPE2L           = $E1FD = 57853  _TEXT       zcpr1_ccp.asm:1948
TYPE3            = $E207 = 57863  _TEXT       zcpr1_ccp.asm:1954
TYPE4            = $E209 = 57865  _TEXT       zcpr1_ccp.asm:1957
UCASE            = $DDC0 = 56768  _TEXT       zcpr1_ccp.asm:905
UDFLAG           = $0004 =     4  _TEXT       zcpr1_ccp.asm:11
USER             = $E2D5 = 58069  _TEXT       zcpr1_ccp.asm:2113
USRMAX           = $0000 =     0  _TEXT       zcpr1_ccp.asm:319
USRNUM           = $DF0B = 57099  _TEXT       zcpr1_ccp.asm:1235
WIDE             = $00FF =   255  _TEXT       zcpr1_ccp.asm:448
WSTYPE           = $00FF =   255  _TEXT       zcpr1_ccp.asm:353
YESCR            = $E1F7 = 57847  _TEXT       zcpr1_ccp.asm:1940
_BSS             = $FAC5 = 64197  _BSS        config_ndsk.asm:44 (unused)
_BSS_end         = $FC37 = 64567  _BSS        config_ndsk.asm:44 (unused)
_BSS_size        = $0172 =   370  _BSS        config_ndsk.asm:44
_JUMP_TABLE      = $FF00 = 65280  _JUMP_TABLE config_ndsk.asm:45 (unused)
_JUMP_TABLE_end  = $FF90 = 65424  _JUMP_TABLE config_ndsk.asm:45 (unused)
_JUMP_TABLE_size = $0090 =   144  _JUMP_TABLE config_ndsk.asm:45 (unused)
_TEXT            = $DC00 = 56320  _TEXT       config_ndsk.asm:43 (unused)
_TEXT_end        = $FAC5 = 64197  _TEXT       config_ndsk.asm:43
_TEXT_size       = $1EC5 =  7877  _TEXT       config_ndsk.asm:43 (unused)
active           = $E742 = 59202  _TEXT       bdos.asm:489
adda2hl          = $E964 = 59748  _TEXT       bdos.asm:918
alloc0           = $F1CA = 61898  _TEXT       bdos.asm:2466
alloc1           = $F1CC = 61900  _TEXT       bdos.asm:2467
alocvect         = $F1BF = 61887  _TEXT       bdos.asm:2456
auto             = $F1DE = 61918  _TEXT       bdos.asm:2481
autoflag         = $F1E0 = 61920  _TEXT       bdos.asm:2483
autosel          = $F051 = 61521  _TEXT       bdos.asm:2196
autosl1          = $F075 = 61557  _TEXT       bdos.asm:2212
backup           = $E5A4 = 58788  _TEXT       bdos.asm:249
backup1          = $E5AC = 58796  _TEXT       bdos.asm:252
badsctr          = $E409 = 58377  _TEXT       bdos.asm:33
badsec           = $E4CA = 58570  _TEXT       bdos.asm:104
badsel           = $E4D5 = 58581  _TEXT       bdos.asm:105
badslct          = $E40B = 58379  _TEXT       bdos.asm:34
batch            = $DCE8 = 56552  _TEXT       zcpr1_ccp.asm:713
bdevsw           = $F36E = 62318  _TEXT       config_ndsk.asm:161
bdosdrv          = $E4C6 = 58566  _TEXT       bdos.asm:103
bdoserr          = $E4BA = 58554  _TEXT       bdos.asm:102
bigdisk          = $F1DD = 61917  _TEXT       bdos.asm:2480
biodma           = $F34D = 62285  _TEXT       bios.asm:337
bitmap           = $EAA3 = 60067  _TEXT       bdos.asm:1211
bitmap1          = $EAB1 = 60081  _TEXT       bdos.asm:1226
bitmap2          = $EAD2 = 60114  _TEXT       bdos.asm:1247
bitmap3          = $EAF6 = 60150  _TEXT       bdos.asm:1264
blkmask          = $F1C4 = 61892  _TEXT       bdos.asm:2462
blknmbr          = $F1E5 = 61925  _TEXT       bdos.asm:2487
blkshft          = $F1C3 = 61891  _TEXT       bdos.asm:2461
boot             = $F233 = 62003  _TEXT       bios.asm:42
bs               = $0008 =     8  _TEXT       zcpr1_ccp.asm:24
bshook           = $F318 = 62232  _TEXT       bios.asm:288
callbd           = $F2F6 = 62198  _TEXT       bios.asm:230
callmj           = $F34A = 62282  _TEXT       bios.asm:331
cbase            = $DC00 = 56320  _TEXT       zcpr1_ccp.asm:515
cbinit           = $F35E = 62302  _TEXT       config_ndsk.asm:92
cdevsw           = $F3AE = 62382  _TEXT       config_ndsk.asm:200
cdindi0          = $F322 = 62242  _TEXT       bios.asm:296
cdindi1          = $F328 = 62248  _TEXT       bios.asm:300
cdindir          = $F31E = 62238  _TEXT       bios.asm:294
cfirq            = $F364 = 62308  _TEXT       config_ndsk.asm:108 (unused)
charbuf          = $E70E = 59150  _TEXT       bdos.asm:478
checkdir         = $E99E = 59806  _TEXT       bdos.asm:991
checksum         = $E8F7 = 59639  _TEXT       bdos.asm:830
chgnam1          = $EC27 = 60455  _TEXT       bdos.asm:1503
chgnames         = $EC16 = 60438  _TEXT       bdos.asm:1495
chkblk           = $E884 = 59524  _TEXT       bdos.asm:737
chkchar          = $E514 = 58644  _TEXT       bdos.asm:146
chkdir1          = $E9C4 = 59844  _TEXT       bdos.asm:1011
chknmbr          = $E98C = 59788  _TEXT       bdos.asm:964
chkrofl          = $E944 = 59716  _TEXT       bdos.asm:894
chksum1          = $E8FD = 59645  _TEXT       bdos.asm:833
chkvect          = $F1BD = 61885  _TEXT       bdos.asm:2455
chkwprt          = $E954 = 59732  _TEXT       bdos.asm:905
chrout           = $F2B9 = 62137  _TEXT       bios.asm:171
ckbitmap         = $EA35 = 59957  _TEXT       bdos.asm:1105
ckbmap1          = $EA56 = 59990  _TEXT       bdos.asm:1140
ckcon1           = $E542 = 58690  _TEXT       bdos.asm:176
ckcon2           = $E545 = 58693  _TEXT       bdos.asm:177
ckconsol         = $E523 = 58659  _TEXT       bdos.asm:162
ckfilpos         = $E9F5 = 59893  _TEXT       bdos.asm:1054
ckrof1           = $E947 = 59719  _TEXT       bdos.asm:895
cksumtbl         = $F1EC = 61932  _TEXT       bdos.asm:2495
clears2          = $E972 = 59762  _TEXT       bdos.asm:935
closefil         = $F0A5 = 61605  _TEXT       bdos.asm:2243
closeflg         = $F1D2 = 61906  _TEXT       bdos.asm:2472
closeit          = $ECA2 = 60578  _TEXT       bdos.asm:1589
closeit1         = $ECCD = 60621  _TEXT       bdos.asm:1609
closeit2         = $ECDB = 60635  _TEXT       bdos.asm:1617
closeit3         = $ECE1 = 60641  _TEXT       bdos.asm:1621
closeit4         = $ECE8 = 60648  _TEXT       bdos.asm:1624
closeit5         = $ECFD = 60669  _TEXT       bdos.asm:1637
closeit6         = $ED17 = 60695  _TEXT       bdos.asm:1655
closeit7         = $ED1F = 60703  _TEXT       bdos.asm:1658
cntrlc           = $0003 =     3  _TEXT       zcpr1_ccp.asm:22
cntrle           = $0005 =     5  _TEXT       zcpr1_ccp.asm:23
cntrlp           = $0010 =    16  _TEXT       zcpr1_ccp.asm:29
cntrlr           = $0012 =    18  _TEXT       zcpr1_ccp.asm:30
cntrls           = $0013 =    19  _TEXT       zcpr1_ccp.asm:31
cntrlu           = $0015 =    21  _TEXT       zcpr1_ccp.asm:32
cntrlx           = $0018 =    24  _TEXT       zcpr1_ccp.asm:33
cntrlz           = $001A =    26  _TEXT       zcpr1_ccp.asm:34 (unused)
comblk           = $E877 = 59511  _TEXT       bdos.asm:728
comprand         = $EFA5 = 61349  _TEXT       bdos.asm:2062
conin            = $F2AB = 62123  _TEXT       bios.asm:158
conout           = $F2B7 = 62135  _TEXT       bios.asm:170
const            = $F2A0 = 62112  _TEXT       bios.asm:146
counter          = $F1D8 = 61912  _TEXT       bdos.asm:2478
cpmlow           = $F298 = 62104  _TEXT       bios.asm:135
cr               = $000D =    13  _TEXT       zcpr1_ccp.asm:28
curpos           = $E70C = 59148  _TEXT       bdos.asm:476
de2hl            = $E74F = 59215  _TEXT       bdos.asm:507
de2hl1           = $E750 = 59216  _TEXT       bdos.asm:508
default          = $0000 =     0              config_ndsk.asm:19
defdma           = $E9DA = 59866  _TEXT       bdos.asm:1029
del              = $007F =   127  _TEXT       zcpr1_ccp.asm:35
delfile          = $F0D7 = 61655  _TEXT       bdos.asm:2274
dirbuf           = $F1B9 = 61881  _TEXT       bdos.asm:2453
dirc1            = $E6E0 = 59104  _TEXT       bdos.asm:434
dircbuf          = $FF10 = 65296  _JUMP_TABLE config_ndsk.asm:47
dircio           = $E6D4 = 59092  _TEXT       bdos.asm:428
dirdma           = $E9E0 = 59872  _TEXT       bdos.asm:1034
dirdma1          = $E9E3 = 59875  _TEXT       bdos.asm:1039
dirread          = $E9D4 = 59860  _TEXT       bdos.asm:1024
dirsize          = $F1C8 = 61896  _TEXT       bdos.asm:2465
dirwrite         = $E9C6 = 59846  _TEXT       bdos.asm:1016
diskpb           = $F1BB = 61883  _TEXT       bdos.asm:2454
diskro           = $E4E1 = 58593  _TEXT       bdos.asm:107
doread           = $E7B2 = 59314  _TEXT       bdos.asm:578
dowrite          = $E7B8 = 59320  _TEXT       bdos.asm:583
dsksize          = $F1C6 = 61894  _TEXT       bdos.asm:2464
eboot            = $F241 = 62017  _TEXT       bios.asm:57
emptyfcb         = $F1AC = 61868  _TEXT       bdos.asm:2440
entry            = $0005 =     5  _TEXT       zcpr1_ccp.asm:12 (unused)
eparam           = $F1D6 = 61910  _TEXT       bdos.asm:2476
erafil1          = $EBA4 = 60324  _TEXT       bdos.asm:1381
erafile          = $EB9C = 60316  _TEXT       bdos.asm:1378
error1           = $E499 = 58521  _TEXT       bdos.asm:85
error2           = $E4A5 = 58533  _TEXT       bdos.asm:91
error3           = $E4AB = 58539  _TEXT       bdos.asm:94
error4           = $E4B1 = 58545  _TEXT       bdos.asm:97
error5           = $E4B4 = 58548  _TEXT       bdos.asm:99
extblk           = $E85E = 59486  _TEXT       bdos.asm:709
extblk1          = $E871 = 59505  _TEXT       bdos.asm:719
extmask          = $F1C5 = 61893  _TEXT       bdos.asm:2463
fbase            = $E406 = 58374  _TEXT       bdos.asm:29
fbase1           = $E411 = 58385  _TEXT       bdos.asm:41
fcb2hl           = $E95E = 59742  _TEXT       bdos.asm:913
fcbpos           = $F1E9 = 61929  _TEXT       bdos.asm:2489
fcbset           = $EBFD = 60413  _TEXT       bdos.asm:1473
fcreate          = $F0EC = 61676  _TEXT       bdos.asm:2291
ff               = $000C =    12  _TEXT       zcpr1_ccp.asm:27 (unused)
filepos          = $F1EA = 61930  _TEXT       bdos.asm:2490
filero           = $E4DC = 58588  _TEXT       bdos.asm:106
filesize         = $F14D = 61773  _TEXT       bdos.asm:2365
findfst          = $EB18 = 60184  _TEXT       bdos.asm:1298
findnxt          = $EB2D = 60205  _TEXT       bdos.asm:1311
fndnxt1          = $EB4A = 60234  _TEXT       bdos.asm:1324
fndnxt2          = $EB53 = 60243  _TEXT       bdos.asm:1328
fndnxt3          = $EB73 = 60275  _TEXT       bdos.asm:1344
fndnxt4          = $EB7C = 60284  _TEXT       bdos.asm:1353
fndnxt5          = $EB83 = 60291  _TEXT       bdos.asm:1358
fndnxt6          = $EB94 = 60308  _TEXT       bdos.asm:1371
fndspa1          = $EBC0 = 60352  _TEXT       bdos.asm:1411
fndspa2          = $EBD1 = 60369  _TEXT       bdos.asm:1434
fndspa3          = $EBEC = 60396  _TEXT       bdos.asm:1455
fndspa4          = $EBF4 = 60404  _TEXT       bdos.asm:1465
fndspace         = $EBBE = 60350  _TEXT       bdos.asm:1405
fndstat          = $F1D4 = 61908  _TEXT       bdos.asm:2474
functns          = $E447 = 58439  _TEXT       bdos.asm:76
getaloc          = $F111 = 61713  _TEXT       bdos.asm:2319
getblk1          = $E845 = 59461  _TEXT       bdos.asm:687
getblk2          = $E853 = 59475  _TEXT       bdos.asm:696
getblk3          = $E85C = 59484  _TEXT       bdos.asm:701
getblock         = $E83E = 59454  _TEXT       bdos.asm:684
getchar          = $E4FB = 58619  _TEXT       bdos.asm:124
getcon           = $E6C8 = 59080  _TEXT       bdos.asm:416
getcrnt          = $F104 = 61700  _TEXT       bdos.asm:2308
getcsts          = $E6FE = 59134  _TEXT       bdos.asm:461
getecho          = $E506 = 58630  _TEXT       bdos.asm:133
getempty         = $ED24 = 60708  _TEXT       bdos.asm:1665
getfst           = $F0AB = 61611  _TEXT       bdos.asm:2250
getfst1          = $F0C2 = 61634  _TEXT       bdos.asm:2261
getiob           = $E6ED = 59117  _TEXT       bdos.asm:442
getlog           = $F0FE = 61694  _TEXT       bdos.asm:2303
getmt1           = $ED46 = 60742  _TEXT       bdos.asm:1681
getnext          = $ED5A = 60762  _TEXT       bdos.asm:1695
getnxt           = $F0C8 = 61640  _TEXT       bdos.asm:2266
getparm          = $F126 = 61734  _TEXT       bdos.asm:2336
getprm1          = $F129 = 61737  _TEXT       bdos.asm:2337
getrdr           = $E6CE = 59086  _TEXT       bdos.asm:421
getrov           = $F117 = 61719  _TEXT       bdos.asm:2324
gets2            = $E969 = 59753  _TEXT       bdos.asm:927
getuser          = $F12D = 61741  _TEXT       bdos.asm:2344
getver           = $F07E = 61566  _TEXT       bdos.asm:2220
getwprt          = $E91E = 59678  _TEXT       bdos.asm:867
goback           = $F174 = 61812  _TEXT       bdos.asm:2400
goback1          = $F191 = 61841  _TEXT       bdos.asm:2412
gtnext1          = $ED83 = 60803  _TEXT       bdos.asm:1715
gtnext2          = $ED8E = 60814  _TEXT       bdos.asm:1724
gtnext3          = $EDAC = 60844  _TEXT       bdos.asm:1735
gtnext4          = $EDAF = 60847  _TEXT       bdos.asm:1736
gtnext5          = $EDB6 = 60854  _TEXT       bdos.asm:1743
home             = $F2D9 = 62169  _TEXT       bios.asm:204
homedrv          = $E7A1 = 59297  _TEXT       bdos.asm:564
inbuff           = $DC06 = 56326  _TEXT       zcpr1_ccp.asm:554
intvec           = $FF00 = 65280  _JUMP_TABLE config_ndsk.asm:46
iobyte           = $0003 =     3  _TEXT       zcpr1_ccp.asm:9
ioerr1           = $E705 = 59141  _TEXT       bdos.asm:471
ioret            = $E7BB = 59323  _TEXT       bdos.asm:584
jumphl           = $E74A = 59210  _TEXT       bdos.asm:499
lf               = $000A =    10  _TEXT       zcpr1_ccp.asm:26
list             = $F2C3 = 62147  _TEXT       bios.asm:181
logical          = $E88A = 59530  _TEXT       bdos.asm:748
logicl1          = $E890 = 59536  _TEXT       bdos.asm:750
login            = $F1AF = 61871  _TEXT       bdos.asm:2442
logindrv         = $F021 = 61473  _TEXT       bdos.asm:2164
logoff           = $F153 = 61779  _TEXT       bdos.asm:2374
logsect          = $F1E7 = 61927  _TEXT       bdos.asm:2488
mem              = $0037 =    55              config_ndsk.asm:38
mode             = $F1D5 = 61909  _TEXT       bdos.asm:2475
morefls          = $E97F = 59775  _TEXT       bdos.asm:951
movedir          = $E9E9 = 59881  _TEXT       bdos.asm:1046
moveword         = $EC94 = 60564  _TEXT       bdos.asm:1572
nd_asva          = $FB35 = 64309  _BSS        nabu_ndsk.asm:33
nd_asvb          = $FBB6 = 64438  _BSS        nabu_ndsk.asm:34
nd_atla          = $0041 =    65  _TEXT       nabu_ndsk.asm:38
nd_ayda          = $0040 =    64  _TEXT       nabu_ndsk.asm:37
nd_buff          = $FAF5 = 64245  _BSS        nabu_ndsk.asm:32
nd_ccp           = $F83F = 63551  _TEXT       nabu_ndsk.asm:255
nd_csec          = $FAF2 = 64242  _BSS        nabu_ndsk.asm:30
nd_ctrk          = $FAF3 = 64243  _BSS        nabu_ndsk.asm:31
nd_dfl0          = $F826 = 63526  _TEXT       nabu_ndsk.asm:230
nd_dflt          = $F81E = 63518  _TEXT       nabu_ndsk.asm:225
nd_dpb           = $F76E = 63342  _TEXT       nabu_ndsk.asm:68
nd_dpha          = $F74E = 63310  _TEXT       nabu_ndsk.asm:54
nd_dphb          = $F75E = 63326  _TEXT       nabu_ndsk.asm:61
nd_dsnd          = $F835 = 63541  _TEXT       nabu_ndsk.asm:247
nd_esnd          = $F82B = 63531  _TEXT       nabu_ndsk.asm:238
nd_fild          = $0080 =   128  _TEXT       nabu_ndsk.asm:42
nd_gbno          = $F7F4 = 63476  _TEXT       nabu_ndsk.asm:187
nd_get0          = $F88B = 63627  _TEXT       nabu_ndsk.asm:302
nd_get1          = $F8B4 = 63668  _TEXT       nabu_ndsk.asm:324
nd_get2          = $F8BE = 63678  _TEXT       nabu_ndsk.asm:331
nd_getb          = $F885 = 63621  _TEXT       nabu_ndsk.asm:300
nd_grb           = $F844 = 63556  _TEXT       nabu_ndsk.asm:259
nd_grb0          = $F847 = 63559  _TEXT       nabu_ndsk.asm:260
nd_grb1          = $F85E = 63582  _TEXT       nabu_ndsk.asm:268
nd_hcca          = $0080 =   128  _TEXT       nabu_ndsk.asm:39
nd_hcer          = $F93D = 63805  _TEXT       nabu_ndsk.asm:433
nd_hcr0          = $F92A = 63786  _TEXT       nabu_ndsk.asm:418
nd_hcr1          = $F944 = 63812  _TEXT       nabu_ndsk.asm:438
nd_hcr2          = $F94D = 63821  _TEXT       nabu_ndsk.asm:444
nd_hcrd          = $F91B = 63771  _TEXT       nabu_ndsk.asm:411
nd_hcre          = $F91E = 63774  _TEXT       nabu_ndsk.asm:412
nd_hcw0          = $F97A = 63866  _TEXT       nabu_ndsk.asm:481
nd_hcw1          = $F992 = 63890  _TEXT       nabu_ndsk.asm:498
nd_hcw2          = $F997 = 63895  _TEXT       nabu_ndsk.asm:500
nd_hcwr          = $F968 = 63848  _TEXT       nabu_ndsk.asm:473
nd_hini          = $F804 = 63492  _TEXT       nabu_ndsk.asm:207
nd_home          = $F796 = 63382  _TEXT       nabu_ndsk.asm:107
nd_inb           = $F9B4 = 63924  _TEXT       nabu_ndsk.asm:526
nd_inf           = $F9B5 = 63925  _TEXT       nabu_ndsk.asm:529
nd_init          = $F795 = 63381  _TEXT       nabu_ndsk.asm:102
nd_m0            = $F9D5 = 63957  _TEXT       nabu_ndsk.asm:547
nd_m0fl          = $F9DB = 63963  _TEXT       nabu_ndsk.asm:551
nd_m0na          = $F9DE = 63966  _TEXT       nabu_ndsk.asm:553
nd_m1            = $F9ED = 63981  _TEXT       nabu_ndsk.asm:558
nd_m2            = $F9F5 = 63989  _TEXT       nabu_ndsk.asm:566
nd_m2bn          = $F9FB = 63995  _TEXT       nabu_ndsk.asm:570
nd_m3            = $FA01 = 64001  _TEXT       nabu_ndsk.asm:575
nd_m3bn          = $FA07 = 64007  _TEXT       nabu_ndsk.asm:579
nd_nctl          = $0000 =     0  _TEXT       nabu_ndsk.asm:40
nd_opef          = $F86B = 63595  _TEXT       nabu_ndsk.asm:281
nd_open          = $F868 = 63592  _TEXT       nabu_ndsk.asm:280
nd_outb          = $F9B2 = 63922  _TEXT       nabu_ndsk.asm:520
nd_outf          = $F9B3 = 63923  _TEXT       nabu_ndsk.asm:523
nd_p0            = $F9B6 = 63926  _TEXT       nabu_ndsk.asm:533
nd_p1            = $F9C0 = 63936  _TEXT       nabu_ndsk.asm:537
nd_p2            = $F9CA = 63946  _TEXT       nabu_ndsk.asm:541
nd_p2im          = $F9CF = 63951  _TEXT       nabu_ndsk.asm:542
nd_put0          = $F8CC = 63692  _TEXT       nabu_ndsk.asm:345
nd_put1          = $F8DE = 63710  _TEXT       nabu_ndsk.asm:355
nd_putb          = $F8C6 = 63686  _TEXT       nabu_ndsk.asm:343
nd_read          = $F7D2 = 63442  _TEXT       nabu_ndsk.asm:161
nd_rec0          = $F8FD = 63741  _TEXT       nabu_ndsk.asm:376
nd_rec1          = $F908 = 63752  _TEXT       nabu_ndsk.asm:383
nd_rece          = $F8F4 = 63732  _TEXT       nabu_ndsk.asm:373
nd_rirq          = $F95A = 63834  _TEXT       nabu_ndsk.asm:456
nd_sel           = $F79D = 63389  _TEXT       nabu_ndsk.asm:116
nd_send          = $F912 = 63762  _TEXT       nabu_ndsk.asm:397
nd_ssec          = $F7CD = 63437  _TEXT       nabu_ndsk.asm:154
nd_strk          = $F7C7 = 63431  _TEXT       nabu_ndsk.asm:144
nd_tran          = $FAF1 = 64241  _BSS        nabu_ndsk.asm:29
nd_wirq          = $F9A1 = 63905  _TEXT       nabu_ndsk.asm:509
nd_writ          = $F7E3 = 63459  _TEXT       nabu_ndsk.asm:173
ndkdev           = $F77D = 63357  _TEXT       nabu_ndsk.asm:83
newline          = $E5B1 = 58801  _TEXT       bdos.asm:258
newln1           = $E5B9 = 58809  _TEXT       bdos.asm:261
nfuncts          = $0029 =    41  _TEXT       bdos.asm:74
nulldev          = $F349 = 62281  _TEXT       bios.asm:328 (unused)
nxent1           = $EA19 = 59929  _TEXT       bdos.asm:1084
nxent2           = $EA20 = 59936  _TEXT       bdos.asm:1087
nxentry          = $EA05 = 59909  _TEXT       bdos.asm:1076
offset           = $F1CE = 61902  _TEXT       bdos.asm:2468
olddrv           = $F1DF = 61919  _TEXT       bdos.asm:2482
openfil          = $F09C = 61596  _TEXT       bdos.asm:2237
openit           = $EC51 = 60497  _TEXT       bdos.asm:1529
openit1          = $EC5A = 60506  _TEXT       bdos.asm:1533
openit2          = $EC8B = 60555  _TEXT       bdos.asm:1561
outchar          = $E548 = 58696  _TEXT       bdos.asm:184
outchr1          = $E562 = 58722  _TEXT       bdos.asm:198
outchr2          = $E579 = 58745  _TEXT       bdos.asm:214
outcon           = $E590 = 58768  _TEXT       bdos.asm:235
outcon1          = $E596 = 58774  _TEXT       bdos.asm:238
outcrlf          = $E5C9 = 58825  _TEXT       bdos.asm:271
outflag          = $E70A = 59146  _TEXT       bdos.asm:474
params           = $E743 = 59203  _TEXT       bdos.asm:490
pattrn2          = $E400 = 58368  _TEXT       bdos.asm:21 (unused)
position         = $EF03 = 61187  _TEXT       bdos.asm:1939
positn1          = $EF07 = 61191  _TEXT       bdos.asm:1944
positn2          = $EF47 = 61255  _TEXT       bdos.asm:1990
positn3          = $EF7F = 61311  _TEXT       bdos.asm:2022
positn4          = $EF84 = 61316  _TEXT       bdos.asm:2028
positn5          = $EF8B = 61323  _TEXT       bdos.asm:2035
pr_atla          = $0041 =    65  _TEXT       nabu_prt.asm:14
pr_ayda          = $0040 =    64  _TEXT       nabu_prt.asm:13
pr_ctrl          = $0000 =     0  _TEXT       nabu_prt.asm:16
pr_init          = $FA18 = 64024  _TEXT       nabu_prt.asm:31
pr_prnt          = $00B0 =   176  _TEXT       nabu_prt.asm:15
pr_read          = $FA1B = 64027  _TEXT       nabu_prt.asm:46
pr_stat          = $FA19 = 64025  _TEXT       nabu_prt.asm:38
pr_wri0          = $FA21 = 64033  _TEXT       nabu_prt.asm:56
pr_wri1          = $FA30 = 64048  _TEXT       nabu_prt.asm:67
pr_writ          = $FA1D = 64029  _TEXT       nabu_prt.asm:53
prstat           = $F312 = 62226  _TEXT       bios.asm:276
prtdev           = $FA0D = 64013  _TEXT       nabu_prt.asm:19
prterr           = $E4E5 = 58597  _TEXT       bdos.asm:111
prtflag          = $E70D = 59149  _TEXT       bdos.asm:477
prtmesg          = $E5D3 = 58835  _TEXT       bdos.asm:278
prtstr           = $E6F8 = 59128  _TEXT       bdos.asm:454
punch            = $F2C7 = 62151  _TEXT       bios.asm:187
putdma           = $F10A = 61706  _TEXT       bdos.asm:2313
ransiz1          = $EFE4 = 61412  _TEXT       bdos.asm:2118
ransiz2          = $F006 = 61446  _TEXT       bdos.asm:2140
ransiz3          = $F00C = 61452  _TEXT       bdos.asm:2142
ransize          = $EFD2 = 61394  _TEXT       bdos.asm:2107
rdbuf1           = $E5EF = 58863  _TEXT       bdos.asm:297
rdbuf10          = $E670 = 58992  _TEXT       bdos.asm:359
rdbuf11          = $E678 = 59000  _TEXT       bdos.asm:365
rdbuf12          = $E68A = 59018  _TEXT       bdos.asm:377
rdbuf13          = $E699 = 59033  _TEXT       bdos.asm:384
rdbuf14          = $E6A6 = 59046  _TEXT       bdos.asm:392
rdbuf15          = $E6A9 = 59049  _TEXT       bdos.asm:395
rdbuf16          = $E6BD = 59069  _TEXT       bdos.asm:407
rdbuf17          = $E6C1 = 59073  _TEXT       bdos.asm:409
rdbuf2           = $E5F1 = 58865  _TEXT       bdos.asm:299
rdbuf3           = $E616 = 58902  _TEXT       bdos.asm:316
rdbuf4           = $E626 = 58918  _TEXT       bdos.asm:325
rdbuf5           = $E637 = 58935  _TEXT       bdos.asm:333
rdbuf6           = $E648 = 58952  _TEXT       bdos.asm:342
rdbuf7           = $E64E = 58958  _TEXT       bdos.asm:345
rdbuf8           = $E65F = 58975  _TEXT       bdos.asm:352
rdbuf9           = $E66B = 58987  _TEXT       bdos.asm:357
rdbuff           = $E5E1 = 58849  _TEXT       bdos.asm:290
rdrandom         = $F141 = 61761  _TEXT       bdos.asm:2355
rdseq            = $EDBC = 60860  _TEXT       bdos.asm:1748
rdseq1           = $EDC1 = 60865  _TEXT       bdos.asm:1750
rdseq2           = $EDE6 = 60902  _TEXT       bdos.asm:1765
rdseq3           = $EDFB = 60923  _TEXT       bdos.asm:1775
rdwrtflg         = $F1D3 = 61907  _TEXT       bdos.asm:2473
read             = $F30A = 62218  _TEXT       bios.asm:261
reader           = $F2CB = 62155  _TEXT       bios.asm:193
readran          = $EF93 = 61331  _TEXT       bdos.asm:2042
readseq          = $F0E0 = 61664  _TEXT       bdos.asm:2281
relblock         = $F1D7 = 61911  _TEXT       bdos.asm:2477
renfile          = $F0F5 = 61685  _TEXT       bdos.asm:2297
resccp           = $F368 = 62312  _TEXT       config_ndsk.asm:150
resgrb           = $F36B = 62315  _TEXT       config_ndsk.asm:156
rodisk           = $E40D = 58381  _TEXT       bdos.asm:35
rofile           = $E40F = 58383  _TEXT       bdos.asm:36
rstdsk           = $F083 = 61571  _TEXT       bdos.asm:2225
rtn              = $E704 = 59140  _TEXT       bdos.asm:467
samext           = $EB07 = 60167  _TEXT       bdos.asm:1279
savatr1          = $EC40 = 60480  _TEXT       bdos.asm:1519
saveattr         = $EC3B = 60475  _TEXT       bdos.asm:1517
savefcb          = $F1D9 = 61913  _TEXT       bdos.asm:2479
savext           = $F1E2 = 61922  _TEXT       bdos.asm:2485
savnrec          = $F1E3 = 61923  _TEXT       bdos.asm:2486
savnxt           = $F1E1 = 61921  _TEXT       bdos.asm:2484
scratch1         = $F1B3 = 61875  _TEXT       bdos.asm:2447
scratch2         = $F1B5 = 61877  _TEXT       bdos.asm:2448
scratch3         = $F1B7 = 61879  _TEXT       bdos.asm:2449
sectors          = $F1C1 = 61889  _TEXT       bdos.asm:2460
sectrn           = $F315 = 62229  _TEXT       bios.asm:281
seldsk           = $F2DE = 62174  _TEXT       bios.asm:213
select           = $E759 = 59225  _TEXT       bdos.asm:518
select1          = $E79D = 59293  _TEXT       bdos.asm:558
setattr          = $F11D = 61725  _TEXT       bdos.asm:2329
setbit           = $E90B = 59659  _TEXT       bdos.asm:850
setdir           = $E99C = 59804  _TEXT       bdos.asm:984
setdma           = $F304 = 62212  _TEXT       bios.asm:253
setdsk           = $F045 = 61509  _TEXT       bdos.asm:2185
setext           = $E8A6 = 59558  _TEXT       bdos.asm:765
setfile          = $EA6B = 60011  _TEXT       bdos.asm:1169
setfl1           = $EA75 = 60021  _TEXT       bdos.asm:1174
setfl2           = $EA88 = 60040  _TEXT       bdos.asm:1186
setfl3           = $EA8E = 60046  _TEXT       bdos.asm:1192
setfl4           = $EA9D = 60061  _TEXT       bdos.asm:1201
sethlde          = $E8AE = 59566  _TEXT       bdos.asm:773
setiob           = $E6F3 = 59123  _TEXT       bdos.asm:447
setnrec          = $E8D2 = 59602  _TEXT       bdos.asm:799
setran           = $F00E = 61454  _TEXT       bdos.asm:2148
sets2b7          = $E978 = 59768  _TEXT       bdos.asm:941
setsec           = $F300 = 62208  _TEXT       bios.asm:246
setstat          = $E701 = 59137  _TEXT       bdos.asm:466
settrk           = $F2FC = 62204  _TEXT       bios.asm:239
setuser          = $F13B = 61755  _TEXT       bdos.asm:2349
shiftl           = $E904 = 59652  _TEXT       bdos.asm:841
shiftl1          = $E905 = 59653  _TEXT       bdos.asm:842
shiftr           = $E8EA = 59626  _TEXT       bdos.asm:815
shiftr1          = $E8EB = 59627  _TEXT       bdos.asm:816
showit           = $E57F = 58751  _TEXT       bdos.asm:222
siodev           = $FA37 = 64055  _TEXT       nabu_sio.asm:20
slcterr          = $E747 = 59207  _TEXT       bdos.asm:495
so_atab          = $FAA7 = 64167  _TEXT       nabu_sio.asm:131
so_conf          = $FAAB = 64171  _TEXT       nabu_sio.asm:135
so_ini0          = $FA4A = 64074  _TEXT       nabu_sio.asm:39
so_ini1          = $FA50 = 64080  _TEXT       nabu_sio.asm:43
so_ini2          = $FA57 = 64087  _TEXT       nabu_sio.asm:49
so_ini3          = $FA63 = 64099  _TEXT       nabu_sio.asm:59
so_init          = $FA42 = 64066  _TEXT       nabu_sio.asm:33
so_rea0          = $FA8A = 64138  _TEXT       nabu_sio.asm:102
so_read          = $FA81 = 64129  _TEXT       nabu_sio.asm:95
so_sta0          = $FA79 = 64121  _TEXT       nabu_sio.asm:83
so_stat          = $FA70 = 64112  _TEXT       nabu_sio.asm:76
so_wri0          = $FA9D = 64157  _TEXT       nabu_sio.asm:121
so_writ          = $FA93 = 64147  _TEXT       nabu_sio.asm:113
starting         = $E70B = 59147  _TEXT       bdos.asm:475
status           = $E745 = 59205  _TEXT       bdos.asm:491
stbitmap         = $EA5C = 59996  _TEXT       bdos.asm:1149
stbmap1          = $EA64 = 60004  _TEXT       bdos.asm:1160
stfilpos         = $E9FE = 59902  _TEXT       bdos.asm:1064
stkarea          = $E741 = 59201  _TEXT       bdos.asm:486
stnrec1          = $E8DE = 59614  _TEXT       bdos.asm:804
strdata          = $E8BB = 59579  _TEXT       bdos.asm:783
ststatus         = $EB01 = 60161  _TEXT       bdos.asm:1271
subhl            = $E995 = 59797  _TEXT       bdos.asm:974
swindi0          = $F331 = 62257  _TEXT       bios.asm:311
swindi1          = $F337 = 62263  _TEXT       bios.asm:315
swindir          = $F32D = 62253  _TEXT       bios.asm:309
syshook          = $F367 = 62311  _TEXT       config_ndsk.asm:128
tab              = $0009 =     9  _TEXT       zcpr1_ccp.asm:25
tbase            = $0100 =   256  _TEXT       zcpr1_ccp.asm:18 (unused)
tbuff            = $0080 =   128  _TEXT       zcpr1_ccp.asm:17
tdrive           = $0004 =     4  _TEXT       zcpr1_ccp.asm:10
tfcb             = $005C =    92  _TEXT       zcpr1_ccp.asm:14 (unused)
tm_40c           = $F5F4 = 62964  _TEXT       nabu_vdp.asm:462
tm_80c           = $F601 = 62977  _TEXT       nabu_vdp.asm:469
tm_addh          = $F718 = 63256  _TEXT       nabu_vdp.asm:707
tm_addr          = $F71A = 63258  _TEXT       nabu_vdp.asm:709
tm_atla          = $0041 =    65  _TEXT       nabu_vdp.asm:37
tm_ayda          = $0040 =    64  _TEXT       nabu_vdp.asm:36
tm_bs            = $F54A = 62794  _TEXT       nabu_vdp.asm:348
tm_cbuf          = $FAC9 = 64201  _BSS        nabu_vdp.asm:26
tm_cha0          = $F6BC = 63164  _TEXT       nabu_vdp.asm:630
tm_chat          = $F6B6 = 63158  _TEXT       nabu_vdp.asm:625
tm_cle0          = $F5E0 = 62944  _TEXT       nabu_vdp.asm:447
tm_clea          = $F5D1 = 62929  _TEXT       nabu_vdp.asm:438
tm_cles          = $F5CF = 62927  _TEXT       nabu_vdp.asm:437
tm_cloc          = $F45B = 62555  _TEXT       nabu_vdp.asm:172
tm_cls           = $F6FD = 63229  _TEXT       nabu_vdp.asm:684
tm_cls0          = $F706 = 63238  _TEXT       nabu_vdp.asm:687
tm_cold          = $F74D = 63309  _TEXT       nabu_vdp.asm:754
tm_colr          = $F748 = 63304  _TEXT       nabu_vdp.asm:749
tm_cr            = $F547 = 62791  _TEXT       nabu_vdp.asm:345
tm_cshm          = $F559 = 62809  _TEXT       nabu_vdp.asm:362
tm_cupd          = $F5F8 = 62968  _TEXT       nabu_vdp.asm:464
tm_curx          = $F74B = 63307  _TEXT       nabu_vdp.asm:752
tm_cury          = $F74C = 63308  _TEXT       nabu_vdp.asm:753
tm_data          = $00A0 =   160  _TEXT       nabu_vdp.asm:30
tm_dint          = $F72B = 63275  _TEXT       nabu_vdp.asm:728
tm_dsc0          = $F627 = 63015  _TEXT       nabu_vdp.asm:495
tm_dsco          = $F614 = 62996  _TEXT       nabu_vdp.asm:488
tm_eint          = $F73B = 63291  _TEXT       nabu_vdp.asm:740
tm_esc           = $F58E = 62862  _TEXT       nabu_vdp.asm:394
tm_esc0          = $F59F = 62879  _TEXT       nabu_vdp.asm:405
tm_esc1          = $F5B9 = 62905  _TEXT       nabu_vdp.asm:420
tm_esc2          = $F5C4 = 62916  _TEXT       nabu_vdp.asm:427
tm_escd          = $F59A = 62874  _TEXT       nabu_vdp.asm:402
tm_esci          = $F5B3 = 62899  _TEXT       nabu_vdp.asm:417
tm_escr          = $F59B = 62875  _TEXT       nabu_vdp.asm:403
tm_escs          = $FAC7 = 64199  _BSS        nabu_vdp.asm:24
tm_get0          = $F650 = 63056  _TEXT       nabu_vdp.asm:530
tm_getc          = $F63A = 63034  _TEXT       nabu_vdp.asm:516
tm_home          = $F55C = 62812  _TEXT       nabu_vdp.asm:363
tm_inb           = $F749 = 63305  _TEXT       nabu_vdp.asm:750
tm_inf           = $F74A = 63306  _TEXT       nabu_vdp.asm:751
tm_ini0          = $F42E = 62510  _TEXT       nabu_vdp.asm:140
tm_ini1          = $F44E = 62542  _TEXT       nabu_vdp.asm:161
tm_inir          = $F3D4 = 62420  _TEXT       nabu_vdp.asm:79
tm_init          = $F406 = 62470  _TEXT       nabu_vdp.asm:116
tm_inr0          = $F3D5 = 62421  _TEXT       nabu_vdp.asm:80
tm_keyd          = $0090 =   144  _TEXT       nabu_vdp.asm:33
tm_keys          = $0091 =   145  _TEXT       nabu_vdp.asm:34
tm_kirq          = $F658 = 63064  _TEXT       nabu_vdp.asm:539
tm_last          = $FAC8 = 64200  _BSS        nabu_vdp.asm:25
tm_latc          = $00A1 =   161  _TEXT       nabu_vdp.asm:31
tm_lf            = $F53B = 62779  _TEXT       nabu_vdp.asm:336
tm_map           = $F666 = 63078  _TEXT       nabu_vdp.asm:554
tm_map0          = $F66A = 63082  _TEXT       nabu_vdp.asm:558
tm_map2          = $F676 = 63094  _TEXT       nabu_vdp.asm:571
tm_mapt          = $F67D = 63101  _TEXT       nabu_vdp.asm:578
tm_mode          = $F746 = 63302  _TEXT       nabu_vdp.asm:748
tm_oti0          = $F3CC = 62412  _TEXT       nabu_vdp.asm:66
tm_otir          = $F3CB = 62411  _TEXT       nabu_vdp.asm:65
tm_outc          = $FAC5 = 64197  _BSS        nabu_vdp.asm:22
tm_putc          = $F692 = 63122  _TEXT       nabu_vdp.asm:596
tm_putf          = $F6A0 = 63136  _TEXT       nabu_vdp.asm:604 (unused)
tm_rea0          = $F4B4 = 62644  _TEXT       nabu_vdp.asm:237
tm_rea1          = $F4CA = 62666  _TEXT       nabu_vdp.asm:249
tm_rea2          = $F4DF = 62687  _TEXT       nabu_vdp.asm:262
tm_rea3          = $F4EF = 62703  _TEXT       nabu_vdp.asm:272
tm_read          = $F4A8 = 62632  _TEXT       nabu_vdp.asm:231
tm_ri            = $F534 = 62772  _TEXT       nabu_vdp.asm:330
tm_sclf          = $F473 = 62579  _TEXT       nabu_vdp.asm:188
tm_scol          = $F607 = 62983  _TEXT       nabu_vdp.asm:474
tm_scr0          = $F46B = 62571  _TEXT       nabu_vdp.asm:185
tm_scr1          = $F471 = 62577  _TEXT       nabu_vdp.asm:187
tm_scri          = $F461 = 62561  _TEXT       nabu_vdp.asm:180
tm_scro          = $FAC6 = 64198  _BSS        nabu_vdp.asm:23
tm_setp          = $F47D = 62589  _TEXT       nabu_vdp.asm:198
tm_sta0          = $F3E9 = 62441  _TEXT       nabu_vdp.asm:98
tm_sta1          = $F3F4 = 62452  _TEXT       nabu_vdp.asm:103
tm_sta2          = $F500 = 62720  _TEXT       nabu_vdp.asm:286
tm_stal          = $F4FD = 62717  _TEXT       nabu_vdp.asm:284
tm_stat          = $F3DD = 62429  _TEXT       nabu_vdp.asm:92
tm_up            = $F554 = 62804  _TEXT       nabu_vdp.asm:357
tm_updc          = $F60B = 62987  _TEXT       nabu_vdp.asm:478
tm_usc0          = $F6E9 = 63209  _TEXT       nabu_vdp.asm:663
tm_usco          = $F6DA = 63194  _TEXT       nabu_vdp.asm:656
tm_vcpy          = $F6C2 = 63170  _TEXT       nabu_vdp.asm:642
tm_virq          = $F725 = 63269  _TEXT       nabu_vdp.asm:718
tm_wri0          = $F521 = 62753  _TEXT       nabu_vdp.asm:318
tm_wri1          = $F560 = 62816  _TEXT       nabu_vdp.asm:368
tm_writ          = $F506 = 62726  _TEXT       nabu_vdp.asm:298
trksec           = $E7C3 = 59331  _TEXT       bdos.asm:592
trksec1          = $E7D1 = 59345  _TEXT       bdos.asm:601
trksec2          = $E7E4 = 59364  _TEXT       bdos.asm:614
trksec3          = $E7FA = 59386  _TEXT       bdos.asm:630
trksec4          = $E80F = 59407  _TEXT       bdos.asm:647
update           = $EC01 = 60417  _TEXT       bdos.asm:1480
update1          = $EC10 = 60432  _TEXT       bdos.asm:1488
userdma          = $F1B1 = 61873  _TEXT       bdos.asm:2443
userno           = $E741 = 59201  _TEXT       bdos.asm:488
usrstack         = $E70F = 59151  _TEXT       bdos.asm:482
vdpdev           = $F3BE = 62398  _TEXT       nabu_vdp.asm:51
wbinit           = $F34F = 62287  _TEXT       config_ndsk.asm:66
wboot            = $F246 = 62022  _TEXT       bios.asm:62
wboot0           = $F26D = 62061  _TEXT       bios.asm:99
wbootin          = $F203 = 61955  _TEXT       bios.asm:22
wbootr           = $F25D = 62045  _TEXT       bios.asm:87
write            = $F30E = 62222  _TEXT       bios.asm:268
writeran         = $EF9C = 61340  _TEXT       bdos.asm:2049
wrtprt           = $F1AD = 61869  _TEXT       bdos.asm:2441
wrtprtd          = $E92C = 59692  _TEXT       bdos.asm:877
wrtseq           = $F0E6 = 61670  _TEXT       bdos.asm:2286
wtrandom         = $F147 = 61767  _TEXT       bdos.asm:2360
wtseq            = $EDFE = 60926  _TEXT       bdos.asm:1779
wtseq1           = $EE03 = 60931  _TEXT       bdos.asm:1781
wtseq10          = $EED2 = 61138  _TEXT       bdos.asm:1896
wtseq11          = $EEFE = 61182  _TEXT       bdos.asm:1920
wtseq12          = $EF00 = 61184  _TEXT       bdos.asm:1921
wtseq2           = $EE3B = 60987  _TEXT       bdos.asm:1804
wtseq3           = $EE48 = 61000  _TEXT       bdos.asm:1810
wtseq4           = $EE64 = 61028  _TEXT       bdos.asm:1822
wtseq5           = $EE6C = 61036  _TEXT       bdos.asm:1829
wtseq6           = $EE6E = 61038  _TEXT       bdos.asm:1830
wtseq7           = $EE8C = 61068  _TEXT       bdos.asm:1853
wtseq8           = $EE9A = 61082  _TEXT       bdos.asm:1860
wtseq9           = $EEBB = 61115  _TEXT       bdos.asm:1880
wtseq99          = $EEDF = 61151  _TEXT       bdos.asm:1907 (unused)
wtspecl          = $F19B = 61851  _TEXT       bdos.asm:2426
xlate            = $F1D0 = 61904  _TEXT       bdos.asm:2469


total time: 0.0715 sec.
no errors
