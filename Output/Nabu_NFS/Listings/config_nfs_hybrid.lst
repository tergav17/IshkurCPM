              	; --------------------------------------
              	; zasm: assemble "config_nfs_hybrid.asm"
              	; date: 2023-07-13 01:13:18
              	; --------------------------------------


              	;
              	;**************************************************************
              	;*
              	;*          I S H K U R   S Y S T E M   C O N F I G
              	;*
              	;*      This file contains points that should be modifed
              	;*      if new devices are to be added to IshkurCP/M. At
              	;*      a mimumum, they need to be included at the bottom
              	;*      of the file, and added to their appropriate dev
              	;*      switch. Some devices may need additional config
              	;*      directly in their source files
              	;*       
              	;*
              	;**************************************************************
              	;
              	;   Set default drive / user
              	;   (uuuudddd) where 'uuuu' is the user number and 'dddd' is the drive number.
              	;
0000:         	default	equ	0
              	
              	;
              	;**************************************************************
              	;*
              	;*                M E M O R Y   C O N F I G
              	;*
              	;*        CP/M memory will start at mem*1024. For example,
              	;*        if memory is configured to be 40, then the image
              	;*        will start at 40kb. The higher memory is configured
              	;*        to, the more memory user programs will have. If memory
              	;*        is configured to be too high, then the core image and
              	;*        BSS space will not fit.
              	;*
              	;**************************************************************
              	;
              	;
              	;   Set memory base here. 
              	;
0035:         	mem	equ	53		; CP/M image starts at mem*1024
              	
              	
              	
              	#target	BIN			; Set up memory segments
D400:         	#code	_TEXT,(mem)*1024
F95E:         	#data	_BSS,_TEXT_end
FDDE:         	#data	_NOINIT,_BSS_end
FF00:         	#data	_JUMP_TABLE,0xFF00
FF00: 00000000	intvec:	defs	16
FF04: 00...   	
FF10: 00000000	dircbuf:defs	128
FF14: 00...   	
              	.area	_TEXT
              	
              	; Include CP/M and BIOS
              	#include "../zcpr1_ccp_nfs.asm"
              	;**************************************************************
              	;*
              	;*         Z C P R 1   C O M M A N D   P R O C E S S O R
              	;*
              	;*          Adapted to work with Ishkur by snhirsch
              	;*
              	;**************************************************************
              	
0003:         	iobyte	equ	3		;i/o definition byte.
0004:         	tdrive	equ	4		;current drive name and user number.
0004:         	UDFLAG  equ     4
0005:         	entry	equ	5		;entry point for the cp/m bdos.
0005:         	BDOS    equ     5
005C:         	tfcb	equ	5ch		;default file control block.
005C:         	TFCB    equ     5ch
0080:         	TBUFF   equ     80h
0080:         	tbuff	equ	80h		;i/o buffer and command line storage.
0100:         	tbase	equ	100h		;transiant program storage area.
              	;
              	;   set control character equates.
              	;
0003:         	cntrlc	equ	3		;control-c
0005:         	cntrle	equ	05h		;control-e
0008:         	bs	equ	08h		;backspace
0009:         	tab	equ	09h		;tab
000A:         	lf	equ	0ah		;line feed
000C:         	ff	equ	0ch		;form feed
000D:         	cr	equ	0dh		;carriage return
0010:         	cntrlp	equ	10h		;control-p
0012:         	cntrlr	equ	12h		;control-r
0013:         	cntrls	equ	13h		;control-s
0015:         	cntrlu	equ	15h		;control-u
0018:         	cntrlx	equ	18h		;control-x
001A:         	cntrlz	equ	1ah		;control-z (end-of-file mark)
007F:         	del	equ	7fh		;rubout
              	
              	;================================================================
              	
              	;	.Z80
              	;	TITLE	'NZCPR V 1.6Z OF 01/07/84'
              	;  This is ZCPR Version 1.6 changed to Zilog mnemonics and put in a
              	;form suitable for the Microsoft M80 assembler. Note that the file uses
              	;the PHASE option to create the memory offset. The COM file should be 
              	;created using L80 with the /P:100 switch option. The COM file can be
              	;loaded into the sysgen program using the methods described in the ZCPR
              	;documentation.
              	;		MMA - Murray Arnow
              	;
              	;  CP/M Z80 Command Processor Replacement (CPR) Version 1.6 in
              	; the NZCPR line.
              	;
              	;	CCPZ CREATED AND CUSTOMIZED FOR ARIES-II BY RLC
              	;	ZCPR VERSION 1.0 CREATED FROM CCPZ VERSION 4.0 BY RLC IN
              	;		A COORDINATED EFFORT WITH CCP-GROUP
              	;
              	;	ZCPR is a group effort by CCP-GROUP, whose active membership involved
              	; in this project consists of the following:
              	;		RLC - Richard Conn
              	;		RGF - Ron Fowler
              	;		KBP - Keith Peterson
              	;		FJW - Frank Wancho
              	;	The following individuals also provided a contribution:
              	;		SBB - Steve Bogolub
              	;
              	;  Since RLC has decided that ZCPR V1.0 is the last official version
              	; sanctioned by the CCPZ group, changes beyond that point are being
              	; called by consensus of a group of new changers "NZCPR Vx.x". The
              	; following individuals have put in their code or opinions:
              	;
              	;		SBB - Steve Bogolub
              	;		PST - Paul Traina
              	;		HLB - Howard Booker
              	;		CAF - Chuck Forsberg
              	;		RAF - Bob Fischer
              	;		BB  - Ben Bronson
              	;		PRG - Paul Grupp
              	;		PJH - Paul Homchick
              	;		HEW - Hal Walchli
              	;
              	;   In an attempt to maintain a link to the past, changes between the
              	; current version of NZCPR are provided as both a difference file
              	; between NZCPR's (NZ14-16.DIF) and as a difference between the current
              	; version and the "official" ZCPR V1.0 (NZCPR-16.DIF).  These changes
              	; are made and supported by individuals in contact with each other through
              	; the Hyde Park RCPM in Chicago. Make comments or complaints there, to
              	; SBB or PST or anyone else interested.
              	;
              	;   The most obvious differences between NZCPR and ZCPR are the security
              	; features, controlled by additional conditional assembly flags. Such
              	; features restrict access to ZCPR intrinsic commands, add additional
              	; levels of .COM file searching, and prevent access to higher drives
              	; or user levels, with either internal or external password control of
              	; these features. Less obvious differences involve code optimization to
              	; gain space, and some minor bug fixes in the TYPE command.
              	;
              	;******** Structure Notes ********
              	;
              	;	This CPR is divided into a number of major sections.  The following
              	; is an outline of these sections and the names of the major routines
              	; located therein.
              	;
              	; Section	Function/Routines
              	; -------	-----------------
              	;
              	;   --		Opening Comments, Equates, and Macro Definitions
              	;
              	;    0		JMP Table into CPR
              	;
              	;    1		Buffers
              	;
              	;    2		CPR Starting Modules
              	;			CPR1	CPR	RESTRT	RSTCPR	RCPRNL
              	;			PRNNF	CMDTBL
              	;
              	;    3		Utilities
              	;			CRLF	CONOUT	CONIN	LCOUT	LSTOUT
              	;			READF	READ	BDOSB	PRINTC	PRINT
              	;			GETDRV	DEFDMA	DMASET	RESET	BDOSJP
              	;			LOGIN	OPENF	OPEN	GRBDOS	CLOSE
              	;			SEARF	SEAR1	SEARN	SUBKIL	DELETE
              	;			RESETUSR GETUSR	SETUSR	PAGER	UCASE
              	;			NOECHO
              	;
              	;     4		CPR Utilities
              	;			SETUD	SETU0D	REDBUF	CNVBUF	CMDSER
              	;			BREAK	USRNUM	ERROR	SDELM	ADVAN
              	;			SBLANK	ADDAH	NUMBER	NUMERR	HEXNUM
              	;			DIRPTR	SLOGIN	DLOGIN	COMLOG	SCANER
              	;
              	;     5		CPR-Resident Commands and Functions
              	;     5A		DIR	DIRPR	FILLQ
              	;     5B		ERA
              	;     5C		LIST
              	;     5D		TYPE
              	;     5E		SAVE
              	;     5F		REN
              	;     5G		USER
              	;     5H		DFU
              	;     5I		JUMP
              	;     5J		GO
              	;     5K		COM	CALLPROG	ERRLOG	ERRJMP
              	;     5L		GET	MEMLOAD	PRNLE
              	;     5M		PASS	NORM
              	;
              	;
0000:         	FALSE	EQU	0
00FF:         	TRUE	EQU	0FFh
              	;
              	;  CUSTOMIZATION EQUATES
              	;
              	;  The following equates may be used to customize this CPR for the user's
              	;    system and integration technique.  The following constants are provided:
              	;
              	;    REL - TRUE if integration is to be done via MOVCPM
              	;        - FALSE if integration is to be done via DDT and SYSGEN
              	;
              	;    SECURE -  TRUE to conditionally disable potentially-harmful
              	;	       commands (GO, ERA, SAVE, REN, DFU, GET, JUMP). Under
              	;	       SECURE, if WHEEL contains RESTRCT, do not accept those
              	;	       commands, and search for COM files under current user
              	;	       then user "DEFUSR" only. If WHEEL does not contain
              	;	       RESTRCT (presumably from passworded change), allow
              	;	       all commands, and search current user, then last user
              	;	       set by DFU (originally "RESUSR"), then user "DEFUSR"
              	;	       for COM files, giving access with password to an
              	;	       additional level of COM files.
              	;
              	;	       (Note: WHEEL must point to a safe place in memory that
              	;		won't be overlayed)
              	;
              	;	If you have chosen a SECURE system,  all resident commands may be
              	; activated by entering:  PASS <password> <cr>  Where <password> is a sequence
              	; of characters placed at PASSID (if INPASS is true, otherwise, see
              	; documentation in PST's PASS.ASM).  If the password is incorrect. the system
              	; will come back with PASS? as if it was looking for a COM file.
              	;	NORM is the reverse of PASS, it will disable the WHEEL mode.
              	;
              	;    INPASS -  If in the SECURE mode, you wish to use a program similar
              	;	       to PST's PASS.ASM, set this false, otherwise, ZCPR will
              	;	       handle the PASSword coding with a built in command.
              	;
              	;    DRUSER -  Set this EQU false if you wish to disable RAF's neat hack
              	;	       that allows you the type B: 7 to move to drive B: user area
              	;	       seven.  This also removes the USER command.  Basically, set
              	;	       this equate false if you want to use USERPW or some other pgm.
              	;
              	;    RAS    -  Remote-Access System; setting this equate to TRUE disables
              	;	       certain CPR commands that are considered harmful in a Remote-
              	;	       Access environment; use under Remote-Access Systems (RBBS) for
              	;	       security purposes.  Note: SECURE is the direct enemy of RAS,
              	;	       DON'T define both equates or you will be VERY sorry.
              	;	       The advantage SECURE has over RAS is that by saying a magic
              	;	       word, all of the normal commands pop into existance.
              	;
              	;    MAXDRIV - Maximum legal drive number stored in this location.
              	;	       (0 means only A:, etc.)  0000H disables this feature.
              	;	       The value MAXDR is stuffed into MAXDRIV at cold boot,
              	;	       and presumably will be changed later by a passworded
              	;	       program if desired.
              	;
              	;	       (This code is in addition to BIOS checks. It's needed here
              	;	       because X: can hang if X: is off line in some BIOS
              	;	       implementations. Personally, I think CAF and others should fix
              	;	       their BIOS instead. Mine works right...SBB).
              	;
              	;    USRMAX -  Maximum legal user # + 1 stored in this location. 0000H
              	;	       disables this feature, and uses the value of MAXUSR+1 instead.
              	;
              	;    BASE - Base Address of user's CP/M system (normally 0 for DR version)
              	;           This equate allows easy modification by non-standard CP/M (eg,H89)
              	;
              	;    CPRLOC - Base Page Address of CPR; this value can be obtained by running
              	;	      the BDOSLOC program on your system, or by setting the
              	;	      MSIZE and BIOSEX equates to the system memory size in
              	;	      K-bytes and the "extra" memory required by your BIOS
              	;	      in K-bytes. BIOSEX is zero if your BIOS is normal size,
              	;	      and can be negative if your BIOS is in PROM or in
              	;	      non-contiguous memory.
              	;
              	;    EPRMPT - Set TRUE to be prompted "OK?" after seeing what files will
              	;	      be erased. No, this is NOT for individual file prompting,
              	;	      it is just to confirm deletion of all selected files at once.
              	;
              	;  Various individuals keep trying to yank out the TYPE, LIST, and DIR
              	; commands, either to use the space for other options or just because
              	; they prefer replacement COM files. To these individuals, I (SBB) say
              	; keep your paws off these commands. For compatibility with the stock
              	; CCP, intrinsic DIR and TYPE commands are required. And many users in
              	; MY neighborhood find it more convenient to use the intrinsic LIST
              	; command than to have a LIST/PRINT program on every disk. If you want
              	; to call a transient program by an intrinsic, then CHANGE THE INTRINSIC
              	; NAME IN THE TABLE. Even setting the name to blanks is fine to get
              	; rid of it. The point is, don't remove features others may want, just
              	; because you disagree, then throw it back in our laps. For those who
              	; simply MUST be rid of these commands, the following symbols control
              	; generation of the code in a CLEAN ACCEPTABLE fashion that allows
              	; others to have these features:
              	;
              	;    CPRTYP -	Set to TRUE to generate code for intrinsic TYPE command.
              	;
              	;    WSTYPE -	Set to TRUE to generate an extra three lines of code
              	;		to correctly interpret the WordStar (tm) internal
              	;		end of line hyphen for display, which is the ASCII
              	;		NEWLINE code (1FH) and normally non-printing or
              	;		troublemaking -- thanks to PJH for this one. CPRTYP
              	;		must be TRUE, or this symbol will be ignored.
              	;
              	;    CPRLST -	Set to TRUE to generate code for intrinsic LIST command.
              	;		Since almost all of the LIST code is common to the
              	;		TYPE code, CPRTYP must be set TRUE as well, or this
              	;		symbol will be ignored.
              	;
              	;    CPRDIR -	Set to TRUE to generate code for intrinsic DIR command.
              	;		Note that unlike the various directory programs, a
              	;		restricted DIR command here allows displaying the names
              	;		of SYS file ONLY, so many RCPM operators WANT this code.
              	;
              	;  Remember, you only get a total of 2048 (0800H) bytes of space for
              	; ALL of the generated code, or many other areas of your system
              	; generation will be affected. For example, to be fully SECURE, you
              	; would set SECURE to TRUE, and define MAXDRIV and USRMAX, and maybe
              	; use the internal password by setting INPASS to TRUE (external is
              	; MUCH recommended for easier modification). Those options absolutely
              	; generate too much code unless either CPRTYP or CPRDIR or both are
              	; set FALSE. A system with SECURE set to FALSE is right on the edge,
              	; and requires a give and take on options to fit, i.e. you can have
              	; MAXDRIV and USRMAX with DIR and TYPE if you leave out LIST and
              	; querying on ERASE, and so on.
              	;
              	;***************************************************************************
              	;** Be careful when playing with different combinations of these equates. **
              	;** You might not have enough memory to some combinations.  Check this    **
              	;** if you have problems, if they still persist, gripe to me (PST).       **
              	;***************************************************************************
              	;
              	;REL	EQU	TRUE		;SET TO TRUE FOR MOVCPM INTEGRATION
              	;
              	;BASE	EQU	0		;BASE OF CP/M SYSTEM (SET FOR STANDARD CP/M)
              	;
              	;; 	IF	REL
              	;; CPRLOC	EQU	0		;MOVCPM IMAGE
              	;; 	ELSE
              	;; ;
              	;; ; If REL is FALSE, the value of CPRLOC may be set in one
              	;; ; of two ways.  The first way is to set MSIZE and BIOSEX
              	;; ; as described above using the following three lines:
              	;; ;
              	;; ;MSIZE	EQU	56		;SIZE OF MEM IN K-BYTES
              	;; ;BIOSEX	EQU	2		;EXTRA # K-BYTES IN BIOS
              	;; ;CPRLOC	EQU	3400H+(MSIZE-20-BIOSEX)*1024	;CPR ORIGIN
              	;; ;
              	;; ; The second way is to obtain the origin of your current
              	;; ; CPR using BDSLOC or its equivalent, then merely set CPRLOC
              	;; ; to that value as in the following line:
              	;; ;
              	;; CPRLOC	EQU	0C400H		;FILL IN WITH BDOSLOC SUPPLIED VALUE
              	;; ;
              	;; ; Note that you should only use one method or the other.
              	;; ; Do NOT define CPRLOC twice!
              	;; ;
              	;; ; The following gives the required offset to load the CPR into the
              	;; ; CP/M SYSGEN Image through DDT (the Roffset command); Note that this
              	;; ; value conforms with the standard value presented in the CP/M reference
              	;; ; manuals, but it may not necessarily conform with the location of the
              	;; ; CCP in YOUR CP/M system; several systems (Morrow Designs, P&T, Heath
              	;; ; Org-0 to name a few) have the CCP located at a non-standard address in
              	;; ; the SYSGEN Image
              	;; ;
              	;; CPRR	EQU	0E00H-CPRLOC	;DDT LOAD OFFSET FOR APPLE SOFTCARD 56K
              	;; ;CPRR	EQU	0980H-CPRLOC	;DDT LOAD OFFSET
              	;; ;CPRR	EQU	1600H-CPRLOC	;DDT LOAD OFFSET FOR COMPUPRO DISK-1
              	;; ;CPRR	EQU	1100H-CPRLOC	;DDT LOAD OFFSET FOR MORROW DESIGNS
              	;; 	ENDIF
              	;
0000:         	RAS	EQU	FALSE		;SET TO TRUE IF CPR IS FOR A REMOTE-ACCESS
              					; SYSTEM AND YOU DON'T WANT TO RUN SECURE
              					; (FOO...)
              	;
0000:         	USRMAX	EQU	0000H		;LOCATION OF BYTE IN MEMORY CONTAINING
              					; NUMBER OF HIGHEST ALLOWABLE USER CODE + 1
              					; THIS VALUE IS SET BY CPR ON COLD BOOT,
              					; AND PRESUMABLY CONTROLLED AFTER THAT
              					; BY A PASSWORD PROGRAM. IF USRMAX=0, THEN
              					; MAXUSR BELOW IS USED FOR CHECKING ONLY.
              					; 03FH IS RECOMMENDED IF USED  ***
0013:         	MAXUSR	EQU	19		;MAX ALLOWED USER NUMBER, THIS + 1 IS STUFFED
              					; INTO USRMAX ON COLD BOOT, OR USED DIRECTLY
              					; IF USRMAX=0
              	;
0000:         	MAXDRIV	EQU	0000H		;LOCATION THAT HAS MAX LEGAL DRIVE #
              					;SET IT TO ZERO TO DISABLE THIS CHECK
              					;03DH IS RECOMMENDED IF USED ***
0001:         	MAXDR	EQU	1		;MAX DRIVE # TO SET INTO MAXDRIV ON COLD BOOT
              	;
0000:         	SECURE	EQU	FALSE		;SET TRUE FOR SECURE ENVIRONMENT...
              	;
0000:         	DEFUSR	EQU	0		;DEFAULT USER FOR UNRESTRICTED COM FILES
              	;
              		IF	SECURE
              	WHEEL	EQU	3EH		;SET TO "RESTRCT" FOR LIMITED ACCESS
              	RESTRCT EQU	0		;WHEN (WHEEL)==RESTRCT, LIMIT COMMANDS
              	RESUSR	EQU	15		;CHECK HERE FOR RESTRICTED ACCESS COM FILES
              					; (LIKE PIP) UNTIL CHANGED BY DFU OR WARM BOOT
              		ENDIF			;SECURE
              	;
0000:         	INPASS	EQU	FALSE		;SET TRUE IF RUNNING SECURE AND NOT PASS.COM
              	;
00FF:         	DRUSER	EQU	TRUE		;TRUE TO ALLOW USER COMMAND AND DRIVE/USER HACK
              	;
0000:         	EPRMPT	EQU	FALSE		;TRUE TO PROMPT BEFORE ERASING ALL FILES
              	;
00FF:         	CPRTYP	EQU	TRUE		;TRUE TO GENERATE TYPE CODE
00FF:         	WSTYPE	EQU	TRUE		;TRUE TO GENERATE WORDSTAR HYPHEN CHECK (CPRTYP
              					; MUST BE TRUE TOO)
00FF:         	CPRLST	EQU	TRUE		;TRUE TO GENERATE LIST CODE (CPRTYP MUST BETRUE TOO)
00FF:         	CPRDIR	EQU	TRUE		;TRUE TO GENERATE DIR CODE
              	;
              	;  ***  Note to Apple Softcard Users  ***
              	;
              	;  In their infinite (?) wisdom (???), Microsoft decided that the way to
              	; get a two-column directory display instead of four-column (narrow 40-col
              	; screen, remember) was to have their BIOS poke CCP every time it was
              	; loaded, if there was no terminal interface card in I/O slot 3.
              	; Naturally, that will turn into a random poke on any non-standard
              	; CCP, like this one.  The best way to get this CPR up on the Apple is to
              	; load it into CPM56.COM, at location 0E00H in the image.  The BIOS code
              	; that pokes the CPR can also be modified at that time.  The poke is done
              	; by "STA 0C8B2H", found at 24FEH in the CPM56 image.  To keep this
              	; feature, change the 0C8B2H address in that instruction by hand to
              	; the value generated for the symbol TWOPOK in the DIR routine.  If
              	; you have assembled out the DIR code by setting CPRDIR to FALSE, then
              	; disable this feature by changing the "STA" to "LDA", i.e. set the
              	; contents of location 24FEH from 32H to 3AH. If you wish to force
              	; a two-column display in all cases, set the TWOCOL switch below to a
              	; value of TRUE, and disable the poke.
              	;
0000:         	TWOCOL	EQU	FALSE		;TRUE IF TWO COL DIR INSTEAD OF FOUR
              	;
              	; The following is presented as an option, but is not generally user-customiz-
              	; able.  A basic design choice had to be made in the design of ZCPR concerning
              	; the execution of SUBMIT files.  The original CCP had a problem in this sense
              	; in that it ALWAYS looked for the SUBMIT file from drive A: and the SUBMIT
              	; program itself (SUBMIT.COM) would place the $$$.SUB file on the currently
              	; logged-in drive, so when the user was logged into B: and he issued a SUBMIT
              	; command, the $$$.SUB was placed on B: and did not execute because the CCP
              	; looked for it on A: and never found it.
              	;
              	;	After much debate it was decided to have ZCPR perform the same type of
              	; function as CCP (look for the $$$.SUB file on A:), but the problem with
              	; SUBMIT.COM still exists.  Hence, RGF designed SuperSUB and RLC took his
              	; SuperSUB and designed SUB from it; both programs are set up to allow the
              	; selection at assembly time of creating the $$$.SUB on the logged-in drive
              	; or on drive A:.
              	;
              	;	A final definition of the Indirect Command File ($$$.SUB or SUBMIT
              	; File) is presented as follows:
              	;
              	;		"An Indirect Command File is one which contains
              	;		 a series of commands exactly as they would be
              	;		 entered from a CP/M Console.  The SUBMIT Command
              	;		 (or SUB Command) reads this files and transforms
              	;		 it for processing by the ZCPR (the $$$.SUB File).
              	;		 ZCPR will then execute the commands indicated
              	;		 EXACTLY as if they were typed at the Console."
              	;
              	;	Hence, to permit this to happen, the $$$.SUB file must always
              	; be present on a specific drive, and A: is the choice for said drive.
              	; With this facility engaged as such, Indirect Command Files like:
              	;
              	;		DIR
              	;		A:
              	;		DIR
              	;
              	; can be executed, even though the currently logged-in drive is changed
              	; during execution.  If the $$$.SUB file was present on the currently
              	; logged-in drive, the above series of commands would not work since the
              	; ZCPR would be looking for $$$.SUB on the logged-in drive, and switching
              	; logged-in drives without moving the $$$.SUB file as well would cause
              	; processing to abort.
              	;
00FF:         	SUBA	EQU	TRUE 		;Set to TRUE to have $$$.SUB always on A:
              					;Set to FALSE to have $$$.SUB on the
              					; logged-in drive
              	;
              	;   The following flag enables extended processing for user-program supplied
              	; command lines.  This is for Command Level 3 of ZCPR.  Under the current
              	; ZCPR philosophy, three command levels exist:
              	;
              	;	(1) that command issued by the user from his console at the '>' prompt
              	;	(2) that command issued by a $$$.SUB file at the '$' prompt
              	;	(3) that command issued by a user program by placing the command into
              	;	    CIBUFF and setting the character count in CBUFF
              	;
              	;   Setting CLEVEL3 to TRUE enables extended processing of the third level of
              	; ZCPR command.  All the user program need do is to store the command line and
              	; set the character count; ZCPR will initialize the pointers properly, store
              	; the ending zero properly, and capitalize the command line for processing.
              	; Once the command line is properly stored, the user executes the command line
              	; by reentering the ZCPR through CPRLOC [NOTE:  The C register MUST contain
              	; a valid User/Disk Flag (see location 4) at this time.]
              	;
00FF:         	CLEVEL3	EQU	TRUE		;ENABLE COMMAND LEVEL 3 PROCESSING
              	;
              	;
              	;*** TERMINAL AND 'TYPE' CUSTOMIZATION EQUATES
              	;
0018:         	NLINES	EQU	24		;NUMBER OF LINES ON CRT SCREEN
00FF:         	WIDE	EQU	TRUE		;TRUE IF WIDE DIR DISPLAY
007C:         	FENCE	EQU	'|'		;SEP CHAR BETWEEN DIR FILES
              	;
0000:         	PGDFLT	EQU	FALSE 		;SET TO FALSE TO DISABLE PAGING BY DEFAULT
0050:         	PGDFLG	EQU	'P'		;FOR TYPE COMMAND: PAGE OR NOT (DEP ON PGDFLT)
              					;  THIS FLAG REVERSES THE DEFAULT EFFECT
              	;
0041:         	SYSFLG	EQU	'A' 		;FOR DIR COMMAND: LIST $SYS AND $DIR
              	;
0053:         	SOFLG	EQU	'S'		;FOR DIR COMMAND: LIST $SYS FILES ONLY
              	;
0000:         	SUPRES	EQU	FALSE		;SUPRESSES USER # REPORT FOR USER 0
              	;
0024:         	SPRMPT	EQU	'$'		;CPR PROMPT INDICATING SUBMIT COMMAND
003E:         	CPRMPT	EQU	'>'		;CPR PROMPT INDICATING USER COMMAND
              	;
0048:         	NUMBASE	EQU	'H'		;CHARACTER USED TO SWITCH FROM DEFAULT
              					; NUMBER BASE
              	;
0053:         	SECTFLG	EQU	'S'		;OPTION CHAR FOR SAVE COMMAND TO SAVE SECTORS
              	;
              	; END OF CUSTOMIZATION SECTION
              	;
000D:         	CR	EQU	0DH
000A:         	LF	EQU	0AH
0009:         	TAB	EQU	09H
000C:         	FFEED	EQU	0CH
0007:         	BEL	EQU	07H
              	;
              	;; WBOOT	EQU	BASE+0000H		;CP/M WARM BOOT ADDRESS
              	;; UDFLAG	EQU	BASE+0004H		;USER NUM IN HIGH NYBBLE, DISK IN LOW
              	;; BDOS	EQU	BASE+0005H		;BDOS FUNCTION CALL ENTRY PT
              	;; TFCB	EQU	BASE+005CH		;DEFAULT FCB BUFFER
              	;; TBUFF	EQU	BASE+0080H		;DEFAULT DISK I/O BUFFER
              	;; TPA	EQU	BASE+0100H		;BASE OF TPA
              	
0100:         	TPA    EQU     100H
              	
              	;
              	;**** Section 0 ****
              	;
              	;	ORG	0100H
              	;	.PHASE	CPRLOC
              	;
              	;  ENTRY POINTS INTO ZCPR
              	;
              	;    If the ZCPR is entered at location CPRLOC (at the JMP to CPR), then
              	; the default command in CIBUFF will be processed.  If the ZCPR is entered
              	; at location CPRLOC+3 (at the JMP to CPR1), then the default command in
              	; CIBUFF will NOT be processed.
              	;
              	;    NOTE:  Entry into ZCPR in this way is permitted under this version,
              	; but in order for this to work, CIBUFF and CBUFF MUST be initialized properly
              	; AND the C register MUST contain a valid User/Disk Flag (see Location 4: the
              	; most significant nybble contains the User Number and the least significant
              	; nybble contains the Disk Number).
              	;
              	;    Some user programs (such as SYNONYM3) attempt to use the default
              	; command facility.  Under the original CCP, it was necessary to initialize
              	; the pointer after the reserved space for the command buffer to point to
              	; the first byte of the command buffer.  Under current versions, this is
              	; no longer the case.  The CIBPTR (Command Input Buffer PoinTeR) is located
              	; to be compatible with such programs (provided they determine the buffer
              	; length from the byte at MBUFF [CPRLOC + 6]), but under ZCPR this is
              	; no longer necessary, since this buffer pointer is automatically
              	; initialized in all cases.
              	;
D400:         	cbase:  
D400:         	ENTRY:
D400: C3C0D4  		JP	CPR		; Process potential default command, and set
              					; USRMAX to MAXUSR default
              	;	JP	CPR1		; Do NOT process potential default command
              	;	
              	;**** Section 1 ****
              	; BUFFERS ET AL
              	;
              	; INPUT COMMAND LINE AND DEFAULT COMMAND
              	;
              	;   The command line to be executed is stored here.  This command line
              	; is generated in one of three ways:
              	;
              	;	(1) by the user entering it through the BDOS READLN function at
              	;	    the du> prompt [user input from keyboard]
              	;	(2) by the SUBMIT File Facility placing it there from a $$$.SUB
              	;	    file
              	;	(3) by an external program or user placing the required command
              	;	    into this buffer
              	;
              	;   In all cases, the command line is placed into the buffer starting at
              	; CIBUFF.  This command line is terminated by the last character (NOT Carriage
              	; Return), and a character count of all characters in the command line
              	; up to and including the last character is placed into location CBUFF
              	; (immediately before the command line at CIBUFF).  The placed command line
              	; is then parsed, interpreted, and the indicated command is executed.
              	; If CLEVEL3 is permitted, a terminating zero is placed after the command
              	; (otherwise the user program has to place this zero) and the CIBPTR is
              	; properly initialized (otherwise the user program has to init this ptr).
              	; If the command is placed by a user program, entering at CPRLOC is enough
              	; to have the command processed.  Again, under the current ZCPR, it is not
              	; necessary to store the pointer to CIBUFF in CIBPTR; ZCPR will do this for
              	; the calling program if CLEVEL3 is made TRUE.
              	;
              	;   WARNING:  The command line must NOT exceed BUFLEN characters in length.
              	; For user programs which load this command, the value of BUFLEN can be
              	; obtained by examining the byte at MBUFF (CPRLOC + 6).
              	;
D403:         	inbuff: 
0050:         	BUFLEN	EQU	80		;MAXIMUM BUFFER LENGTH
D403:         	MBUFF:
D403: 50      		DEFB	BUFLEN		;MAXIMUM BUFFER LENGTH
D404:         	CBUFF:
D404: 00      		DEFB	0		;NUMBER OF VALID CHARS IN COMMAND LINE
              	
D405:         	CIBUFF:
D405: 494E4954	 	DEFM	'INIT '
D409: 20      	
D40A: FF      	        DEFB    255
D40B: 20202020	        DEFM    '        ';DEFAULT (COLD BOOT) COMMAND
D40F: 20202020	
              	;
              	;  The copyright notice from Digital Research is genned into the
              	; stock CCP at this location. It should be maintained in ZCPR,
              	; since Digital Research grants permission for ZCPR to exist.
              	;
D413: 2020434F		DEFM	'  COPYRIGHT (C) 1979, DIGITAL RESEARCH  '
D417: 50595249	
D41B: 47485420	
D41F: 28432920	
D423: 31393739	
D427: 2C204449	
D42B: 47495441	
D42F: 4C205245	
D433: 53454152	
D437: 43482020	
D43B:         	CIBUF:
D43B: 00      		DEFB	0		;COMMAND STRING TERMINATOR
D43C: 4E5A4350		DEFM	'NZCPR V 1.6 of'
D440: 52205620	
D444: 312E3620	
D448: 6F66    	
D44A: 2030382F		DEFM	' 08/03/82 '	;ZCPR ID FOR DISK DUMP
D44E: 30332F38	
D452: 3220    	
D454: 0000    	 	DEFS	BUFLEN-($-CIBUFF)+1	;TOTAL IS 'BUFLEN' BYTES
              	;
D456:         	CIBPTR:
D456: 05D4    		DEFW	CIBUFF		;POINTER TO COMMAND INPUT BUFFER
D458:         	CIPTR:
D458: 3BD4    		DEFW	CIBUF		;POINTER TO CURR COMMAND FOR
              					; ERROR REPORTING
              	;
D45A: 00000000		DEFS	26		;STACK AREA
D45E: 00...   	
D474:         	STACK	EQU	$		;TOP OF STACK
              	;
              	; FILE TYPE FOR COMMAND
              	;
D474:         	COMMSG:
D474: 434F4D  		DEFM	'COM'
              	;
              	; SUBMIT FILE CONTROL BLOCK
              	;
D477:         	SUBFCB:
              		IF	SUBA		;IF $$$.SUB ON A:
D477: 01      		DEFB	1		;DISK NAME SET TO DEFAULT TO DRIVE A:
              	;	ENDIF
              	;
              	;	IF	NOT SUBA	;IF $$$.SUB ON CURRENT DRIVE
              	        ELSE
              		DEFB	0		;DISK NAME SET TO DEFAULT TO CURRENT DRIVE
              		ENDIF
              	;
D478: 242424  		DEFM	'$$$'		;FILE NAME
D47B: 20202020		DEFM	'     '
D47F: 20      	
D480: 535542  		DEFM	'SUB'		;FILE TYPE
D483: 00      		DEFB	0		;EXTENT NUMBER
D484: 00      		DEFB	0		;S1
D485:         	SUBFS2:
D485: 00      		DEFS	1		;S2
D486:         	SUBFRC:
D486: 00      		DEFS	1		;RECORD COUNT
D487: 00000000		DEFS	16		;DISK GROUP MAP
D48B: 00...   	
D497:         	SUBFCR:
D497: 00      		DEFS	1		;CURRENT RECORD NUMBER
              	; COMMAND FILE CONTROL BLOCK
              	;
D498:         	FCBDN:
D498: 00      		DEFS	1		;DISK NAME
D499:         	FCBFN:
D499: 00000000		DEFS	8		;FILE NAME
D49D: 00000000	
D4A1:         	FCBFT:
D4A1: 000000  		DEFS	3		;FILE TYPE
D4A4: 00      		DEFS	1		;EXTENT NUMBER
D4A5: 0000    		DEFS	2		;S1 AND S2
D4A7: 00      		DEFS	1		;RECORD COUNT
D4A8:         	FCBDM:
D4A8: 00000000		DEFS	16		;DISK GROUP MAP
D4AC: 00...   	
D4B8:         	FCBCR:
D4B8: 00      		DEFS	1		;CURRENT RECORD NUMBER
              	;
              	; OTHER BUFFERS
              	;
D4B9:         	PAGCNT:
D4B9: 16      		DEFB	NLINES-2	;LINES LEFT ON PAGE
D4BA:         	CHRCNT:
D4BA: 00      		DEFB	0		;CHAR COUNT FOR TYPE
D4BB:         	QMCNT:
D4BB: 00      		DEFB	0		;QUESTION MARK COUNT FOR FCB TOKEN SCANNER
              	;
              	;
              	;**** Section 2 ****
              	; CPR STARTING POINTS.  NOTE THAT SOME CP/M IMPLEMENTATIONS
              	; REQUIRE THE COLD START ADDRESS TO BE IN THE STARTING PAGE
              	; OF THE CPR, FOR DYNAMIC CCP LOADING.  CMDTBL WAS MOVED FOR
              	; THIS REASON.
              	;
              	; SET USRMAX AND/OR MAXDRIV TO DEFAULT VALUES ON COLD BOOT
              	; IF REQUIRED. NOTE THAT SOME BIOS IMPLEMENTATIONS WILL END
              	; UP HERE INSTEAD OF AT THE WARM BOOT, DEFEATING PASSWORDING
              	; OF THESE OPTIONS. RECOMMEND SUCH A BIOS BE FIXED.
              	;
              		IF	USRMAX OR MAXDRIV
              	CPR:
              		IF	USRMAX
              		LD	A,MAXUSR+1	;SET USRMAX ON COLD BOOT
              		LD	(USRMAX),A
              		ENDIF			;USRMAX
              	;
              		IF	MAXDRIV
              		LD	A,MAXDR		;SET MAXDRIV ON COLD BOOT
              		LD	(MAXDRIV),A
              		ENDIF			;MAXDRIV
              	;
              		JR	CPR2		; THEN PROCEED
              		ENDIF			;USRMAX OR MAXDRIV
              	;
              	; START CPR AND DON'T PROCESS DEFAULT COMMAND STORED
              	;
D4BC:         	CPR1:
D4BC: AF      		XOR	A		;SET NO DEFAULT COMMAND
D4BD: 3204D4  		LD	(CBUFF),A
              	;
              	; START CPR AND POSSIBLY PROCESS DEFAULT COMMAND
              	;
              	; NOTE ON MODIFICATION BY RGF: BDOS RETURNS 0FFH IN
              	; ACCUMULATOR WHENEVER IT LOGS IN A DIRECTORY, IF ANY
              	; FILE NAME CONTAINS A '$' IN IT.  THIS IS NOW USED AS
              	; A CLUE TO DETERMINE WHETHER OR NOT TO DO A SEARCH
              	; FOR SUBMIT FILE, IN ORDER TO ELIMINATE WASTEFUL SEARCHES.
              	;
              		IF	USRMAX OR MAXDRIV
              	CPR2:
              		ELSE
D4C0:         	CPR:
              		ENDIF			;USRMAX OR MAXDRIV
              	;
D4C0: 3174D4  		LD	SP,STACK	;RESET STACK
D4C3: C5      		PUSH	BC
D4C4: 79      		LD	A,C		;C=USER/DISK NUMBER (SEE LOC 4)
D4C5: 1F      		RRA			;EXTRACT USER NUMBER
D4C6: 1F      		RRA
D4C7: 1F      		RRA
D4C8: 1F      		RRA
D4C9: E60F    		AND	0FH
D4CB: 5F      		LD	E,A		;SET USER NUMBER
D4CC: CD6AD6  		CALL	SETUSR
D4CF: CD2DD6  		CALL	RESET		;RESET DISK SYSTEM
              		;LD	(RNGSUB),A	;SAVE SUBMIT CLUE FROM DRIVE A:
D4D2: C1      		POP	BC
D4D3: 79      		LD	A,C		;C=USER/DISK NUMBER (SEE LOC 4)
D4D4: E60F    		AND	0FH		;EXTRACT DEFAULT DISK DRIVE
D4D6: 327ED6  		LD	(TDRIVE),A	;SET IT
D4D9: 2803    		JR	Z,NOLOG		;SKIP IF 0...ALREADY LOGGED
D4DB: CD32D6  		CALL	LOGIN		;LOG IN DEFAULT DISK
              	;
              		IF	SUBA	;IF $$$.SUB IS ON CURRENT DRIVE
              	        ELSE
              		LD	(RNGSUB),A	;BDOS '$' CLUE
              		ENDIF
              	;
D4DE:         	NOLOG:
D4DE: 1177D4  		LD	DE,SUBFCB	;CHECK FOR $$$.SUB ON CURRENT DISK
D4E2:         	batch:  EQU     $+1
D4E2:         	RNGSUB:	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
D4E1: 3E00    	        LD	A,0	        ;2ND BYTE (IMMEDIATE ARG) IS THE RNGSUB FLAG
D4E3: B7      		OR	A		;SET FLAGS ON CLUE
D4E4: 2F      		CPL			;PREPARE FOR COMING 'CPL'
D4E5: C44CD6  		CALL	NZ,SEAR1
D4E8: 2F      		CPL			;0FFH IS RETURNED IF NO $$$.SUB, SO COMPLEMENT
D4E9: 32E2D4  		LD	(RNGSUB),A	;SET FLAG (0=NO $$$.SUB)
D4EC: 3A04D4  		LD	A,(CBUFF)	;EXECUTE DEFAULT COMMAND?
D4EF: B7      		OR	A		;0=NO
D4F0: 2026    		JR	NZ,RS1
              	;
              	; PROMPT USER AND INPUT COMMAND LINE FROM HIM
              	;
D4F2:         	RESTRT:
D4F2: 3174D4  		LD	SP,STACK	;RESET STACK
              	;
              	; PRINT PROMPT (DU>)
              	;
D4F5: CDA1D5  		CALL	CRLF		;PRINT PROMPT
D4F8: CD22D6  		CALL	GETDRV		;CURRENT DRIVE IS PART OF PROMPT
D4FB: C641    		ADD	A,'A'		;CONVERT TO ASCII A-P
D4FD: CDA8D5  		CALL	CONOUT
D500: CD68D6  		CALL	GETUSR		;GET USER NUMBER
              	;
              		IF	SUPRES		;IF SUPPRESSING USR # REPORT FOR USR 0
              		OR	A
              		JR	Z,RS000
              		ENDIF
              	;
D503: FE0A    		CP	10		;USER < 10?
D505: 3809    		JR	C,RS00
D507: D60A    		SUB	10		;SUBTRACT 10 FROM IT
D509: F5      		PUSH	AF		;SAVE IT
D50A: 3E31    		LD	A,'1'		;OUTPUT 10'S DIGIT
D50C: CDA8D5  		CALL	CONOUT
D50F: F1      		POP	AF
D510:         	RS00:
D510: C630    		ADD	A,'0'		;OUTPUT 1'S DIGIT (CONVERT TO ASCII)
D512: CDA8D5  		CALL	CONOUT
              	;
              	; READ INPUT LINE FROM USER OR $$$.SUB
              	;
D515:         	RS000:
D515: CD83D6  		CALL	REDBUF		;INPUT COMMAND LINE FROM USER (OR $$$.SUB)
              	;
              	; PROCESS INPUT LINE
              	;
D518:         	RS1:
              	;
              		IF	CLEVEL3		;IF THIRD COMMAND LEVEL IS PERMITTED
D518: CDF0D6  		CALL	CNVBUF		;CAPITALIZE COMMAND LINE, PLACE ENDING 0,
              					; AND SET CIBPTR VALUE
              		ENDIF
              	;
D51B: CD26D6  		CALL	DEFDMA		;SET TBUFF TO DMA ADDRESS
D51E: CD22D6  		CALL	GETDRV		;GET DEFAULT DRIVE NUMBER
D521: 327ED6  		LD	(TDRIVE),A	;SET IT
D524: CD08D8  		CALL	SCANER		;PARSE COMMAND NAME FROM COMMAND LINE
D527: C417D7  		CALL	NZ,ERROR	;ERROR IF COMMAND NAME CONTAINS A '?'
D52A: 1140D5  		LD	DE,RSTCPR	;PUT RETURN ADDRESS OF COMMAND
D52D: D5      		PUSH	DE		;ON THE STACK
D52E: 3AFFD7  		LD	A,(TEMPDR)	;IS COMMAND OF FORM 'D:COMMAND'?
D531: B7      		OR	A		;NZ=YES
D532: C2F7DA  		JP	NZ,COM		; IMMEDIATELY
D535: CD87D8  		CALL	CMDSER		;SCAN FOR CPR-RESIDENT COMMAND
D538: C2F7DA  		JP	NZ,COM		;NOT CPR-RESIDENT
D53B: 7E      		LD	A,(HL)		;FOUND IT:  GET LOW-ORDER PART
D53C: 23      		INC	HL		;GET HIGH-ORDER PART
D53D: 66      		LD	H,(HL)		;STORE HIGH
D53E: 6F      		LD	L,A		;STORE LOW
D53F: E9      		JP	(HL)		;EXECUTE CPR ROUTINE
              	;
              	; ENTRY POINT FOR RESTARTING CPR AND LOGGING IN DEFAULT DRIVE
              	;
D540:         	RSTCPR:
D540: CDF4D7  		CALL	DLOGIN		;LOG IN DEFAULT DRIVE
              	;
              	; ENTRY POINT FOR RESTARTING CPR WITHOUT LOGGING IN DEFAULT DRIVE
              	;
D543:         	RCPRNL:
D543: CD08D8  		CALL	SCANER		;EXTRACT NEXT TOKEN FROM COMMAND LINE
D546: 3A99D4  		LD	A,(FCBFN)	;GET FIRST CHAR OF TOKEN
D549: D620    		SUB	' '		;ANY CHAR?
D54B: 21FFD7  		LD	HL,TEMPDR
D54E: B6      		OR	(HL)
D54F: C217D7  		JP	NZ,ERROR
D552: 189E    		JR	RESTRT
              	;
              	; No File Error Message
              	;
D554:         	PRNNF:
D554: CD0AD6  		CALL	PRINTC		;NO FILE MESSAGE
D557: 4E6F2046		DEFM	'No Fil'
D55B: 696C    	
D55D: E5      		DEFB	'e'+80H
D55E: C9      		RET
              	;
              	; CPR BUILT-IN COMMAND TABLE
              	;
0004:         	NCHARS	EQU	4		;NUMBER OF CHARS/COMMAND
              	;
              	; CPR COMMAND NAME TABLE
              	;   EACH TABLE ENTRY IS COMPOSED OF THE 4-BYTE COMMAND AND 2-BYTE ADDRESS
              	;
D55F:         	CMDTBL:
              	;
              		IF	INPASS AND SECURE
              		DEFM	'PASS'		;ENABLE WHEEL (SYSOP) MODE
              		DEFW	PASS
              		ENDIF			;INPASS AND SECURE
              	;
              		IF	DRUSER
D55F: 55534552		DEFM	'USER'		;CHANGE USER AREAS
D563: DBDA    		DEFW	USER
              		ENDIF			;DRUSER
              	;
              		IF	CPRTYP
D565: 54595045		DEFM	'TYPE'		;TYPE A FILE TO CON:
D569: 85D9    		DEFW	TYPE
              		ENDIF			;CPRTYP
              	;
              		IF	CPRDIR
D56B: 44495220		DEFM	'DIR '		;PULL A DIRECTORY OF DISK FILES
D56F: A9D8    		DEFW	DIR
              		ENDIF			;CPRDIR
              	
0003:         	NRCMDS	EQU	($-CMDTBL)/(NCHARS+2)
              					;PUT ANY COMMANDS THAT ARE OK TO
              					;RUN WHEN NOT UNDER WHEEL MODE
              					;IN FRONT OF THIS LABEL
              		IF	CPRLST AND CPRTYP
D571: 4C495354		DEFM	'LIST'		;LIST FILE TO PRINTER
D575: 81D9    		DEFW	LIST
              		ENDIF			;CPRLST AND CPRTYP
              	;
              		IF	INPASS AND SECURE
              		DEFM	'NORM'		;DISABLE WHEEL MODE
              		DEFW	NORM
              		ENDIF			;INPASS AND SECURE
              	;
              		IF	RAS		;FOR NON-RAS
              	        ELSE
D577: 474F2020		DEFM	'GO  '		;JUMP TO 100H
D57B: F2DA    		DEFW	GO
D57D: 45524120		DEFM	'ERA '		;ERASE FILE
D581: 5AD9    		DEFW	ERA
D583: 53415645		DEFM	'SAVE'		;SAVE MEMORY IMAGE TO DISK
D587: 12DA    		DEFW	SAVE
D589: 52454E20		DEFM	'REN '		;RENAME FILE
D58D: 97DA    		DEFW	REN
D58F: 44465520		DEFM	'DFU '		;SET DEFAULT USER
D593: E5DA    		DEFW	DFU
D595: 47455420		DEFM	'GET '		;LOAD FILE INTO MEMORY
D599: 97DB    		DEFW	GET
D59B: 4A554D50		DEFM	'JUMP'		;JUMP TO LOCATION IN MEMORY
D59F: EDDA    		DEFW	JUMP
              		ENDIF			;RAS
              	;
000B:         	NCMNDS	EQU	($-CMDTBL)/(NCHARS+2)
              	;
              	;**** Section 3 ****
              	; I/O UTILITIES
              	;
              	; OUTPUT CHAR IN REG A TO CONSOLE AND DON'T CHANGE BC
              	;
              	;
              	; OUTPUT <CRLF>
              	;
D5A1:         	CRLF:
D5A1: 3E0D    		LD	A,CR
D5A3: CDA8D5  		CALL	CONOUT
D5A6: 3E0A    		LD	A,LF		;FALL THRU TO CONOUT
              	;
D5A8:         	CONOUT:
D5A8: C5      		PUSH	BC
D5A9: 0E02    		LD	C,02H
D5AB:         	OUTPUT:
D5AB: E67F    		AND	7FH		;PREVENT INADVERTANT GRAPHIC OUTPUT
              					; TO EPSON-TYPE PRINTERS
D5AD: 5F      		LD	E,A
D5AE: E5      		PUSH	HL
D5AF: CD0500  		CALL	BDOS
D5B2: E1      		POP	HL
D5B3: C1      		POP	BC
D5B4: C9      		RET
              	;
D5B5:         	CONIN:
D5B5: 0E01    		LD	C,01H		;GET CHAR FROM CON: WITH ECHO
D5B7: CD03D6  		CALL	BDOSB
              	;
              	; CONVERT CHAR IN A TO UPPER CASE
              	;
D5BA:         	UCASE:
D5BA: FE61    		CP	61H		;LOWER-CASE A
D5BC: D8      		RET	C
D5BD: FE7B    		CP	7BH		;GREATER THAN LOWER-CASE Z?
D5BF: D0      		RET	NC
D5C0: E65F    		AND	5FH		;CAPITALIZE
D5C2: C9      		RET
              	;
D5C3:         	NOECHO:
D5C3: D5      		PUSH	DE		;SAVE D
D5C4: 0E06    		LD	C,6		;DIRECT CONSOLE I/O
D5C6: 1EFF    		LD	E,0FFH		;INPUT
D5C8: CD03D6  		CALL	BDOSB
D5CB: D1      		POP	DE
D5CC: B7      		OR	A		;DID WE GET A CHAR?
D5CD: 28F4    		JR	Z,NOECHO	;WAIT FOR IT IF NOT, IT'S EXPECTED
D5CF: C9      		RET
              	;
              		IF	CPRTYP
D5D0:         	LCOUT:
              		ENDIF			;CPRTYP
              	;
              		IF	CPRTYP AND CPRLST
D5D0: F5      		PUSH	AF		;OUTPUT CHAR TO CON: OR LST: DEP ON PRFLG
D5D2:         	PRFLG	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
D5D1: 3E00    		LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS THE PRINT FLAG
D5D3: B7      		OR	A		;0=TYPE
D5D4: 2806    		JR	Z,LC1
D5D6: F1      		POP	AF		;GET CHAR
              	;
              	; OUTPUT CHAR IN REG A TO LIST DEVICE
              	;
D5D7:         	LSTOUT:
D5D7: C5      		PUSH	BC
D5D8: 0E05    		LD	C,05H
D5DA: 18CF    		JR	OUTPUT
D5DC:         	LC1:
D5DC: F1      		POP	AF		;GET CHAR
              		ENDIF			;CPRTYP AND CPRLST
              	;
              		IF	CPRTYP
D5DD: F5      		PUSH	AF
D5DE: CDA8D5  		CALL	CONOUT		;OUTPUT TO CON:
D5E1: F1      		POP	AF
D5E2: FE0A    		CP	LF		;CHECK FOR PAGING
D5E4: C0      		RET	NZ		;DONE IF NOT EOL YET
              	;
              	;  COUNT DOWN LINES AND PAUSE FOR INPUT (DIRECT) IF COUNT EXPIRES
              	;
D5E5: E5      		PUSH	HL
D5E6: 21B9D4  		LD	HL,PAGCNT	;COUNT DOWN
D5E9: 35      		DEC	(HL)
D5EA: 2010    		JR	NZ,PGBAK	;JUMP IF NOT END OF PAGE
D5EC: 3616    		LD	(HL),NLINES-2	;REFILL COUNTER
              	;
D5EF:         	PGFLG	EQU	$+1		;POINTER TO IN-THE-CODE BUFFER PGFLG
D5EE: 3E00    		LD	A,0		;0 MAY BE CHANGED BY PGFLG EQUATE
D5F0: FE50    		CP	PGDFLG		;PAGE DEFAULT OVERRIDE OPTION WANTED?
              	;
              		IF	PGDFLT		;IF PAGING IS DEFAULT
              		JR	Z,PGBAK		;  PGDFLG MEANS NO PAGING, PLEASE
              		ELSE			;IF PAGING NOT DEFAULT
D5F2: 2008    		JR	NZ,PGBAK	;  PGDFLG MEANS PLEASE PAGINATE
              		ENDIF
              	;
D5F4: CDC3D5  		CALL	NOECHO		;GET CHAR BUT DON'T ECHO TO SCREEN
D5F7: FE03    		CP	'C'-'@' 	;^C
D5F9: CA40D5  		JP	Z,RSTCPR	;RESTART CPR
D5FC:         	PGBAK:
D5FC: E1      		POP	HL		;RESTORE HL
D5FD: C9      		RET
              		ENDIF			;CPRTYP
              	;
D5FE:         	READF:
D5FE: 1198D4  		LD	DE,FCBDN 	;FALL THRU TO READ
D601:         	READ:
D601: 0E14    		LD	C,14H		;FALL THRU TO BDOSB
              	;
              	; CALL BDOS AND SAVE BC
              	;
D603:         	BDOSB:
D603: C5      		PUSH	BC
D604: CD0500  		CALL	BDOS
D607: C1      		POP	BC
D608: B7      		OR	A
D609: C9      		RET
              	;
              	; PRINT STRING ENDING WITH ZERO BYTE OR CHAR WITH HIGH BIT SET
              	; PT'ED TO BY RET ADDR, START WITH <CR><LF>
              	;
D60A:         	PRINTC:
D60A: F5      		PUSH	AF		;SAVE FLAGS
D60B: CDA1D5  		CALL	CRLF		;NEW LINE
D60E: F1      		POP	AF
              	;
D60F:         	PRINT:
D60F: E3      		EX	(SP),HL		;GET PTR TO STRING
D610: F5      		PUSH	AF		;SAVE FLAGS
D611: CD17D6  		CALL	PRIN1		;PRINT STRING
D614: F1      		POP	AF		;GET FLAGS
D615: E3      		EX	(SP),HL		;RESTORE HL AND RET ADR
D616: C9      		RET
              	;
              	; PRINT STRING ENDING WITH ZERO BYTE OR CHAR WITH HIGH BIT SET
              	; PT'ED TO BY HL
              	;
D617:         	PRIN1:
D617: 7E      		LD	A,(HL)		;GET NEXT BYTE
D618: CDA8D5  		CALL	CONOUT		;PRINT CHAR
D61B: 7E      		LD	A,(HL)		;GET NEXT BYTE AGAIN FOR TEST
D61C: 23      		INC	HL		;PT TO NEXT BYTE
D61D: B7      		OR	A		;SET FLAGS
D61E: C8      		RET	Z		;DONE IF ZERO
D61F: F8      		RET	M		;DONE IF MSB SET
D620: 18F5    		JR	PRIN1
              	;
              	; BDOS FUNCTION ROUTINES
              	;
              	;
              	; RETURN NUMBER OF CURRENT DISK IN A
              	;
D622:         	GETDRV:
D622: 0E19    		LD	C,19H
D624: 1809    		JR	BDOSJP
              	;
              	; SET 80H AS DMA ADDRESS
              	;
D626:         	DEFDMA:
D626: 118000  		LD	DE,TBUFF 	;80H=TBUFF
D629:         	DMASET:
D629: 0E1A    		LD	C,1AH
D62B: 1802    		JR	BDOSJP
              	;
D62D:         	RESET:
D62D: 0E0D    		LD	C,0DH
D62F:         	BDOSJP:
D62F: C30500  		JP	BDOS
              	;
D632:         	LOGIN:
D632: 5F      		LD	E,A		;MOVE DESIRED # TO BDOS REG
              	;
              		IF	MAXDRIV
              		LD	A,(MAXDRIV)	;CHECK FOR LEGAL DRIVE #
              		CP	E
              		JP	C,ERROR		;DON'T DO IT IF TOO HIGH
              		ENDIF			;MAXDRIV
              	;
D633: 0E0E    		LD	C,0EH
D635: 18F8    		JR	BDOSJP		;SAVE SOME CODE SPACE
              	;
D637:         	OPENF:
D637: AF      		XOR	A
D638: 32B8D4  		LD	(FCBCR),A
D63B: 1198D4  		LD	DE,FCBDN 	;FALL THRU TO OPEN
              	;
D63E:         	OPEN:
D63E: 0E0F    		LD	C,0FH		;FALL THRU TO GRBDOS
              	;
D640:         	GRBDOS:
D640: CD0500  		CALL	BDOS
D643: 3C      		INC	A		;SET ZERO FLAG FOR ERROR RETURN
D644: C9      		RET
              	;
D645:         	CLOSE:
D645: 0E10    		LD	C,10H
D647: 18F7    		JR	GRBDOS
              	;
D649:         	SEARF:
D649: 1198D4  		LD	DE,FCBDN 	;SPECIFY FCB
D64C:         	SEAR1:
D64C: 0E11    		LD	C,11H
D64E: 18F0    		JR	GRBDOS
              	;
D650:         	SEARN:
D650: 0E12    		LD	C,12H
D652: 18EC    		JR	GRBDOS
              	;
              	; CHECK FOR SUBMIT FILE IN EXECUTION AND ABORT IT IF SO
              	;
D654:         	SUBKIL:
D654: 21E2D4  		LD	HL,RNGSUB	;CHECK FOR SUBMIT FILE IN EXECUTION
D657: 7E      		LD	A,(HL)
D658: B7      		OR	A		;0=NO
D659: C8      		RET	Z
D65A: 3600    		LD	(HL),0		;ABORT SUBMIT FILE
D65C: 1177D4  		LD	DE,SUBFCB	;DELETE $$$.SUB
              	;
D65F:         	DELETE:
D65F: 0E13    		LD	C,13H
D661: 18CC    		JR	BDOSJP		;SAVE MORE SPACE
              	;
              	; RESET USER NUMBER IF CHANGED
              	;
D663:         	RESETUSR:
D664:         	TMPUSR	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
D663: 3E00    		LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS TMPUSR
D665: 5F      		LD	E,A		;PLACE IN E
D666: 1802    		JR	SETUSR		;THEN GO SET USER
D668:         	GETUSR:
D668: 1EFF    		LD	E,0FFH		;GET CURRENT USER NUMBER
D66A:         	SETUSR:
D66A: 0E20    		LD	C,20H		;SET USER NUMBER TO VALUE IN E (GET IF E=FFH)
D66C: 18C1    		JR	BDOSJP		;MORE SPACE SAVING
              	;
              	; END OF BDOS FUNCTIONS
              	;
              	;
              	;**** Section 4 ****
              	; CPR UTILITIES
              	;
              	; SET USER/DISK FLAG TO CURRENT USER AND DEFAULT DISK
              	;
D66E:         	SETUD:
D66E: CD68D6  		CALL	GETUSR		;GET NUMBER OF CURRENT USER
D671: 87      		ADD	A,A		;PLACE IT IN HIGH NYBBLE
D672: 87      		ADD	A,A
D673: 87      		ADD	A,A
D674: 87      		ADD	A,A
D675: 217ED6  		LD	HL,TDRIVE	;MASK IN DEFAULT DRIVE NUMBER (LOW NYBBLE)
D678: B6      		OR	(HL)		;MASK IN
D679: 320400  		LD	(UDFLAG),A	;SET USER/DISK NUMBER
D67C: C9      		RET
              	;
              	; SET USER/DISK FLAG TO USER 0 AND DEFAULT DISK
              	;
D67D:         	SETU0D:
D67E:         	TDRIVE	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
D67D: 3E00    		LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS TDRIVE
D67F: 320400  		LD	(UDFLAG),A	;SET USER/DISK NUMBER
D682: C9      		RET
              	;
              	; INPUT NEXT COMMAND TO CPR
              	;	This routine determines if a SUBMIT file is being processed
              	; and extracts the command line from it if so or from the user's console
              	;
D683:         	REDBUF:
D683: 3AE2D4  		LD	A,(RNGSUB)	;SUBMIT FILE CURRENTLY IN EXECUTION?
D686: B7      		OR	A		;0=NO
D687: 2851    		JR	Z,RB1		;GET LINE FROM CONSOLE IF NOT
D689: 1177D4  		LD	DE,SUBFCB	;OPEN $$$.SUB
D68C: CD3ED6  		CALL	OPEN
D68F: 2849    		JR	Z,RB1		;ERASE $$$.SUB IF END OF FILE AND GET CMND
D691: 3A86D4  		LD	A,(SUBFRC)	;GET VALUE OF LAST RECORD IN FILE
D694: 1177D4  	REDBUF0:LD	DE,SUBFCB
D697: 3D      		DEC	A		;PT TO NEXT TO LAST RECORD
D698: 3297D4  		LD	(SUBFCR),A	;SAVE NEW VALUE OF LAST RECORD IN $$$.SUB
D69B: F5      		PUSH	AF
D69C: CD01D6  		CALL	READ		;DE=SUBFCB
D69F: C1      		POP	BC
D6A0: 2038    		JR	NZ,RB1		;ABORT $$$.SUB IF ERROR IN READING LAST REC
D6A2: 218000  		LD	HL,TBUFF
D6A5: AF      		XOR	A
D6A6: BE      		CP	(HL)
D6A7: 78      		LD	A,B
D6A8: 28EA    		JR	Z,REDBUF0
D6AA: 1104D4  		LD	DE,CBUFF 	;COPY LAST RECORD (NEXT SUBMIT CMND) TO CBUFF FROM TBUFF
D6AD: E5      		PUSH	HL
D6AE: 015000  		LD	BC,BUFLEN	;NUMBER OF BYTES
D6B1: EDB0    		LDIR
D6B3: E1      		POP	HL
D6B4: 71      		LD	(HL),C
D6B5: 2197D4  		LD	HL,SUBFCR
D6B8: 35      		DEC	(HL)
D6B9: 1177D4  		LD	DE,SUBFCB	
D6BC: D5      		PUSH	DE
D6BD: 0E15    		LD	C,15H
D6BF: CD0500  		CALL	BDOS		; SCRATCH OFF COMMAND
D6C2: D1      		POP	DE
D6C3: CD45D6  		CALL	CLOSE		;CLOSE $$$.SUB
              	;	JR	Z,RB1		;ABORT $$$.SUB IF ERROR (PROBABLY NOT GOING TO HIT THIS ONE)
D6C6: 3E24    		LD	A,SPRMPT	;PRINT SUBMIT PROMPT
D6C8: CDA8D5  		CALL	CONOUT
D6CB: 2105D4  		LD	HL,CIBUFF	;PRINT COMMAND LINE FROM $$$.SUB
D6CE: CD17D6  		CALL	PRIN1
D6D1: CD06D7  		CALL	BREAK		;CHECK FOR ABORT (ANY CHAR)
              	;
              		IF	CLEVEL3		;IF THIRD COMMAND LEVEL IS PERMITTED
D6D4: C8      		RET	Z		;IF <NULL> (NO ABORT), RETURN TO CALLER AND RUN
              		ENDIF
              	;
              		IF	CLEVEL3	;IF THIRD COMMAND LEVEL IS NOT PERMITTED
              	        ELSE
              		JR	Z,CNVBUF	;IF <NULL> (NO ABORT), CAPITALIZE COMMAND
              		ENDIF
              	;
D6D5: CD54D6  		CALL	SUBKIL		;KILL $$$.SUB IF ABORT
D6D8: 1857    		JR	RESTTMP		;RESTART CPR
              	;
              	; INPUT COMMAND LINE FROM USER CONSOLE
              	;
D6DA:         	RB1:
D6DA: CD54D6  		CALL	SUBKIL		;ERASE $$$.SUB IF PRESENT
D6DD: CD6ED6  		CALL	SETUD		;SET USER AND DISK
D6E0: 3E3E    		LD	A,CPRMPT	;PRINT PROMPT
D6E2: CDA8D5  		CALL	CONOUT
D6E5: 0E0A    		LD	C,0AH		;READ COMMAND LINE FROM USER
D6E7: 1103D4  		LD	DE,MBUFF
D6EA: CD0500  		CALL	BDOS
              	;
              		IF	CLEVEL3		;IF THIRD COMMAND LEVEL IS PERMITTED
D6ED: C37DD6  		JP	SETU0D		;SET CURRENT DISK NUMBER IN LOWER PARAMS
              		ENDIF
              	;
              		IF	CLEVEL3	;IF THIRD COMMAND LEVEL IS NOT PERMITTED
              	        ELSE
              		CALL	SETU0D		;SET CURRENT DISK NUMBER IF LOWER PARAMS
              					; AND FALL THRU TO CNVBUF
              		ENDIF
              	;
              	; CAPITALIZE STRING (ENDING IN 0) IN CBUFF AND SET PTR FOR PARSING
              	;
D6F0:         	CNVBUF:
D6F0: 2104D4  		LD	HL,CBUFF 	;PT TO USER'S COMMAND
D6F3: 46      		LD	B,(HL)		;CHAR COUNT IN B
D6F4: 04      		INC	B		;ADD 1 IN CASE OF ZERO
D6F5:         	CB1:
D6F5: 23      		INC	HL		;PT TO 1ST VALID CHAR
D6F6: 7E      		LD	A,(HL)		;CAPITALIZE COMMAND CHAR
D6F7: CDBAD5  		CALL	UCASE
D6FA: 77      		LD	(HL),A
D6FB: 10F8    		DJNZ	CB1		;CONTINUE TO END OF COMMAND LINE
D6FD:         	CB2:
D6FD: 3600    		LD	(HL),0		;STORE ENDING <NULL>
D6FF: 2105D4  		LD	HL,CIBUFF	;SET COMMAND LINE PTR TO 1ST CHAR
D702: 2256D4  		LD	(CIBPTR),HL
D705: C9      		RET
              	;
              	; CHECK FOR ANY CHAR FROM USER CONSOLE;RET W/ZERO SET IF NONE
              	;
D706:         	BREAK:
D706: D5      		PUSH	DE		;SAVE DE
D707: 0E0B    		LD	C,11		;CSTS CHECK
D709: CD03D6  		CALL	BDOSB
D70C: C4B5D5  		CALL	NZ,CONIN	;GET INPUT CHAR
D70F:         	BRKBK:
D70F: D1      		POP	DE
D710: C9      		RET
              	;
              	; GET THE REQUESTED USER NUMBER FROM THE COMMAND LINE AND VALIDATE IT.
              	;
D711:         	USRNUM:		
D711: CD63D7  		CALL	NUMBER
              	;
              		IF	USRMAX
              		LD	HL,USRMAX 	;PT TO MAXUSR + 1
              		CP	(HL)		;NEW VALUE ALLOWED?
              		ELSE
D714: FE14    		CP	MAXUSR+1 	;NEW VALUE ALLOWED?
              		ENDIF			;USRMAX
              	;
D716: D8      		RET	C		;RETURN TO CALLER IF SO,
              					; ELSE FLAG AS ERROR
              	;
              	; INVALID COMMAND -- PRINT IT
              	;
D717:         	ERROR:
D717: CDA1D5  		CALL	CRLF		;NEW LINE
D71A: 2A58D4  		LD	HL,(CIPTR)	;PT TO BEGINNING OF COMMAND LINE
D71D:         	ERR2:
D71D: 7E      		LD	A,(HL)		;GET CHAR
D71E: FE21    		CP	' '+1		;SIMPLE '?' IF <SP> OR LESS
D720: 3808    		JR	C,ERR1
D722: E5      		PUSH	HL		;SAVE PTR TO ERROR COMMAND CHAR
D723: CDA8D5  		CALL	CONOUT		;PRINT COMMAND CHAR
D726: E1      		POP	HL		;GET PTR
D727: 23      		INC	HL		;PT TO NEXT
D728: 18F3    		JR	ERR2		;CONTINUE
D72A:         	ERR1:
D72A: CD0FD6  		CALL	PRINT		;PRINT '?'
D72D: BF      		DEFB	'?'+80H
D72E: CD54D6  		CALL	SUBKIL		;TERMINATE ACTIVE $$$.SUB IF ANY
D731: C3F2D4  	RESTTMP:JP	RESTRT		;RESTART CPR
              	;
              	; CHECK TO SEE IF DE PTS TO DELIMITER; IF SO, RET W/ZERO FLAG SET
              	;
D734:         	SDELM:
D734: 1A      		LD	A,(DE)
D735: B7      		OR	A		;0=DELIMITER
D736: C8      		RET	Z
D737: FE20    		CP	' '		;ERROR IF < <SP>
D739: 38DC    		JR	C,ERROR
D73B: C8      		RET	Z			;<SP>=DELIMITER
D73C: FE3D    		CP	'='		;'='=DELIMITER
D73E: C8      		RET	Z
D73F: FE5F    		CP	5FH		;UNDERSCORE=DELIMITER
D741: C8      		RET	Z
D742: FE2E    		CP	'.'		;'.'=DELIMITER
D744: C8      		RET	Z
D745: FE3A    		CP	':'		;':'=DELIMITER
D747: C8      		RET	Z
D748: FE3B    		CP	';'		;';'=DELIMITER
D74A: C8      		RET	Z
D74B: FE3C    		CP	'<'		;'<'=DELIMITER
D74D: C8      		RET	Z
D74E: FE3E    		CP	'>'		;'>'=DELIMITER
D750: C9      		RET
              	;
              	; ADVANCE INPUT PTR TO FIRST NON-BLANK AND FALL THROUGH TO SBLANK
              	;
D751:         	ADVAN:
D751: ED5B56D4		LD	DE,(CIBPTR)
              	;
              	; SKIP STRING PTED TO BY DE (STRING ENDS IN 0) UNTIL END OF STRING
              	;   OR NON-BLANK ENCOUNTERED (BEGINNING OF TOKEN)
              	;
D755:         	SBLANK:
D755: 1A      		LD	A,(DE)
D756: B7      		OR	A
D757: C8      		RET	Z
D758: FE20    		CP	' '
D75A: C0      		RET	NZ
D75B: 13      		INC	DE
D75C: 18F7    		JR	SBLANK
              	;
              	; ADD A TO HL (HL=HL+A)
              	;
D75E:         	ADDAH:
D75E: 85      		ADD	A,L
D75F: 6F      		LD	L,A
D760: D0      		RET	NC
D761: 24      		INC	H
D762: C9      		RET
              	;
              	; EXTRACT DECIMAL NUMBER FROM COMMAND LINE
              	;   RETURN WITH VALUE IN REG A;ALL REGISTERS MAY BE AFFECTED
              	;
D763:         	NUMBER:
D763: CD08D8  		CALL	SCANER		;PARSE NUMBER AND PLACE IN FCBFN
D766: 21A3D4  		LD	HL,FCBFN+10 	;PT TO END OF TOKEN FOR CONVERSION
D769: 060B    		LD	B,11		;11 CHARS MAX
              	;
              	; CHECK FOR SUFFIX FOR HEXADECIMAL NUMBER
              	;
D76B:         	NUMS:
D76B: 7E      		LD	A,(HL)		;GET CHARS FROM END, SEARCHING FOR SUFFIX
D76C: 2B      		DEC	HL		;BACK UP
D76D: FE20    		CP	' '		;SPACE?
D76F: 2004    		JR	NZ,NUMS1	;CHECK FOR SUFFIX
D771: 10F8    		DJNZ	NUMS		;COUNT DOWN
D773: 1804    		JR	NUM0		;BY DEFAULT, PROCESS
D775:         	NUMS1:
D775: FE48    		CP	NUMBASE		;CHECK AGAINST BASE SWITCH FLAG
D777: 282B    		JR	Z,HNUM0
              	;
              	; PROCESS DECIMAL NUMBER
              	;
D779:         	NUM0:
D779: 2199D4  		LD	HL,FCBFN	;PT TO BEGINNING OF TOKEN
D77C: 010011  		LD	BC,1100H	;C=ACCUMULATED VALUE, B=CHAR COUNT
              					; (C=0, B=11)
D77F:         	NUM1:
D77F: 7E      		LD	A,(HL)		;GET CHAR
D780: FE20    		CP	' '		;DONE IF <SP>
D782: 2818    		JR	Z,NUM2
D784: 23      		INC	HL		;PT TO NEXT CHAR
D785: D630    		SUB	'0'		;CONVERT TO BINARY (ASCII 0-9 TO BINARY)
D787: FE0A    		CP	10		;ERROR IF >= 10
D789: 3013    		JR	NC,NUMERR
D78B: 57      		LD	D,A		;DIGIT IN D
D78C: 79      		LD	A,C		;NEW VALUE = OLD VALUE * 10
D78D: 07      		RLCA
D78E: 07      		RLCA
D78F: 07      		RLCA
D790: 81      		ADD	A,C		;CHECK FOR RANGE ERROR
D791: 380B    		JR	C,NUMERR
D793: 81      		ADD	A,C		;CHECK FOR RANGE ERROR
D794: 3808    		JR	C,NUMERR
D796: 82      		ADD	A,D		;NEW VALUE = OLD VALUE * 10 + DIGIT
D797: 3805    		JR	C,NUMERR	;CHECK FOR RANGE ERROR
D799: 4F      		LD	C,A		;SET NEW VALUE
D79A: 10E3    		DJNZ	NUM1		;COUNT DOWN
              	;
              	; RETURN FROM NUMBER
              	;
D79C:         	NUM2:
D79C: 79      		LD	A,C		;GET ACCUMULATED VALUE
D79D: C9      		RET
              	;
              	; NUMBER ERROR ROUTINE FOR SPACE CONSERVATION
              	;
D79E:         	NUMERR:
D79E: C317D7  		JP	ERROR		;USE ERROR ROUTINE - THIS IS RELATIVE PT
              	;
              	; EXTRACT HEXADECIMAL NUMBER FROM COMMAND LINE
              	;   RETURN WITH VALUE IN REG A; ALL REGISTERS MAY BE AFFECTED
              	;
D7A1:         	HEXNUM:
D7A1: CD08D8  		CALL	SCANER		;PARSE NUMBER AND PLACE IN FCBFN
D7A4:         	HNUM0:
D7A4: 2199D4  		LD	HL,FCBFN	;PT TO TOKEN FOR CONVERSION
D7A7: 110000  		LD	DE,0		;DE=ACCUMULATED VALUE
D7AA: 060B    		LD	B,11		;B=CHAR COUNT
D7AC:         	HNUM1:
D7AC: 7E      		LD	A,(HL)		;GET CHAR
D7AD: FE20    		CP	' '		;DONE?
D7AF: 282D    		JR	Z,HNUM3		;RETURN IF SO
D7B1: FE48    		CP	NUMBASE		;DONE IF NUMBASE SUFFIX
D7B3: 2829    		JR	Z,HNUM3
D7B5: D630    		SUB	'0'		;CONVERT TO BINARY
D7B7: 38E5    		JR	C,NUMERR	;RETURN AND DONE IF ERROR
D7B9: FE0A    		CP	10		;0-9?
D7BB: 3806    		JR	C,HNUM2
D7BD: D607    		SUB	7		;A-F?
D7BF: FE10    		CP	10H		;ERROR?
D7C1: 30DB    		JR	NC,NUMERR
D7C3:         	HNUM2:
D7C3: 23      		INC	HL		;PT TO NEXT CHAR
D7C4: 4F      		LD	C,A		;DIGIT IN C
D7C5: 7A      		LD	A,D		;GET ACCUMULATED VALUE
D7C6: 07      		RLCA			;EXCHANGE NYBBLES
D7C7: 07      		RLCA
D7C8: 07      		RLCA
D7C9: 07      		RLCA
D7CA: E6F0    		AND	0F0H		;MASK OUT LOW NYBBLE
D7CC: 57      		LD	D,A
D7CD: 7B      		LD	A,E		;SWITCH LOW-ORDER NYBBLES
D7CE: 07      		RLCA
D7CF: 07      		RLCA
D7D0: 07      		RLCA
D7D1: 07      		RLCA
D7D2: 5F      		LD	E,A		;HIGH NYBBLE OF E=NEW HIGH OF E,
              					;  LOW NYBBLE OF E=NEW LOW OF D
D7D3: E60F    		AND	0FH		;GET NEW LOW OF D
D7D5: B2      		OR	D		;MASK IN HIGH OF D
D7D6: 57      		LD	D,A		;NEW HIGH BYTE IN D
D7D7: 7B      		LD	A,E
D7D8: E6F0    		AND	0F0H		;MASK OUT LOW OF E
D7DA: B1      		OR	C		;MASK IN NEW LOW
D7DB: 5F      		LD	E,A		;NEW LOW BYTE IN E
D7DC: 10CE    		DJNZ	HNUM1		;COUNT DOWN
              	;
              	; RETURN FROM HEXNUM
              	;
D7DE:         	HNUM3:
D7DE: EB      		EX	DE,HL		;RETURNED VALUE IN HL
D7DF: 7D      		LD	A,L		;LOW-ORDER BYTE IN A
D7E0: C9      		RET
              	;
              	; PT TO DIRECTORY ENTRY IN TBUFF WHOSE OFFSET IS SPECIFIED BY A AND C
              	;
D7E1:         	DIRPTR:
D7E1: 218000  		LD	HL,TBUFF 	;PT TO TEMP BUFFER
D7E4: 81      		ADD	A,C		;PT TO 1ST BYTE OF DIR ENTRY
D7E5: CD5ED7  		CALL	ADDAH		;PT TO DESIRED BYTE IN DIR ENTRY
D7E8: 7E      		LD	A,(HL)		;GET DESIRED BYTE
D7E9: C9      		RET
              	;
              	; CHECK FOR SPECIFIED DRIVE AND LOG IT IN IF NOT DEFAULT
              	;
D7EA:         	SLOGIN:
D7EA: AF      		XOR	A		;SET FCBDN FOR DEFAULT DRIVE
D7EB: 3298D4  		LD	(FCBDN),A
D7EE: CDFED7  		CALL	COMLOG		;CHECK DRIVE
D7F1: C8      		RET	Z
D7F2: 1807    		JR	DLOG5		;DO LOGIN OTHERWISE
              	;
              	; CHECK FOR SPECIFIED DRIVE AND LOG IN DEFAULT DRIVE IF SPECIFIED<>DEFAULT
              	;
D7F4:         	DLOGIN:
D7F4: CDFED7  		CALL	COMLOG		;CHECK DRIVE
D7F7: C8      		RET	Z		;ABORT IF SAME
D7F8: 3A7ED6  		LD	A,(TDRIVE)	;LOG IN DEFAULT DRIVE
              	;
D7FB: C332D6  	DLOG5:	JP	LOGIN
              	;
              	; ROUTINE COMMON TO BOTH LOGIN ROUTINES; ON EXIT, Z SET MEANS ABORT
              	;
D7FE:         	COMLOG:
D7FF:         	TEMPDR	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
D7FE: 3E00    		LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS TEMPDR
D800: B7      		OR	A		;0=NO
D801: C8      		RET	Z
D802: 3D      		DEC	A		;COMPARE IT AGAINST DEFAULT
D803: 217ED6  		LD	HL,TDRIVE
D806: BE      		CP	(HL)
D807: C9      		RET			;ABORT IF SAME
              	;
              	; EXTRACT TOKEN FROM COMMAND LINE AND PLACE IT INTO FCBDN;
              	;   FORMAT FCBDN FCB IF TOKEN RESEMBLES FILE NAME AND TYPE (FILENAME.TYP);
              	;   ON INPUT, CIBPTR PTS TO CHAR AT WHICH TO START SCAN;
              	;   ON OUTPUT, CIBPTR PTS TO CHAR AT WHICH TO CONTINUE AND ZERO FLAG IS RESET
              	;     IF '?' IS IN TOKEN
              	;
              	; ENTRY POINTS:
              	;	SCANER - LOAD TOKEN INTO FIRST FCB
              	;	SCANX - LOAD TOKEN INTO FCB PTED TO BY HL
              	;
D808:         	SCANER:
D808: 2198D4  		LD	HL,FCBDN 	;POINT TO FCBDN
D80B:         	SCANX:
D80B: AF      		XOR	A		;SET TEMPORRY DRIVE NUMBER TO DEFAULT
D80C: 32FFD7  		LD	(TEMPDR),A
D80F: CD51D7  		CALL	ADVAN		;SKIP TO NON-BLANK OR END OF LINE
D812: ED5358D4		LD	(CIPTR),DE	;SET PTR TO NON-BLANK OR END OF LINE
D816: 1A      		LD	A,(DE)		;END OF LINE?
D817: B7      		OR	A		;0=YES
D818: 280A    		JR	Z,SCAN2
D81A: DE40    		SBC	A,'A'-1		;CONVERT POSSIBLE DRIVE SPEC TO NUMBER
D81C: 47      		LD	B,A		;STORE NUMBER (A:=0, B:=1, ETC) IN B
D81D: 13      		INC	DE		;PT TO NEXT CHAR
D81E: 1A      		LD	A,(DE)		;SEE IF IT IS A COLON (:)
D81F: FE3A    		CP	':'
D821: 2807    		JR	Z,SCAN3		;YES, WE HAVE A DRIVE SPEC
D823: 1B      		DEC	DE		;NO, BACK UP PTR TO FIRST NON-BLANK CHAR
D824:         	SCAN2:
D824: 3A7ED6  		LD	A,(TDRIVE)	;SET 1ST BYTE OF FCBDN AS DEFAULT DRIVE
D827: 77      		LD	(HL),A
D828: 1806    		JR	SCAN4
D82A:         	SCAN3:
D82A: 78      		LD	A,B		;WE HAVE A DRIVE SPEC
D82B: 32FFD7  		LD	(TEMPDR),A	;SET TEMPORRY DRIVE
D82E: 70      		LD	(HL),B		;SET 1ST BYTE OF FCBDN AS SPECIFIED DRIVE
D82F: 13      		INC	DE		;PT TO BYTE AFTER ':'
              	;
              	; EXTRACT FILENAME FROM POSSIBLE FILENAME.TYP
              	;
D830:         	SCAN4:
D830: AF      		XOR	A		;A=0
D831: 32BBD4  		LD	(QMCNT),A	;INIT COUNT OF NUMBER OF QUESTION MARKS IN FCB
D834: 0608    		LD	B,8		;MAX OF 8 CHARS IN FILE NAME
D836: CD58D8  		CALL	SCANF		;FILL FCB FILE NAME
              	;
              	; EXTRACT FILE TYPE FROM POSSIBLE FILENAME.TYP
              	;
D839: 0603    		LD	B,3		;PREPARE TO EXTRACT TYPE
D83B: FE2E    		CP	'.'		;IF (DE) DELIMITER IS A '.', WE HAVE A TYPE
D83D: 2006    		JR	NZ,SCAN15	;FILL FILE TYPE BYTES WITH <SP>
D83F: 13      		INC	DE		;PT TO CHAR IN COMMAND LINE AFTER '.'
D840: CD58D8  		CALL	SCANF		;FILL FCB FILE TYPE
D843: 1803    		JR	SCAN16		;SKIP TO NEXT PROCESSING
D845:         	SCAN15:
D845: CD79D8  		CALL	SCANF4		;SPACE FILL
              	;
              	; FILL IN EX, S1, S2, AND RC WITH ZEROES
              	;
D848:         	SCAN16:
D848: 0604    		LD	B,4		;4 BYTES
D84A:         	SCAN17:
D84A: 23      		INC	HL		;PT TO NEXT BYTE IN FCBDN
D84B: 3600    		LD	(HL),0
D84D: 10FB    		DJNZ	SCAN17
              	;
              	; SCAN COMPLETE -- DE PTS TO DELIMITER BYTE AFTER TOKEN
              	;
D84F: ED5356D4		LD	(CIBPTR),DE
              	;
              	; SET ZERO FLAG TO INDICATE PRESENCE OF '?' IN FILENAME.TYP
              	;
D853: 3ABBD4  		LD	A,(QMCNT)	;GET NUMBER OF QUESTION MARKS
D856: B7      		OR	A		;SET ZERO FLAG TO INDICATE ANY '?'
D857: C9      		RET
              	;
              	;  SCANF -- SCAN TOKEN PTED TO BY DE FOR A MAX OF B BYTES; PLACE IT INTO
              	;    FILE NAME FIELD PTED TO BY HL; EXPAND AND INTERPRET WILD CARDS OF
              	;    '*' AND '?'; ON EXIT, DE PTS TO TERMINATING DELIMITER
              	;
D858:         	SCANF:
D858: CD34D7  		CALL	SDELM		;DONE IF DELIMITER ENCOUNTERED - <SP> FILL
D85B: 281C    		JR	Z,SCANF4
D85D: 23      		INC	HL		;PT TO NEXT BYTE IN FCBDN
D85E: FE2A    		CP	'*'		;IS (DE) A WILD CARD?
D860: 2007    		JR	NZ,SCANF1	;CONTINUE IF NOT
D862: 363F    		LD	(HL),'?'	;PLACE '?' IN FCBDN AND DON'T ADVANCE DE IF SO
D864: CD7FD8  		CALL	SCQ		;SCANNER COUNT QUESTION MARKS
D867: 1807    		JR	SCANF2
D869:         	SCANF1:
D869: 77      		LD	(HL),A		;STORE FILENAME CHAR IN FCBDN
D86A: 13      		INC	DE		;PT TO NEXT CHAR IN COMMAND LINE
D86B: FE3F    		CP	'?'		;CHECK FOR QUESTION MARK (WILD)
D86D: CC7FD8  		CALL	Z,SCQ		;SCANNER COUNT QUESTION MARKS
D870:         	SCANF2:
D870: 10E6    		DJNZ	SCANF		;DECREMENT CHAR COUNT UNTIL 8 ELAPSED
D872:         	SCANF3:
D872: CD34D7  		CALL	SDELM		;8 CHARS OR MORE - SKIP UNTIL DELIMITER
D875: C8      		RET	Z		;ZERO FLAG SET IF DELIMITER FOUND
D876: 13      		INC	DE		;PT TO NEXT CHAR IN COMMAND LINE
D877: 18F9    		JR	SCANF3
              	;
              	;  FILL MEMORY POINTED TO BY HL WITH SPACES FOR B BYTES
              	;
D879:         	SCANF4:
D879: 23      		INC	HL		;PT TO NEXT BYTE IN FCBDN
D87A: 3620    		LD	(HL),' '	;FILL FILENAME PART WITH <SP>
D87C: 10FB    		DJNZ	SCANF4
D87E: C9      		RET
              	;
              	;  INCREMENT QUESTION MARK COUNT FOR SCANNER
              	;    THIS ROUTINE INCREMENTS THE COUNT OF THE NUMBER OF QUESTION MARKS IN
              	;    THE CURRENT FCB ENTRY
              	;
D87F:         	SCQ:
D87F: 3ABBD4  		LD	A,(QMCNT)	;GET COUNT
D882: 3C      		INC	A		;INCREMENT
D883: 32BBD4  		LD	(QMCNT),A	;PUT COUNT
D886: C9      		RET
              	;
              	; CMDTBL (COMMAND TABLE) SCANNER
              	;   ON RETURN, HL PTS TO ADDRESS OF COMMAND IF CPR-RESIDENT
              	;   ON RETURN, ZERO FLAG SET MEANS CPR-RESIDENT COMMAND
              	;
D887:         	CMDSER:
D887: 215FD5  		LD	HL,CMDTBL	;PT TO COMMAND TABLE
              	;
              		IF	SECURE
              		LD	C,NRCMDS
              		LD	A,(WHEEL)	;SEE IF NON-RESTRCTED
              		CP	RESTRCT
              		JR	Z,CMS1		;PASS IF RESTRCTED
              		ENDIF			;SECURE
              	;
D88A: 0E0B    		LD	C,NCMNDS	;SET COMMAND COUNTER
D88C:         	CMS1:
D88C: 1199D4  		LD	DE,FCBFN 	;PT TO STORED COMMAND NAME
D88F: 0604    		LD	B,NCHARS	;NUMBER OF CHARS/COMMAND (8 MAX)
D891:         	CMS2:
D891: 1A      		LD	A,(DE)		;COMPARE AGAINST TABLE ENTRY
D892: BE      		CP	(HL)
D893: 200A    		JR	NZ,CMS3		;NO MATCH
D895: 13      		INC	DE		;PT TO NEXT CHAR
D896: 23      		INC	HL
D897: 10F8    		DJNZ	CMS2		;COUNT DOWN
D899: 1A      		LD	A,(DE)		;NEXT CHAR IN INPUT COMMAND MUST BE <SP>
D89A: FE20    		CP	' '
D89C: 2004    		JR	NZ,CMS4
D89E: C9      		RET			;COMMAND IS CPR-RESIDENT (ZERO FLAG SET)
D89F:         	CMS3:
D89F: 23      		INC	HL		;SKIP TO NEXT COMMAND TABLE ENTRY
D8A0: 10FD    		DJNZ	CMS3
D8A2:         	CMS4:
D8A2: 23      		INC	HL		;SKIP ADDRESS
D8A3: 23      		INC	HL
D8A4: 0D      		DEC	C		;DECREMENT TABLE ENTRY NUMBER
D8A5: 20E5    		JR	NZ,CMS1
D8A7: 0C      		INC	C		;CLEAR ZERO FLAG
D8A8: C9      		RET			;COMMAND IS DISK-RESIDENT (ZERO FLAG CLEAR)
              	;
              	;**** Section 5 ****
              	; CPR-Resident Commands
              	;
              	;
              	;Section 5A
              	;Command: DIR
              	;Function:  To display a directory of the files on disk
              	;Forms:
              	;	DIR <afn>	Displays the DIR files
              	;	DIR <afn> S	Displays the SYS files
              	;	DIR <afn> A	Display both DIR and SYS files
              	;
              		IF	CPRDIR
              	;
D8A9:         	DIR:
D8A9: 3E80    		LD	A,80H		;SET SYSTEM BIT EXAMINATION
D8AB: F5      		PUSH	AF
D8AC: CD08D8  		CALL	SCANER		;EXTRACT POSSIBLE D:FILENAME.TYP TOKEN
D8AF: CDEAD7  		CALL	SLOGIN		;LOG IN DRIVE IF NECESSARY
D8B2: 2199D4  		LD	HL,FCBFN 	;MAKE FCB WILD (ALL '?') IF NO FILENAME.TYP
D8B5: 7E      		LD	A,(HL)		;GET FIRST CHAR OF FILENAME.TYP
D8B6: FE20    		CP	' '		;IF <SP>, ALL WILD
D8B8: CC52D9  		CALL	Z,FILLQ
D8BB: CD51D7  		CALL	ADVAN		;LOOK AT NEXT INPUT CHAR
D8BE: 0600    		LD	B,0		;SYS TOKEN DEFAULT
D8C0: 2816    		JR	Z,DIR2		;JUMP; THERE ISN'T ONE
D8C2: FE41    		CP	SYSFLG		;SYSTEM FLAG SPECIFIER?
D8C4: 2806    		JR	Z,GOTSYS	;GOT SYSTEM SPECIFIER
D8C6: FE53    		CP	SOFLG		;SYS ONLY?
D8C8: 200E    		JR	NZ,DIR2
D8CA: 0680    		LD	B,80H		;FLAG SYS ONLY
D8CC:         	GOTSYS:
D8CC: 13      		INC	DE
D8CD: ED5356D4		LD	(CIBPTR),DE
D8D1: FE53    		CP	SOFLG		;SYS ONLY SPEC?
D8D3: 2803    		JR	Z,DIR2		;THEN LEAVE BIT SPEC UNCHAGNED
D8D5: F1      		POP	AF		;GET FLAG
D8D6: AF      		XOR	A		;SET NO SYSTEM BIT EXAMINATION
D8D7: F5      		PUSH	AF 
D8D8:         	DIR2:
D8D8: F1      		POP	AF		;GET FLAG
D8D9:         	DIR2A:
              					;DROP INTO DIRPR TO PRINT DIRECTORY
              					; THEN RESTART CPR
              		ENDIF			;CPRDIR
              	;
              	; DIRECTORY PRINT ROUTINE; ON ENTRY, MSB OF A IS 1 (80H) IF SYSTEM FILES
              	; EXCLUDED. THIS ROUTINE IS ALSO USED BY ERA.
              	;
D8D9:         	DIRPR:
D8D9: 57      		LD	D,A		;STORE SYSTEM FLAG IN D
D8DA: 1E00    		LD	E,0		;SET COLUMN COUNTER TO ZERO
D8DC: D5      		PUSH	DE		;SAVE COLUMN COUNTER (E) AND SYSTEM FLAG (D)
D8DD: 78      		LD	A,B		;SYS ONLY SPECIFIER
D8DE: 32F9D8  		LD	(SYSTST),A
D8E1: CD49D6  		CALL	SEARF		;SEARCH FOR SPECIFIED FILE (FIRST OCCURRANCE)
D8E4: CC54D5  		CALL	Z,PRNNF		;PRINT NO FILE MSG;REG A NOT CHANGED
              	;
              	; ENTRY SELECTION LOOP; ON ENTRY, A=OFFSET FROM SEARF OR SEARN
              	;
D8E7:         	DIR3:
D8E7: 2867    		JR	Z,DIR11		;DONE IF ZERO FLAG SET
D8E9: 3D      		DEC	A		;ADJUST TO RETURNED VALUE
D8EA: 0F      		RRCA			;CONVERT NUMBER TO OFFSET INTO TBUFF
D8EB: 0F      		RRCA
D8EC: 0F      		RRCA
D8ED: E660    		AND	60H
D8EF: 4F      		LD	C,A		;OFFSET INTO TBUFF IN C (C=OFFSET TO ENTRY)
D8F0: 3E0A    		LD	A,10		;ADD 10 TO PT TO SYSTEM FILE ATTRIBUTE BIT
D8F2: CDE1D7  		CALL	DIRPTR
D8F5: D1      		POP	DE		;GET SYSTEM BIT MASK FROM D
D8F6: D5      		PUSH	DE
D8F7: A2      		AND	D		;MASK FOR SYSTEM BIT
D8F9:         	SYSTST	EQU	$+1		;POINTER TO IN-THE-CODE BUFFER SYSTST
D8F8: FE00    		CP	0
D8FA: 204A    		JR	NZ,DIR10
D8FC: D1      		POP	DE		;GET ENTRY COUNT (=<CR> COUNTER)
D8FD: 7B      		LD	A,E		;ADD 1 TO IT
D8FE: 1C      		INC	E
D8FF: D5      		PUSH	DE		;SAVE IT
              	;
              		IF	TWOCOL
              		AND	01H		;OUTPUT <CRLF> IF 2 ENTRIES PRINTED IN LINE
              		ENDIF			;TWOCOL
              	;
              		IF	TWOCOL
              	        ELSE
D901:         	TWOPOK	EQU	$+1		;FOR APPLE PATCHING
D900: E603    		AND	03H		;OUTPUT <CRLF> IF 4 ENTRIES PRINTED IN LINE
              		ENDIF			;NOT TWOCOL
              	;
D902: F5      		PUSH	AF
D903: 2005    		JR	NZ,DIR4
D905: CDA1D5  		CALL	CRLF		;NEW LINE
D908: 1808    		JR	DIR5
D90A:         	DIR4:
D90A: CD0FD6  		CALL	PRINT
              	;
              		IF	WIDE
D90D: 2020    		DEFM	'  '		;2 SPACES
D90F: 7C      		DEFB	FENCE		;THEN FENCE CHAR
D910: 20A0    		DEFB	' ',' '+80H	;THEN 2 MORE SPACES
              	;	ENDIF
              	;
              	        ELSE
              		DEFB	' '		;SPACE
              		DEFB	FENCE		;THEN FENCE CHAR
              		DEFB	' '+80H		;THEN SPACE
              		ENDIF
              	;
D912:         	DIR5:
D912: 0601    		LD	B,01H		;PT TO 1ST BYTE OF FILE NAME
D914:         	DIR6:
D914: 78      		LD	A,B		;A=OFFSET
D915: CDE1D7  		CALL	DIRPTR		;HL NOW PTS TO 1ST BYTE OF FILE NAME
D918: E67F    		AND	7FH		;MASK OUT MSB
D91A: FE20    		CP	' '		;NO FILE NAME?
D91C: 2013    		JR	NZ,DIR8		;PRINT FILE NAME IF PRESENT
D91E: F1      		POP	AF
D91F: F5      		PUSH	AF
D920: FE03    		CP	03H
D922: 200B    		JR	NZ,DIR7
D924: 3E09    		LD	A,09H		;PT TO 1ST BYTE OF FILE TYPE
D926: CDE1D7  		CALL	DIRPTR		;HL NOW PTS TO 1ST BYTE OF FILE TYPE
D929: E67F    		AND	7FH		;MASK OUT MSB
D92B: FE20    		CP	' '		;NO FILE TYPE?
D92D: 2816    		JR	Z,DIR9		;CONTINUE IF SO
D92F:         	DIR7:
D92F: 3E20    		LD	A,' '		;OUTPUT <SP>
D931:         	DIR8:
D931: CDA8D5  		CALL	CONOUT		;PRINT CHAR
D934: 04      		INC	B		;INCR CHAR COUNT
D935: 78      		LD	A,B
D936: FE0C    		CP	12		;END OF FILENAME.TYP?
D938: 300B    		JR	NC,DIR9		;CONTINUE IF SO
D93A: FE09    		CP	09H		;END IF FILENAME ONLY?
D93C: 20D6    		JR	NZ,DIR6		;PRINT TYP IF SO
D93E: 3E2E    		LD	A,'.'		;PRINT DOT BETWEEN FILE NAME AND TYPE
D940: CDA8D5  		CALL	CONOUT
D943: 18CF    		JR	DIR6
D945:         	DIR9:
D945: F1      		POP	AF
D946:         	DIR10:
D946: CD06D7  		CALL	BREAK		;CHECK FOR ABORT
D949: 2005    		JR	NZ,DIR11
D94B: CD50D6  		CALL	SEARN		;SEARCH FOR NEXT FILE
D94E: 1897    		JR	DIR3		;CONTINUE
D950:         	DIR11:
D950: D1      		POP	DE		;RESTORE STACK
D951: C9      		RET
              	;
              	; FILL FCB @HL WITH '?'
              	;
D952:         	FILLQ:
D952: 060B    		LD	B,11		;NUMBER OF CHARS IN FN & FT
D954:         	FQLP:
D954: 363F    		LD	(HL),'?'	;STORE '?'
D956: 23      		INC	HL
D957: 10FB    		DJNZ	FQLP
D959: C9      		RET
              	;
              	;Section 5B
              	;Command: ERA
              	;Function:  Erase files
              	;Forms:
              	;	ERA <afn>	Erase Specified files and print their names
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
              	;
D95A:         	ERA:
D95A: CD08D8  		CALL	SCANER		;PARSE FILE SPECIFICATION
D95D: FE0B    		CP	11		;ALL WILD (ALL FILES = 11 '?')?
D95F: 2012    		JR	NZ,ERA1		;IF NOT, THEN DO ERASES
D961: CD0AD6  		CALL	PRINTC
D964: 416C6C  		DEFM	'All'
D967: BF      		DEFB	'?'+80H
D968: CDB5D5  		CALL	CONIN		;GET REPLY
D96B: FE59    		CP	'Y'		;YES?
D96D:         	ERARJ:
D96D: C2F2D4  		JP	NZ,RESTRT	;RESTART CPR IF NOT
D970: CDA1D5  		CALL	CRLF		;NEW LINE
D973:         	ERA1:
D973: CDEAD7  		CALL	SLOGIN		;LOG IN SELECTED DISK IF ANY
D976: AF      		XOR	A		;PRINT ALL FILES (EXAMINE SYSTEM BIT)
D977: 47      		LD	B,A		;NO SYS-ONLY OPT TO DIRPR
D978: CDD9D8  		CALL	DIRPR		;PRINT DIRECTORY OF ERASED FILES
              	;
              		IF	EPRMPT
              	;
              	;  QUERY USER AFTER FILES ARE SEEN, AND GIVE ONE LAST CHANCE TO BACK OUT
              	;
              		LD	A,E		;HOW MANY FILES DISPLAYED?
              		OR	A
              		JP	Z,RESTRT	;IF NONE, DON'T ASK OR DELETE
              		CALL	PRINTC		;PROMPT
              		DEFM	'Ok'
              		DEFB	'?'+80H
              		CALL	CONIN		;GET REPLY FOLDED
              		CP	'Y'		;YES?
              		JR	NZ,ERARJ	;GET OUT IF NOT
              		ENDIF			;EPRMPT
              	;
D97B: 1198D4  		LD	DE,FCBDN 	;DELETE FILE(S) SPECIFIED
D97E: C35FD6  		JP	DELETE		;RESTART CPR AFTER DELETE
              	;
              		ENDIF			;RAS
              	;
              	;Section 5C
              	;Command: LIST
              	;Function:  Print out specified file on the LST: Device
              	;Forms:
              	;	LIST <ufn>	Print file (NO Paging)
              	;
              		IF	CPRLST
D981:         	LIST:
D981: 3EFF    		LD	A,0FFH		;TURN ON PRINTER FLAG
D983: 1801    		JR	TYPE0
              		ENDIF			;CPRLST
              	;
              	;Section 5D
              	;Command: TYPE
              	;Function:  Print out specified file on the CON: Device
              	;Forms:
              	;	TYPE <ufn>	Print file
              	;	TYPE <ufn> P	Print file with paging flag	
              	;
              		IF	CPRTYP
D985:         	TYPE:
              		ENDIF			;CPRTYP
              	;
              		IF	CPRTYP AND CPRLST
D985: AF      		XOR	A		;TURN OFF PRINTER FLAG
              	;
              	; ENTRY POINT FOR CPR LIST FUNCTION (LIST)
              	;
D986:         	TYPE0:
D986: 32D2D5  		LD	(PRFLG),A	;SET FLAG
              		ENDIF			;CPRTYP AND CPRLST
              	;
              		IF	CPRTYP
D989: CD08D8  		CALL	SCANER		;EXTRACT FILENAME.TYP TOKEN
D98C: C217D7  		JP	NZ,ERROR	;ERROR IF ANY QUESTION MARKS
D98F: CD51D7  		CALL	ADVAN		;GET PGDFLG IF IT'S THERE
D992: 32EFD5  		LD	(PGFLG),A	;SAVE IT AS A FLAG
D995: 2805    		JR	Z,NOSLAS	;JUMP IF INPUT ENDED
D997: 13      		INC	DE		;PUT NEW BUF POINTER
D998: EB      		EX	DE,HL
D999: 2256D4  		LD	(CIBPTR),HL
D99C:         	NOSLAS:
D99C: CDEAD7  		CALL	SLOGIN		;LOG IN SELECTED DISK IF ANY
D99F: CD37D6  		CALL	OPENF		;OPEN SELECTED FILE
D9A2: CA0FDA  		JP	Z,TYPE4		;ABORT IF ERROR
D9A5: CDA1D5  		CALL	CRLF		;NEW LINE
D9A8: 3E17    		LD	A,NLINES-1	;SET LINE COUNT
D9AA: 32B9D4  		LD	(PAGCNT),A
D9AD: 21BAD4  		LD	HL,CHRCNT	;SET CHAR POSITION/COUNT
D9B0: 36FF    		LD	(HL),0FFH	;EMPTY LINE
D9B2: 0600    		LD	B,0		;SET TAB CHAR COUNTER
D9B4:         	TYPE1:
D9B4: 21BAD4  		LD	HL,CHRCNT	;PT TO CHAR POSITION/COUNT
D9B7: 7E      		LD	A,(HL)		;END OF BUFFER?
D9B8: FE80    		CP	80H
D9BA: 3809    		JR	C,TYPE2
D9BC: E5      		PUSH	HL		;READ NEXT BLOCK
D9BD: CDFED5  		CALL	READF
D9C0: E1      		POP	HL
D9C1: 204A    		JR	NZ,TYPE3	;ERROR?
D9C3: AF      		XOR	A		;RESET COUNT
D9C4: 77      		LD	(HL),A
D9C5:         	TYPE2:
D9C5: 34      		INC	(HL)		;INCREMENT CHAR COUNT
D9C6: 218000  		LD	HL,TBUFF 	;PT TO BUFFER
D9C9: CD5ED7  		CALL	ADDAH		;COMPUTE ADDRESS OF NEXT CHAR FROM OFFSET
D9CC: 7E      		LD	A,(HL)		;GET NEXT CHAR
D9CD: E67F    		AND	7FH		;MASK OUT MSB
D9CF: FE1A    		CP	1AH		;END OF FILE (^Z)?
D9D1: C8      		RET	Z		;RESTART CPR IF SO
              	;
              	; OUTPUT CHAR TO CON: OR LST: DEVICE WITH TABULATION
              	;
              		IF	WSTYPE		;WORDSTAR HYPHEN CHECK
D9D2: FE1F    		CP	1FH		;IS CHAR WORDSTAR EOL HYPHEN?
D9D4: 2002    		JR	NZ,NOHYPH	;PASS IF NOT
D9D6: 3E2D    		LD	A,'-'		;YES, MAKE IT A REAL HYPHEN
D9D8:         	NOHYPH:
              		ENDIF			;WSTYPE
              	;
D9D8: FE20    		CP	' '		;IS CHAR CONTROL CODE?
D9DA: 3023    		JR	NC,PRT		;GO BOP CHAR COUNT AND PRINT IF NOT
D9DC: FE0D    		CP	CR		;IS CHAR A CR?
D9DE: 281D    		JR	Z,YESCR		;IF SO, GO ZERO B THEN PRINT
D9E0: FE0C    		CP	FFEED		;FORM FEED?
D9E2: 2819    		JR	Z,YESCR		;MANY PRINTERS RETURN CARRIAGE ON THIS
D9E4: FE0A    		CP	LF		;LINE FEED?
D9E6: 2818    		JR	Z,NOBOP		;PRINT, BUT DON'T BOP B
D9E8: FE07    		CP	BEL		;BELL?
D9EA: 2814    		JR	Z,NOBOP		;GO RING BUT DON'T BOP B
D9EC: FE09    		CP	TAB		;TAB?
D9EE: 2013    		JR	NZ,TYPE2L	;IF NOT, NO OTHER CHOICES, TOSS CONTROL
D9F0:         	LTAB:
D9F0: 3E20    		LD	A,' '		;<SP>
D9F2: CDD0D5  		CALL	LCOUT
D9F5: 04      		INC	B		;INCR POS COUNT
D9F6: 78      		LD	A,B
D9F7: E607    		AND	7
D9F9: 20F5    		JR	NZ,LTAB
D9FB: 1806    		JR	TYPE2L
              	;
D9FD: 06FF    	YESCR:	LD	B,0FFH		;COMBINE WITH INC BELOW TO GET ZERO
              	;
D9FF: 04      	PRT:	INC	B		;INCREMENT CHAR COUNT
DA00: CDD0D5  	NOBOP:	CALL	LCOUT		;PRINT IT
              	;
              	; CONTINUE PROCESSING
              	;
              	;
DA03:         	TYPE2L:
DA03: CD06D7  		CALL	BREAK		;CHECK FOR ABORT
DA06: 28AC    		JR	Z,TYPE1		;CONTINUE IF NO CHAR
DA08: FE03    		CP	'C'-'@' 	;^C?
DA0A: C8      		RET	Z		;RESTART IF SO
DA0B: 18A7    		JR	TYPE1
DA0D:         	TYPE3:
DA0D: 3D      		DEC	A		;NO ERROR?
DA0E: C8      		RET	Z		;RESTART CPR
DA0F:         	TYPE4:
DA0F: C3FADB  		JP	ERRLOG
              		ENDIF			;CPRTYP
              	;
              	;Section 5E
              	;Command: SAVE
              	;Function:  To save the contents of the TPA onto disk as a file
              	;Forms:
              	;	SAVE <Number of Pages> <ufn>
              	;				Save specified number of pages (start at 100H)
              	;				from TPA into specified file; <Number of
              	;				Pages> is in DEC
              	;	SAVE <Number of Sectors> <ufn> S
              	;				Like SAVE above, but numeric argument specifies
              	;				number of sectors rather than pages
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
              	;
DA12:         	SAVE:
DA12: CD63D7  		CALL	NUMBER		;EXTRACT NUMBER FROM COMMAND LINE
DA15: 6F      		LD	L,A		;HL=PAGE COUNT
DA16: 2600    		LD	H,0
DA18: E5      		PUSH	HL		;SAVE PAGE COUNT
DA19: CD68DA  		CALL	EXTEST		;TEST FOR EXISTENCE OF FILE AND ABORT IF SO
DA1C: 0E16    		LD	C,16H		;BDOS MAKE FILE
DA1E: CD40D6  		CALL	GRBDOS
DA21: E1      		POP	HL		;GET PAGE COUNT
DA22: 2841    		JR	Z,SAVE3		;ERROR?
DA24: AF      		XOR	A		;SET RECORD COUNT FIELD OF NEW FILE'S FCB
DA25: 32B8D4  		LD	(FCBCR),A
DA28: CD51D7  		CALL	ADVAN		;LOOK FOR 'S' FOR SECTOR OPTION
DA2B: 13      		INC	DE		;PT TO AFTER 'S' TOKEN
DA2C: FE53    		CP	SECTFLG
DA2E: 2802    		JR	Z,SAVE0
DA30: 1B      		DEC	DE		;NO 'S' TOKEN, SO BACK UP
DA31: 29      		ADD	HL,HL		;DOUBLE IT FOR HL=SECTOR (128 BYTES) COUNT
DA32:         	SAVE0:
DA32: ED5356D4		LD	(CIBPTR),DE	;SET PTR TO BAD TOKEN OR AFTER GOOD TOKEN
DA36: 110001  		LD	DE,TPA		;PT TO START OF SAVE AREA (TPA)
DA39:         	SAVE1:
DA39: 7C      		LD	A,H		;DONE WITH SAVE?
DA3A: B5      		OR	L		;HL=0 IF SO
DA3B: 2818    		JR	Z,SAVE2
DA3D: 2B      		DEC	HL		;COUNT DOWN ON SECTORS
DA3E: E5      		PUSH	HL		;SAVE PTR TO BLOCK TO SAVE
DA3F: 218000  		LD	HL,128		;128 BYTES PER SECTOR
DA42: 19      		ADD	HL,DE		;PT TO NEXT SECTOR
DA43: E5      		PUSH	HL		;SAVE ON STACK
DA44: CD29D6  		CALL	DMASET		;SET DMA ADDRESS FOR WRITE (ADDRESS IN DE)
DA47: 1198D4  		LD	DE,FCBDN 	;WRITE SECTOR
DA4A: 0E15    		LD	C,15H		;BDOS WRITE SECTOR
DA4C: CD03D6  		CALL	BDOSB		;SAVE BC
DA4F: D1      		POP	DE		;GET PTR TO NEXT SECTOR IN DE
DA50: E1      		POP	HL		;GET SECTOR COUNT
DA51: 28E6    		JR	Z,SAVE1		;CONTINUE IF NO WRITE ERROR
DA53: 1809    		JR	PRNLE		;GO PRINT ERROR AND RESET DMA
DA55:         	SAVE2:
DA55: 1198D4  		LD	DE,FCBDN 	;CLOSE SAVED FILE
DA58: CD45D6  		CALL	CLOSE
DA5B: 3C      		INC	A		;ERROR?
DA5C: 2007    		JR	NZ,SAVE3	;PASS IF OK
              	;
              	;  PRNLE IS ALSO USED BY MEMLOAD FOR TPA FULL ERROR
              	;
DA5E: CD0AD6  	PRNLE:	CALL	PRINTC		;DISK OR MEM FULL
DA61: 46756C  		DEFM	'Ful'
DA64: EC      		DEFB	'l'+80H
              	;
DA65: C326D6  	SAVE3:	JP	DEFDMA		;SET DMA TO 0080 AND RESTART CPR
              					; OR RETURN TO MLERR
              	;
              	; Test File in FCB for existence, ask user to delete if so, and abort if he
              	;  choses not to
              	;
DA68:         	EXTEST:
DA68: CD08D8  		CALL	SCANER		;EXTRACT FILE NAME
DA6B: C217D7  		JP	NZ,ERROR	;'?' IS NOT PERMITTED
DA6E: CDEAD7  		CALL	SLOGIN		;LOG IN SELECTED DISK
DA71: CD49D6  		CALL	SEARF		;LOOK FOR SPECIFIED FILE
DA74: 1198D4  		LD	DE,FCBDN	;PT TO FILE FCB
DA77: C8      		RET	Z		;OK IF NOT FOUND
DA78: D5      		PUSH	DE		;SAVE PTR TO FCB
DA79: CD0AD6  		CALL	PRINTC
DA7C: 44656C65		DEFM	'Delete File'
DA80: 74652046	
DA84: 696C65  	
DA87: BF      		DEFB	'?'+80H
DA88: CDB5D5  		CALL	CONIN		;GET RESPONSE
DA8B: D1      		POP	DE		;GET PTR TO FCB
DA8C: FE59    		CP	'Y'		;KEY ON YES
DA8E: C240D5  		JP	NZ,RSTCPR	;RESTART IF NO, SP RESET EVENTUALLY
DA91: D5      		PUSH	DE		;SAVE PTR TO FCB
DA92: CD5FD6  		CALL	DELETE		;DELETE FILE
DA95: D1      		POP	DE		;GET PTR TO FCB
DA96: C9      		RET
              	;
              		ENDIF			;RAS
              	;
              	;Section 5F
              	;Command: REN
              	;Function:  To change the name of an existing file
              	;Forms:
              	;	REN <New ufn>=<Old ufn>	Perform function
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
              	;
DA97:         	REN:
DA97: CD68DA  		CALL	EXTEST		;TEST FOR FILE EXISTENCE AND RETURN
              					; IF FILE DOESN'T EXIST; ABORT IF IT DOES
DA9A: 3AFFD7  		LD	A,(TEMPDR)	;SAVE CURRENT DEFAULT DISK
DA9D: F5      		PUSH	AF		;SAVE ON STACK
DA9E:         	REN0:
DA9E: 2198D4  		LD	HL,FCBDN 	;SAVE NEW FILE NAME
DAA1: 11A8D4  		LD	DE,FCBDM
DAA4: 011000  		LD	BC,16		;16 BYTES
DAA7: EDB0    		LDIR
DAA9: CD51D7  		CALL	ADVAN		;ADVANCE CIBPTR
DAAC: FE3D    		CP	'='		;'=' OK
DAAE: 2028    		JR	NZ,REN4
DAB0:         	REN1:
DAB0: EB      		EX	DE,HL		;PT TO CHAR AFTER '=' IN HL
DAB1: 23      		INC	HL
DAB2: 2256D4  		LD	(CIBPTR),HL	;SAVE PTR TO OLD FILE NAME
DAB5: CD08D8  		CALL	SCANER		;EXTRACT FILENAME.TYP TOKEN
DAB8: 201E    		JR	NZ,REN4		;ERROR IF ANY '?'
DABA: F1      		POP	AF		;GET OLD DEFAULT DRIVE
DABB: 47      		LD	B,A		;SAVE IT
DABC: 21FFD7  		LD	HL,TEMPDR	;COMPARE IT AGAINST CURRENT DEFAULT DRIVE
DABF: 7E      		LD	A,(HL)		;MATCH?
DAC0: B7      		OR	A
DAC1: 2804    		JR	Z,REN2
DAC3: B8      		CP	B		;CHECK FOR DRIVE ERROR
DAC4: 70      		LD	(HL),B
DAC5: 2011    		JR	NZ,REN4
DAC7:         	REN2:
DAC7: 70      		LD	(HL),B
DAC8: AF      		XOR	A
DAC9: 3298D4  		LD	(FCBDN),A	;SET DEFAULT DRIVE
DACC: 1198D4  		LD	DE,FCBDN 	;RENAME FILE
DACF: 0E17    		LD	C,17H		;BDOS RENAME FCT
DAD1: CD40D6  		CALL	GRBDOS
DAD4: C0      		RET	NZ
DAD5:         	REN3:
DAD5: CD54D5  		CALL	PRNNF		;PRINT NO FILE MSG
DAD8:         	REN4:
DAD8: C3FADB  		JP	ERRLOG
              	;
              		ENDIF			;RAS
              	;
              	;Section 5G
              	;Command: USER
              	;Function:  Change current USER number
              	;Forms:
              	;	USER <unum>	Select specified user number;<unum> is in DEC
              	;
              		IF	DRUSER		;IF DRIVE/USER CODE OK...
DADB:         	USER:
DADB: CD11D7  		CALL	USRNUM		;EXTRACT USER NUMBER FROM COMMAND LINE
DADE: 5F      		LD	E,A		;PLACE USER NUMBER IN E
DADF: CD6AD6  	SUSER:	CALL	SETUSR		;SET SPECIFIED USER
              		ENDIF			;DRUSER
DAE2:         	RSTJP:
DAE2: C343D5  		JP	RCPRNL		;RESTART CPR
              	;
              	;Section 5H
              	;Command: DFU
              	;Function:  Set the Default User Number for the command/file scanner
              	;	     (MEMLOAD)
              	;	    Note: When under SECURE mode, this will select the second
              	;	          user area to check for programs (normally user 15).
              	;
              	;Forms:
              	;	DFU <unum>	Select Default User Number;<unum> is in DEC
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
DAE5:         	DFU:
DAE5: CD11D7  		CALL	USRNUM		;GET USER NUMBER
DAE8: 32B7DB  		LD	(DFUSR),A	;PUT IT AWAY
DAEB: 18F5    		JR	RSTJP		;RESTART CPR (NO DEFAULT LOGIN)
              		ENDIF			;NOT RAS
              	;
              	;Section 5I
              	;Command: JUMP
              	;Function:  To Call the program (subroutine) at the specified address
              	;	     without loading from disk
              	;Forms:
              	;	JUMP <adr>		Call at <adr>;<adr> is in HEX
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
              	;
DAED:         	JUMP:
DAED: CDA1D7  		CALL	HEXNUM		;GET LOAD ADDRESS IN HL
DAF0: 1844    		JR	CALLPROG	;PERFORM CALL
              	;
              		ENDIF			;RAS
              	;
              	;Section 5J
              	;Command: GO
              	;Function:  To Call the program in the TPA without loading
              	;	     loading from disk. Same as JUMP 100H, but much
              	;	     more convenient, especially when used with
              	;	     parameters for programs like STAT. Also can be
              	;	     allowed on remote-access systems with no problems.
              	;
              	;Form:
              	;	GO <parameters like for COMMAND>
              	;
              		IF	RAS		;ONLY IF RAS
              	        ELSE
              	;
DAF2: 210001  	GO:	LD	HL,TPA		;Always to TPA
DAF5: 183F    		JR	CALLPROG	;Perform call
              	;
              		ENDIF			;END OF GO FOR RAS
              	;
              	;Section 5K
              	;Command: COM file processing
              	;Function:  To load the specified COM file from disk and execute it
              	;Forms:
              	;	<command>
              	;
DAF7:         	COM:
DAF7: 3A99D4  		LD	A,(FCBFN)	;ANY COMMAND?
DAFA: FE20    		CP	' '		;' ' MEANS COMMAND WAS 'D:' TO SWITCH
DAFC: 201D    		JR	NZ,COM1		;NOT <SP>, SO MUST BE TRANSIENT OR ERROR
DAFE: 3AFFD7  		LD	A,(TEMPDR)	;LOOK FOR DRIVE SPEC
DB01: B7      		OR	A		;IF ZERO, JUST BLANK
DB02: 28DE    		JR	Z,RSTJP
DB04: 3D      		DEC	A		;ADJUST FOR LOG IN
DB05: 327ED6  		LD	(TDRIVE),A	;SET DEFAULT DRIVE
DB08: CD7DD6  		CALL	SETU0D		;SET DRIVE WITH USER 0
DB0B: CD32D6  		CALL	LOGIN		;LOG IN DRIVE
              	;
              		IF	DRUSER		;DRIVE/USER HACKERY OK?
DB0E: CD11D7  		CALL	USRNUM		;GET USER #, IF ANY
DB11: 5F      		LD	E,A		;GET IT READY FOR BDOS
DB12: 3A99D4  		LD	A,(FCBFN)	;SEE IF # SPECIFIED
DB15: FE20    		CP	' '
DB17: 20C6    		JR	NZ,SUSER	;SELECT IF WANTED
              		ENDIF			;DRUSER
              	;
DB19: 18C7    		JR	RSTJP		;RESTART CPR
DB1B:         	COM1:
DB1B: 3AA1D4  		LD	A,(FCBFT)	;FILE TYPE MUST BE BLANK
DB1E: FE20    		CP	' '
DB20: C217D7  		JP	NZ,ERROR
DB23: 2174D4  		LD	HL,COMMSG	;PLACE DEFAULT FILE TYPE (COM) INTO FCB
DB26: 11A1D4  		LD	DE,FCBFT	;COPY INTO FILE TYPE
DB29: 010300  		LD	BC,3		;3 BYTES
DB2C: EDB0    		LDIR
DB2E: 210001  		LD	HL,TPA		;SET EXECUTION/LOAD ADDRESS
DB31: E5      		PUSH	HL		;SAVE FOR EXECUTION
DB32: CDA2DB  		CALL	MEMLOAD		;LOAD MEMORY WITH FILE SPECIFIED IN CMD LINE
              					; (NO RETURN IF ERROR OR TOO BIG)
DB35: E1      		POP	HL		;GET EXECUTION ADDRESS
              	;
              	; CALLPROG IS THE ENTRY POINT FOR THE EXECUTION OF THE LOADED
              	;   PROGRAM. ON ENTRY TO THIS ROUTINE, HL MUST CONTAIN THE EXECUTION
              	;   ADDRESS OF THE PROGRAM (SUBROUTINE) TO EXECUTE
              	;
DB36:         	CALLPROG:
DB36: 2289DB  		LD	(EXECADR),HL	;PERFORM IN-LINE CODE MODIFICATION
DB39: CDF4D7  		CALL	DLOGIN		;LOG IN DEFAULT DRIVE
DB3C: CD08D8  		CALL	SCANER		;SEARCH COMMAND LINE FOR NEXT TOKEN
DB3F: 21FFD7  		LD	HL,TEMPDR	;SAVE PTR TO DRIVE SPEC
DB42: E5      		PUSH	HL
DB43: 7E      		LD	A,(HL)		;SET DRIVE SPEC
DB44: 3298D4  		LD	(FCBDN),A
DB47: 21A8D4  		LD	HL,FCBDN+10H	;PT TO 2ND FILE NAME
DB4A: CD0BD8  		CALL	SCANX		;SCAN FOR IT AND LOAD IT INTO FCBDN+16
DB4D: E1      		POP	HL		;SET UP DRIVE SPECS
DB4E: 7E      		LD	A,(HL)
DB4F: 32A8D4  		LD	(FCBDM),A
DB52: AF      		XOR	A
DB53: 32B8D4  		LD	(FCBCR),A
DB56: 115C00  		LD	DE,TFCB		;COPY TO DEFAULT FCB
DB59: 2198D4  		LD	HL,FCBDN 	;FROM FCBDN
DB5C: 012100  		LD	BC,33		;SET UP DEFAULT FCB
DB5F: EDB0    		LDIR
DB61: 2104D4  		LD	HL,CIBUFF-1
DB64:         	COM4:
DB64: 23      		INC	HL
DB65: 7E      		LD	A,(HL)		;SKIP TO END OF 2ND FILE NAME
DB66: B7      		OR	A		;END OF LINE?
DB67: 2804    		JR	Z,COM5
DB69: FE20    		CP	' '		;END OF TOKEN?
DB6B: 20F7    		JR	NZ,COM4
              	;
              	; LOAD COMMAND LINE INTO TBUFF
              	;
DB6D:         	COM5:
DB6D: 06FF    		LD	B,-1		;SET CHAR COUNT
DB6F: 118000  		LD	DE,TBUFF	;PT TO CHAR POS
DB72: 2B      		DEC	HL
DB73:         	COM6:
DB73: 04      		INC	B		;INCR CHAR COUNT
DB74: 23      		INC	HL		;PT TO NEXT
DB75: 13      		INC	DE
DB76: 7E      		LD	A,(HL)		;COPY COMMAND LINE TO TBUFF
DB77: 12      		LD	(DE),A
DB78: B7      		OR	A		;DONE IF ZERO
DB79: 20F8    		JR	NZ,COM6
              	;
              	; RUN LOADED TRANSIENT PROGRAM
              	;
DB7B:         	COM7:
DB7B: 78      		LD	A,B		;SAVE CHAR COUNT
DB7C: 328000  		LD	(TBUFF),A
DB7F: CDA1D5  		CALL	CRLF		;NEW LINE
DB82: CD26D6  		CALL	DEFDMA		;SET DMA TO 0080
DB85: CD6ED6  		CALL	SETUD		;SET USER/DISK
              	;
              	; EXECUTION (CALL) OF PROGRAM (SUBROUTINE) OCCURS HERE
              	;
DB89:         	EXECADR	EQU	$+1		;CHANGE ADDRESS FOR IN-LINE CODE MODIFICATION
DB88: CD0001  		CALL	TPA		;CALL TRANSIENT
DB8B: CD26D6  		CALL	DEFDMA		;SET DMA TO 0080, IN CASE
              					;PROG CHANGED IT ON US
DB8E: CD7DD6  		CALL	SETU0D		;SET USER 0/DISK
DB91: CD32D6  		CALL	LOGIN		;LOGIN DISK
DB94: C3F2D4  		JP	RESTRT		;RESTART CPR
              	;
              	;Section 5L
              	;Command: GET
              	;Function:  To load the specified file from disk to the specified address
              	;Forms:
              	;	GET <adr> <ufn>	Load the specified file at the specified page;
              	;			<adr> is in HEX
              	;
              		IF	RAS		;NOT FOR REMOTE-ACCESS SYSTEM
              	        ELSE
              	;
DB97:         	GET:
DB97: CDA1D7  		CALL	HEXNUM		;GET LOAD ADDRESS IN HL
DB9A: E5      		PUSH	HL		;SAVE ADDRESS
DB9B: CD08D8  		CALL	SCANER		;GET FILE NAME
DB9E: E1      		POP	HL		;RESTORE ADDRESS
DB9F: C217D7  		JP	NZ,ERROR	;MUST BE UNAMBIGUOUS
              	;
              	; FALL THRU TO MEMLOAD
              	;
              		ENDIF			;RAS
              	;
              	; LOAD MEMORY WITH THE FILE WHOSE NAME IS SPECIFIED IN THE COMMAND LINE
              	;   ON INPUT, HL CONTAINS STARTING ADDRESS TO LOAD
              	;
              	;  EXIT BACK TO CALLER IF NO ERROR.  IF COM FILE TOO BIG OR
              	; OTHER ERROR, EXIT DIRECTLY TO MLERR.
              	;
DBA2:         	MEMLOAD:
DBA2: 22D5DB  		LD	(LOADADR),HL	;SET LOAD ADDRESS
DBA5: CD68D6  		CALL	GETUSR		;GET CURRENT USER NUMBER
DBA8: 3264D6  		LD	(TMPUSR),A	;SAVE IT FOR LATER
DBAB: 32B9DB  		LD	(TSELUSR),A	;TEMP USER TO SELECT
              	;
              	;   MLA is a reentry point for a non-standard CP/M Modification
              	; This is the return point for when the .COM (or GET) file is not found the
              	; first time, Drive A: is selected for a second attempt
              	;
DBAE:         	MLA:
DBAE: CDEAD7  		CALL	SLOGIN		;LOG IN SPECIFIED DRIVE IF ANY
DBB1: CD37D6  		CALL	OPENF		;OPEN COMMAND.COM FILE
DBB4: 201E    		JR	NZ,MLA1		;FILE FOUND - LOAD IT
              	;
              		IF	SECURE
              	;
              	;  IF SECURE ENABLED, SEARCH CURRENT DRIVE, CURRENT USER, THEN
              	; IF IN WHEEL MODE, SEARCH UNDER LAST USER SET BY DFU (ORIG
              	; "RESUSR" AFTER WARM BOOT) ON CURRENT DRIVE. IF NOT FOUND, OR
              	; NOT IN WHEEL MODE, THEN SEARCH ON CURRENT DRIVE, UNDER USER
              	; "DEFUSR". IF STILL NOT FOUND, LOOK AT SAME SERIES OF USERS
              	; ON DRIVE A.
              	;
              	DFLAG	EQU	$+1		;MARK IN-THE-CODE VARIABLE
              		LD	A,0		;HAVE WE CHECKED THIS DRIVE ALREADY?
              		OR	A
              		JR	NZ,MLA0		;PASS IF SO TO GO TO DRIVE A:
              		LD	A,(WHEEL)	;RESTRICTED PROGS ALLOWED?
              		CP	RESTRCT
              		JR	Z,MLA00		;PASS IF NOT
              		PUSH	BC		;PUSH BC
              		LD	A,(DFUSR)	;LOAD DEFAULT USER
              		LD	B,A		;PUT IT IN B
              		LD	A,(TSELUSR)	;CHECK CURR USER
              	DFUSR	EQU	$+1		;DEFAULT USER LOCATION
              		CP	RESUSR		;RESTRICTED USER?
              		LD	A,B		;ASSUME NOT
              		POP	BC		;RESTORE BC
              		JR	NZ,SETTSE	;GO TRY IF NOT
              	MLA00:				;SS IF NOT
              	TSELUSR	EQU	$+1		;MARK IN-THE-CODE VARIABLE
              		LD	A,0		;GET CURR USER
              		SUB	DEFUSR		;IS IT UNRESTRICTED COM AREA?
              		JR	Z,MLA0		;NO MORE CHOICES IF SO
              		LD	(DFLAG),A	;MAKE DFLAG NON-ZERO IF NOT
              		LD	A,DEFUSR	; AND TRY UNRESTRICTED COM AREA
              		ENDIF			;SECURE
              	;
              		IF	SECURE
              	        ELSE
DBB7:         	DFUSR	EQU	$+1		;MARK IN-THE-CODE VARIABLE
DBB6: 3E00    		LD	A,DEFUSR	;GET DEFAULT USER
DBB9:         	TSELUSR	EQU	$+1		;MARK IN-THE-CODE VARIABLE
DBB8: FE00    		CP	DEFUSR		;CHECK FOR THE USER AREA..
DBBA: 2809    		JR	Z,MLA0		;..EQUAL DEFAULT, AND JUMP IF SO
              		ENDIF			;NOT SECURE
              	;
DBBC:         	SETTSE:
DBBC: 32B9DB  		LD	(TSELUSR),A	;PUT DOWN NEW ONE
DBBF: 5F      		LD	E,A
DBC0: CD6AD6  		CALL	SETUSR		;GO SET NEW USER NUMBER
DBC3: 18E9    		JR	MLA		;AND TRY AGAIN
              	;
              	; ERROR ROUTINE TO SELECT DRIVE A: IF DEFAULT WAS ORIGINALLY SELECTED
              	;
DBC5:         	MLA0:
DBC5: 21FFD7  		LD	HL,TEMPDR	;GET DRIVE FROM CURRENT COMMAND
DBC8: AF      		XOR	A		;A=0
              	;
              		IF	SECURE
              		LD	(DFLAG),A	;ALLOW A: SEARCH
              		ENDIF			;SECURE
              	;
DBC9: B6      		OR	(HL)
DBCA: C2F7DB  		JP	NZ,MLERR	;ERROR IF ALREADY DISK A:
DBCD: 3601    		LD	(HL),1		;SELECT DRIVE A:
DBCF: 3A64D6  		LD	A,(TMPUSR)	;GO TO 'CURRENT' USER CODE
DBD2: 18E8    		JR	SETTSE
              	;
              	; FILE FOUND -- PROCEED WITH LOAD
              	;
DBD4:         	MLA1:
DBD5:         	LOADADR	EQU	$+1
DBD4: 210001  		LD	HL,TPA
DBD7:         	ML2:
DBD7: 3ED3    		LD	A,ENTRY/256-1	;GET HIGH-ORDER ADR OF JUST BELOW CPR
DBD9: BC      		CP	H		;ARE WE GOING TO OVERWRITE THE CPR?
DBDA: 3818    		JR	C,ML4		;ERROR IF SO
DBDC: E5      		PUSH	HL		;SAVE ADDRESS OF NEXT SECTOR
DBDD: EB      		EX	DE,HL		;... IN DE
DBDE: CD29D6  		CALL	DMASET		;SET DMA ADDRESS FOR LOAD
DBE1: 1198D4  		LD	DE,FCBDN 	;READ NEXT SECTOR
DBE4: CD01D6  		CALL	READ
DBE7: E1      		POP	HL		;GET ADDRESS OF NEXT SECTOR
DBE8: 2006    		JR	NZ,ML3		;READ ERROR OR EOF?
DBEA: 118000  		LD	DE,128		;MOVE 128 BYTES PER SECTOR
DBED: 19      		ADD	HL,DE		;PT TO NEXT SECTOR IN HL
DBEE: 18E7    		JR	ML2
              	;
DBF0:         	ML3:
DBF0: 3D      		DEC	A		;LOAD COMPLETE
DBF1: CA63D6  		JP	Z,RESETUSR	;IF ZERO, OK, GO RESET CORRECT USER #
              					; ON WAY OUT, ELSE FALL THRU TO PRNLE
              	;
              	;  TPA FULL
              	;
DBF4: CD5EDA  	ML4:	CALL	PRNLE		;PRINT MSG AND RESET DEF DMA
              	;
              	; TRANSIENT LOAD ERROR
              	;
DBF7:         	MLERR:
              					;NOTE THAT THERE IS AN EXTRA RETURN ADDRESS ON
              					; THE STACK. IT WILL BE TOSSED WHEN ERROR EXITS
              					; TO RESTRT, WHICH RELOADS SP.
DBF7: CD63D6  		CALL	RESETUSR	;RESET CURRENT USER NUMBER
              					;  RESET MUST BE DONE BEFORE LOGIN
DBFA:         	ERRLOG:
DBFA: CDF4D7  		CALL	DLOGIN		;LOG IN DEFAULT DISK
DBFD: C317D7  		JP	ERROR		;FLAG ERROR
              	;
              	;
              	;Section: 5M
              	;PASS:  Enable wheel mode.
              	;NORM:	Disable wheel mode.
              	;
              	;  Type PASS <password> <cr> to CP/M prompt to enter wheel mode.
              	; This code can be replaced with PST's PASS.ASM which gives many
              	; nice little options like no keyboard echo, etc.
              	;
              		IF	INPASS		;WE WANT TO USE THIS CODE, NOT PASS.COM
              	PASS:
              		LD	HL,PASSWD	;SET UP POINTERS
              		LD	DE,CIBUFF+NCHARS+1
              		LD	B,PRGEND-PASSWD	;B= LENGTH
              	CKPASS:	LD	A,(DE)		;TRIAL PW TO A
              		CP	(HL)		;CHECK FOR MATCH
              		JP	NZ,COM		;NOPE.. LOOK FOR PASS.COM
              		INC	HL		;INCREMENT COUNTER
              		INC	DE
              		DJNZ	CKPASS		;CONTINUE IF MORE
              		LD	A,NOT RESTRCT	;WHEEL = NOT RESTRCT
              	
              	PWOUT:	LD	(WHEEL),A
              		JP	RESTRT
              	;
              	NORM:
              		LD	A,RESTRCT
              		JR	PWOUT
              	;
              	PASSWD:
              		DEFM	'YOURPW'	;YOUR PASSWORD
              	PRGEND	EQU	$		;END OF PASSWORD
              	;
              		ENDIF			;INPASS
              	
              	;        DEFS    4
              	;
              	;; 	IF	($ GE CPRLOC+800H)
              	;; 	.PRINTX	/ZCPR exceeds 2K memory size !!!/
              	;; 	ENDIF
              	;; ;
              	;; 	END
              	
              	#include "../bdos.asm"
              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;*      Modified to build as single image from source
              	;*
              	;*
              	;*
              	;**************************************************************
              	
              	
              	
              	;
              	;   note that the following six bytes must match those at
              	; (pattrn1) or cp/m will halt. why?
              	;
DC00: 00160000	pattrn2:defb	0,22,0,0,0,0	;(* serial number bytes *).
DC04: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
DC06: C311DC  	fbase:	jp	fbase1
              	;
              	;   bdos error table.
              	;
DC09: 99DC    	badsctr:defw	error1		;bad sector on read or write.
DC0B: A5DC    	badslct:defw	error2		;bad disk select.
DC0D: ABDC    	rodisk:	defw	error3		;disk is read only.
DC0F: B1DC    	rofile:	defw	error4		;file is read only.
              	;
              	;   entry into bdos. (de) or (e) are the parameters passed. the
              	; function number desired is in register (c).
              	;
DC11: EB      	fbase1:	ex	de,hl		;save the (de) parameters.
DC12: 2243DF  		ld	(params),hl
DC15: EB      		ex	de,hl
DC16: 7B      		ld	a,e		;and save register (e) in particular.
DC17: 32D6E9  		ld	(eparam),a
DC1A: 210000  		ld	hl,0
DC1D: 2245DF  		ld	(status),hl	;clear return status.
DC20: 39      		add	hl,sp
DC21: 220FDF  		ld	(usrstack),hl	;save users stack pointer.
DC24: 3141DF  		ld	sp,stkarea	;and set our own.
DC27: AF      		xor	a		;clear auto select storage space.
DC28: 32E0E9  		ld	(autoflag),a
DC2B: 2174E9  		ld	hl,goback	;set return address.
DC2E: E5      		push	hl
DC2F: CD18EB  		call	bshook		; see if anyone wants to intercept the call
DC32: 79      		ld	a,c		;get function number.
DC33: FE29    		cp	nfuncts		;valid function number?
DC35: D0      		ret	nc
DC36: 4B      		ld	c,e		;keep single register function here.
DC37: 2147DC  		ld	hl,functns	;now look thru the function table.
DC3A: 5F      		ld	e,a
DC3B: 1600    		ld	d,0		;(de)=function number.
DC3D: 19      		add	hl,de
DC3E: 19      		add	hl,de		;(hl)=(start of table)+2*(function number).
DC3F: 5E      		ld	e,(hl)
DC40: 23      		inc	hl
DC41: 56      		ld	d,(hl)		;now (de)=address for this function.
DC42: 2A43DF  		ld	hl,(params)	;retrieve parameters.
DC45: EB      		ex	de,hl		;now (de) has the original parameters.
DC46: E9      		jp	(hl)		;execute desired function.
              	;
              	;   bdos function jump table.
              	;
0029:         	nfuncts equ	41		;number of functions in followin table.
              	;
DC47: 46EAC8DE	functns:defw	wboot,getcon,outcon,getrdr,punch,list,dircio,getiob
DC4B: 90DDCEDE	
DC4F: C7EAC3EA	
DC53: D4DEEDDE	
DC57: F3DEF8DE		defw	setiob,prtstr,rdbuff,getcsts,getver,rstdsk,setdsk,openfil
DC5B: E1DDFEDE	
DC5F: 7EE883E8	
DC63: 45E89CE8	
DC67: A5E8ABE8		defw	closefil,getfst,getnxt,delfile,readseq,wrtseq,fcreate
DC6B: C8E8D7E8	
DC6F: E0E8E6E8	
DC73: ECE8    	
DC75: F5E8FEE8		defw	renfile,getlog,getcrnt,putdma,getaloc,wrtprtd,getrov,setattr
DC79: 04E90AE9	
DC7D: 11E92CE1	
DC81: 17E91DE9	
DC85: 26E92DE9		defw	getparm,getuser,rdrandom,wtrandom,filesize,setran,logoff,rtn
DC89: 41E947E9	
DC8D: 4DE90EE8	
DC91: 53E904DF	
DC95: 04DF9BE9		defw	rtn,wtspecl
              	;
              	;   bdos error message section.
              	;
DC99: 21CADC  	error1:	ld	hl,badsec	;bad sector message.
DC9C: CDE5DC  		call	prterr		;print it and get a 1 char responce.
DC9F: FE03    		cp	cntrlc		;re-boot request (control-c)?
DCA1: CA0000  		jp	z,0		;yes.
DCA4: C9      		ret			;no, return to retry i/o function.
              	;
DCA5: 21D5DC  	error2:	ld	hl,badsel	;bad drive selected.
DCA8: C3B4DC  		jp	error5
              	;
DCAB: 21E1DC  	error3:	ld	hl,diskro	;disk is read only.
DCAE: C3B4DC  		jp	error5
              	;
DCB1: 21DCDC  	error4:	ld	hl,filero	;file is read only.
              	;
DCB4: CDE5DC  	error5:	call	prterr
DCB7: C341EA  		jp	eboot		;always reboot on these errors.
              	;
DCBA: 42646F73	bdoserr:defb	'Bdos Err on '
DCBE: 20457272	
DCC2: 206F6E20	
DCC6: 203A2024	bdosdrv:defb	' : $'
DCCA: 42616420	badsec:	defb	'Bad Sector$'
DCCE: 53656374	
DCD2: 6F7224  	
DCD5: 53656C65	badsel:	defb	'Select$'
DCD9: 637424  	
DCDC: 46696C65	filero:	defb	'File '
DCE0: 20      	
DCE1: 522F4F24	diskro:	defb	'R/O$'
              	;
              	;   print bdos error message.
              	;
DCE5: E5      	prterr:	push	hl		;save second message pointer.
DCE6: CDC9DD  		call	outcrlf		;send (cr)(lf).
DCE9: 3A42DF  		ld	a,(active)	;get active drive.
DCEC: C641    		add	a,'A'		;make ascii.
DCEE: 32C6DC  		ld	(bdosdrv),a	;and put in message.
DCF1: 01BADC  		ld	bc,bdoserr	;and print it.
DCF4: CDD3DD  		call	prtmesg
DCF7: C1      		pop	bc		;print second message line now.
DCF8: CDD3DD  		call	prtmesg
              	;
              	;   get an input character. we will check our 1 character
              	; buffer first. this may be set by the console status routine.
              	;
DCFB: 210EDF  	getchar:ld	hl,charbuf	;check character buffer.
DCFE: 7E      		ld	a,(hl)		;anything present already?
DCFF: 3600    		ld	(hl),0		;...either case clear it.
DD01: B7      		or	a
DD02: C0      		ret	nz		;yes, use it.
DD03: C3ABEA  		jp	conin		;nope, go get a character responce.
              	;
              	;   input and echo a character.
              	;
DD06: CDFBDC  	getecho:call	getchar		;input a character.
DD09: CD14DD  		call	chkchar		;carriage control?
DD0C: D8      		ret	c		;no, a regular control char so don't echo.
DD0D: F5      		push	af		;ok, save character now.
DD0E: 4F      		ld	c,a
DD0F: CD90DD  		call	outcon		;and echo it.
DD12: F1      		pop	af		;get character and return.
DD13: C9      		ret	
              	;
              	;   check character in (a). set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
DD14: FE0D    	chkchar:cp	cr		;check for carriage return, line feed, backspace,
DD16: C8      		ret	z		;or a tab.
DD17: FE0A    		cp	lf
DD19: C8      		ret	z
DD1A: FE09    		cp	tab
DD1C: C8      		ret	z
DD1D: FE08    		cp	bs
DD1F: C8      		ret	z
DD20: FE20    		cp	' '		;other control char? set carry flag.
DD22: C9      		ret	
              	;
              	;   check the console during output. halt on a control-s, then
              	; reboot on a control-c. if anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
DD23: 3A0EDF  	ckconsol: ld	a,(charbuf)	;check buffer.
DD26: B7      		or	a		;if anything, just return without checking.
DD27: C245DD  		jp	nz,ckcon2
DD2A: CDA0EA  		call	const		;nothing in buffer. check console.
DD2D: E601    		and	01h		;look at bit 0.
DD2F: C8      		ret	z		;return if nothing.
DD30: CDABEA  		call	conin		;ok, get it.
DD33: FE13    		cp	cntrls		;if not control-s, return with zero cleared.
DD35: C242DD  		jp	nz,ckcon1
DD38: CDABEA  		call	conin		;halt processing until another char
DD3B: FE03    		cp	cntrlc		;is typed. control-c?
DD3D: CA0000  		jp	z,0		;yes, reboot now.
DD40: AF      		xor	a		;no, just pretend nothing was ever ready.
DD41: C9      		ret	
DD42: 320EDF  	ckcon1:	ld	(charbuf),a	;save character in buffer for later processing.
DD45: 3E01    	ckcon2:	ld	a,1		;set (a) to non zero to mean something is ready.
DD47: C9      		ret	
              	;
              	;   output (c) to the screen. if the printer flip-flop flag
              	; is set, we will send character to printer also. the console
              	; will be checked in the process.
              	;
DD48: 3A0ADF  	outchar:ld	a,(outflag)	;check output flag.
DD4B: B7      		or	a		;anything and we won't generate output.
DD4C: C262DD  		jp	nz,outchr1
DD4F: C5      		push	bc
DD50: CD23DD  		call	ckconsol	;check console (we don't care whats there).
DD53: C1      		pop	bc
DD54: C5      		push	bc
DD55: CDB7EA  		call	conout		;output (c) to the screen.
DD58: C1      		pop	bc
DD59: C5      		push	bc
DD5A: 3A0DDF  		ld	a,(prtflag)	;check printer flip-flop flag.
DD5D: B7      		or	a
DD5E: C4C3EA  		call	nz,list		;print it also if non-zero.
DD61: C1      		pop	bc
DD62: 79      	outchr1:ld	a,c		;update cursors position.
DD63: 210CDF  		ld	hl,curpos
DD66: FE7F    		cp	del		;rubouts don't do anything here.
DD68: C8      		ret	z
DD69: 34      		inc	(hl)		;bump line pointer.
DD6A: FE20    		cp	' '		;and return if a normal character.
DD6C: D0      		ret	nc
DD6D: 35      		dec	(hl)		;restore and check for the start of the line.
DD6E: 7E      		ld	a,(hl)
DD6F: B7      		or	a
DD70: C8      		ret	z		;ingnore control characters at the start of the line.
DD71: 79      		ld	a,c
DD72: FE08    		cp	bs		;is it a backspace?
DD74: C279DD  		jp	nz,outchr2
DD77: 35      		dec	(hl)		;yes, backup pointer.
DD78: C9      		ret	
DD79: FE0A    	outchr2:cp	lf		;is it a line feed?
DD7B: C0      		ret	nz		;ignore anything else.
DD7C: 3600    		ld	(hl),0		;reset pointer to start of line.
DD7E: C9      		ret	
              	;
              	;   output (a) to the screen. if it is a control character
              	; (other than carriage control), use ^x format.
              	;
DD7F: 79      	showit:	ld	a,c
DD80: CD14DD  		call	chkchar		;check character.
DD83: D290DD  		jp	nc,outcon	;not a control, use normal output.
DD86: F5      		push	af
DD87: 0E5E    		ld	c,'^'		;for a control character, preceed it with '^'.
DD89: CD48DD  		call	outchar
DD8C: F1      		pop	af
DD8D: F640    		or	'@'		;and then use the letter equivelant.
DD8F: 4F      		ld	c,a
              	;
              	;   function to output (c) to the console device and expand tabs
              	; if necessary.
              	;
DD90: 79      	outcon:	ld	a,c
DD91: FE09    		cp	tab		;is it a tab?
DD93: C248DD  		jp	nz,outchar	;use regular output.
DD96: 0E20    	outcon1:ld	c,' '		;yes it is, use spaces instead.
DD98: CD48DD  		call	outchar
DD9B: 3A0CDF  		ld	a,(curpos)	;go until the cursor is at a multiple of 8
              	
DD9E: E607    		and	07h		;position.
DDA0: C296DD  		jp	nz,outcon1
DDA3: C9      		ret	
              	;
              	;   echo a backspace character. erase the prevoius character
              	; on the screen.
              	;
DDA4: CDACDD  	backup:	call	backup1		;backup the screen 1 place.
DDA7: 0E20    		ld	c,' '		;then blank that character.
DDA9: CDB7EA  		call	conout
DDAC: 0E08    	backup1:ld	c,bs		;then back space once more.
DDAE: C3B7EA  		jp	conout
              	;
              	;   signal a deleted line. print a '#' at the end and start
              	; over.
              	;
DDB1: 0E23    	newline:ld	c,'#'
DDB3: CD48DD  		call	outchar		;print this.
DDB6: CDC9DD  		call	outcrlf		;start new line.
DDB9: 3A0CDF  	newln1:	ld	a,(curpos)	;move the cursor to the starting position.
DDBC: 210BDF  		ld	hl,starting
DDBF: BE      		cp	(hl)
DDC0: D0      		ret	nc		;there yet?
DDC1: 0E20    		ld	c,' '
DDC3: CD48DD  		call	outchar		;nope, keep going.
DDC6: C3B9DD  		jp	newln1
              	;
              	;   output a (cr) (lf) to the console device (screen).
              	;
DDC9: 0E0D    	outcrlf:ld	c,cr
DDCB: CD48DD  		call	outchar
DDCE: 0E0A    		ld	c,lf
DDD0: C348DD  		jp	outchar
              	;
              	;   print message pointed to by (bc). it will end with a '$'.
              	;
DDD3: 0A      	prtmesg:ld	a,(bc)		;check for terminating character.
DDD4: FE24    		cp	'$'
DDD6: C8      		ret	z
DDD7: 03      		inc	bc
DDD8: C5      		push	bc		;otherwise, bump pointer and print it.
DDD9: 4F      		ld	c,a
DDDA: CD90DD  		call	outcon
DDDD: C1      		pop	bc
DDDE: C3D3DD  		jp	prtmesg
              	;
              	;   function to execute a buffered read.
              	;
DDE1: 3A0CDF  	rdbuff:	ld	a,(curpos)	;use present location as starting one.
DDE4: 320BDF  		ld	(starting),a
DDE7: 2A43DF  		ld	hl,(params)	;get the maximum buffer space.
DDEA: 4E      		ld	c,(hl)
DDEB: 23      		inc	hl		;point to first available space.
DDEC: E5      		push	hl		;and save.
DDED: 0600    		ld	b,0		;keep a character count.
DDEF: C5      	rdbuf1:	push	bc
DDF0: E5      		push	hl
DDF1: CDFBDC  	rdbuf2:	call	getchar		;get the next input character.
DDF4: E67F    		and	7fh		;strip bit 7.
DDF6: E1      		pop	hl		;reset registers.
DDF7: C1      		pop	bc
DDF8: FE0D    		cp	cr		;en of the line?
DDFA: CAC1DE  		jp	z,rdbuf17
DDFD: FE0A    		cp	lf
DDFF: CAC1DE  		jp	z,rdbuf17
DE02: FE08    		cp	bs		;how about a backspace?
DE04: C216DE  		jp	nz,rdbuf3
DE07: 78      		ld	a,b		;yes, but ignore at the beginning of the line.
DE08: B7      		or	a
DE09: CAEFDD  		jp	z,rdbuf1
DE0C: 05      		dec	b		;ok, update counter.
DE0D: 3A0CDF  		ld	a,(curpos)	;if we backspace to the start of the line,
DE10: 320ADF  		ld	(outflag),a	;treat as a cancel (control-x).
DE13: C370DE  		jp	rdbuf10
DE16: FE7F    	rdbuf3:	cp	del		;user typed a rubout?
DE18: C226DE  		jp	nz,rdbuf4
DE1B: 78      		ld	a,b		;ignore at the start of the line.
DE1C: B7      		or	a
DE1D: CAEFDD  		jp	z,rdbuf1
DE20: 7E      		ld	a,(hl)		;ok, echo the prevoius character.
DE21: 05      		dec	b		;and reset pointers (counters).
DE22: 2B      		dec	hl
DE23: C3A9DE  		jp	rdbuf15
DE26: FE05    	rdbuf4:	cp	cntrle		;physical end of line?
DE28: C237DE  		jp	nz,rdbuf5
DE2B: C5      		push	bc		;yes, do it.
DE2C: E5      		push	hl
DE2D: CDC9DD  		call	outcrlf
DE30: AF      		xor	a		;and update starting position.
DE31: 320BDF  		ld	(starting),a
DE34: C3F1DD  		jp	rdbuf2
DE37: FE10    	rdbuf5:	cp	cntrlp		;control-p?
DE39: C248DE  		jp	nz,rdbuf6
DE3C: E5      		push	hl		;yes, flip the print flag filp-flop byte.
DE3D: 210DDF  		ld	hl,prtflag
DE40: 3E01    		ld	a,1		;prtflag=1-prtflag
DE42: 96      		sub	(hl)
DE43: 77      		ld	(hl),a
DE44: E1      		pop	hl
DE45: C3EFDD  		jp	rdbuf1
DE48: FE18    	rdbuf6:	cp	cntrlx		;control-x (cancel)?
DE4A: C25FDE  		jp	nz,rdbuf8
DE4D: E1      		pop	hl
DE4E: 3A0BDF  	rdbuf7:	ld	a,(starting)	;yes, backup the cursor to here.
DE51: 210CDF  		ld	hl,curpos
DE54: BE      		cp	(hl)
DE55: D2E1DD  		jp	nc,rdbuff	;done yet?
DE58: 35      		dec	(hl)		;no, decrement pointer and output back up one space.
DE59: CDA4DD  		call	backup
DE5C: C34EDE  		jp	rdbuf7
DE5F: FE15    	rdbuf8:	cp	cntrlu		;cntrol-u (cancel line)?
DE61: C26BDE  		jp	nz,rdbuf9
DE64: CDB1DD  		call	newline		;start a new line.
DE67: E1      		pop	hl
DE68: C3E1DD  		jp	rdbuff
DE6B: FE12    	rdbuf9:	cp	cntrlr		;control-r?
DE6D: C2A6DE  		jp	nz,rdbuf14
DE70: C5      	rdbuf10:push	bc		;yes, start a new line and retype the old one.
DE71: CDB1DD  		call	newline
DE74: C1      		pop	bc
DE75: E1      		pop	hl
DE76: E5      		push	hl
DE77: C5      		push	bc
DE78: 78      	rdbuf11:ld	a,b		;done whole line yet?
DE79: B7      		or	a
DE7A: CA8ADE  		jp	z,rdbuf12
DE7D: 23      		inc	hl		;nope, get next character.
DE7E: 4E      		ld	c,(hl)
DE7F: 05      		dec	b		;count it.
DE80: C5      		push	bc
DE81: E5      		push	hl
DE82: CD7FDD  		call	showit		;and display it.
DE85: E1      		pop	hl
DE86: C1      		pop	bc
DE87: C378DE  		jp	rdbuf11
DE8A: E5      	rdbuf12:push	hl		;done with line. if we were displaying
DE8B: 3A0ADF  		ld	a,(outflag)	;then update cursor position.
DE8E: B7      		or	a
DE8F: CAF1DD  		jp	z,rdbuf2
DE92: 210CDF  		ld	hl,curpos	;because this line is shorter, we must
DE95: 96      		sub	(hl)		;back up the cursor (not the screen however)
DE96: 320ADF  		ld	(outflag),a	;some number of positions.
DE99: CDA4DD  	rdbuf13:call	backup		;note that as long as (outflag) is non
DE9C: 210ADF  		ld	hl,outflag	;zero, the screen will not be changed.
DE9F: 35      		dec	(hl)
DEA0: C299DE  		jp	nz,rdbuf13
DEA3: C3F1DD  		jp	rdbuf2		;now just get the next character.
              	;
              	;   just a normal character, put this in our buffer and echo.
              	;
DEA6: 23      	rdbuf14:inc	hl
DEA7: 77      		ld	(hl),a		;store character.
DEA8: 04      		inc	b		;and count it.
DEA9: C5      	rdbuf15:push	bc
DEAA: E5      		push	hl
DEAB: 4F      		ld	c,a		;echo it now.
DEAC: CD7FDD  		call	showit
DEAF: E1      		pop	hl
DEB0: C1      		pop	bc
DEB1: 7E      		ld	a,(hl)		;was it an abort request?
DEB2: FE03    		cp	cntrlc		;control-c abort?
DEB4: 78      		ld	a,b
DEB5: C2BDDE  		jp	nz,rdbuf16
DEB8: FE01    		cp	1		;only if at start of line.
DEBA: CA0000  		jp	z,0
DEBD: B9      	rdbuf16:cp	c		;nope, have we filled the buffer?
DEBE: DAEFDD  		jp	c,rdbuf1
DEC1: E1      	rdbuf17:pop	hl		;yes end the line and return.
DEC2: 70      		ld	(hl),b
DEC3: 0E0D    		ld	c,cr
DEC5: C348DD  		jp	outchar		;output (cr) and return.
              	;
              	;   function to get a character from the console device.
              	;
DEC8: CD06DD  	getcon:	call	getecho		;get and echo.
DECB: C301DF  		jp	setstat		;save status and return.
              	;
              	;   function to get a character from the tape reader device.
              	;
DECE: CDCBEA  	getrdr:	call	reader		;get a character from reader, set status and return.
DED1: C301DF  		jp	setstat
              	;
              	;  function to perform direct console i/o. if (c) contains (ff)
              	; then this is an input request. if (c) contains (fe) then
              	; this is a status request. otherwise we are to output (c).
              	;
DED4: 79      	dircio:	ld	a,c		;test for (ff).
DED5: 3C      		inc	a
DED6: CAE0DE  		jp	z,dirc1
DED9: 3C      		inc	a		;test for (fe).
DEDA: CAA0EA  		jp	z,const
DEDD: C3B7EA  		jp	conout		;just output (c).
DEE0: CDA0EA  	dirc1:	call	const		;this is an input request.
DEE3: B7      		or	a
DEE4: CA91E9  		jp	z,goback1	;not ready? just return (directly).
DEE7: CDABEA  		call	conin		;yes, get character.
DEEA: C301DF  		jp	setstat		;set status and return.
              	;
              	;   function to return the i/o byte.
              	;
DEED: 3A0300  	getiob:	ld	a,(iobyte)
DEF0: C301DF  		jp	setstat
              	;
              	;   function to set the i/o byte.
              	;
DEF3: 210300  	setiob:	ld	hl,iobyte
DEF6: 71      		ld	(hl),c
DEF7: C9      		ret	
              	;
              	;   function to print the character string pointed to by (de)
              	; on the console device. the string ends with a '$'.
              	;
DEF8: EB      	prtstr:	ex	de,hl
DEF9: 4D      		ld	c,l
DEFA: 44      		ld	b,h		;now (bc) points to it.
DEFB: C3D3DD  		jp	prtmesg
              	;
              	;   function to interigate the console device.
              	;
DEFE: CD23DD  	getcsts:call	ckconsol
              	;
              	;   get here to set the status and return to the cleanup
              	; section. then back to the user.
              	;
DF01: 3245DF  	setstat:ld	(status),a
DF04: C9      	rtn:	ret	
              	;
              	;   set the status to 1 (read or write error code).
              	;
DF05: 3E01    	ioerr1:	ld	a,1
DF07: C301DF  		jp	setstat
              	;
DF0A: 00      	outflag:defb	0		;output flag (non zero means no output).
DF0B: 02      	starting: defb	2		;starting position for cursor.
DF0C: 00      	curpos:	defb	0		;cursor position (0=start of line).
DF0D: 00      	prtflag:defb	0		;printer flag (control-p toggle). list if non zero.
DF0E: 00      	charbuf:defb	0		;single input character buffer.
              	;
              	;   stack area for bdos calls.
              	;
DF0F: 0000    	usrstack: defw	0		;save users stack pointer here.
              	;
DF11: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DF15: 00...   	
DF29: 00000000		defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DF2D: 00...   	
DF41:         	stkarea equ	$		;end of stack area.
              	;
DF41: 00      	userno:	defb	0		;current user number.
DF42: 00      	active:	defb	0		;currently active drive.
DF43: 0000    	params:	defw	0		;save (de) parameters here on entry.
DF45: 0000    	status:	defw	0		;status returned from bdos function.
              	;
              	;   select error occured, jump to error routine.
              	;
DF47: 210BDC  	slcterr:ld	hl,badslct
              	;
              	;   jump to (hl) indirectly.
              	;
DF4A: 5E      	jumphl:	ld	e,(hl)
DF4B: 23      		inc	hl
DF4C: 56      		ld	d,(hl)		;now (de) contain the desired address.
DF4D: EB      		ex	de,hl
DF4E: E9      		jp	(hl)
              	;
              	;   block move. (de) to (hl), (c) bytes total.
              	;
DF4F: 0C      	de2hl:	inc	c		;is count down to zero?
DF50: 0D      	de2hl1:	dec	c
DF51: C8      		ret	z		;yes, we are done.
DF52: 1A      		ld	a,(de)		;no, move one more byte.
DF53: 77      		ld	(hl),a
DF54: 13      		inc	de
DF55: 23      		inc	hl
DF56: C350DF  		jp	de2hl1		;and repeat.
              	;
              	;   select the desired drive.
              	;
DF59: 3A42DF  	select:	ld	a,(active)	;get active disk.
DF5C: 4F      		ld	c,a
DF5D: CDDEEA  		call	seldsk		;select it.
DF60: 7C      		ld	a,h		;valid drive?
DF61: B5      		or	l		;valid drive?
DF62: C8      		ret	z		;return if not.
              	;
              	;   here, the bios returned the address of the parameter block
              	; in (hl). we will extract the necessary pointers and save them.
              	;
DF63: 5E      		ld	e,(hl)		;yes, get address of translation table into (de).
DF64: 23      		inc	hl
DF65: 56      		ld	d,(hl)
DF66: 23      		inc	hl
DF67: 22B3E9  		ld	(scratch1),hl	;save pointers to scratch areas.
DF6A: 23      		inc	hl
DF6B: 23      		inc	hl
DF6C: 22B5E9  		ld	(scratch2),hl	;ditto.
DF6F: 23      		inc	hl
DF70: 23      		inc	hl
DF71: 22B7E9  		ld	(scratch3),hl	;ditto.
DF74: 23      		inc	hl
DF75: 23      		inc	hl
DF76: EB      		ex	de,hl		;now save the translation table address.
DF77: 22D0E9  		ld	(xlate),hl
DF7A: 21B9E9  		ld	hl,dirbuf	;put the next 8 bytes here.
DF7D: 0E08    		ld	c,8		;they consist of the directory buffer
DF7F: CD4FDF  		call	de2hl		;pointer, parameter block pointer,
DF82: 2ABBE9  		ld	hl,(diskpb)	;check and allocation vectors.
DF85: EB      		ex	de,hl
DF86: 21C1E9  		ld	hl,sectors	;move parameter block into our ram.
DF89: 0E0F    		ld	c,15		;it is 15 bytes long.
DF8B: CD4FDF  		call	de2hl
DF8E: 2AC6E9  		ld	hl,(dsksize)	;check disk size.
DF91: 7C      		ld	a,h		;more than 256 blocks on this?
DF92: 21DDE9  		ld	hl,bigdisk
DF95: 36FF    		ld	(hl),0ffh	;set to samll.
DF97: B7      		or	a
DF98: CA9DDF  		jp	z,select1
DF9B: 3600    		ld	(hl),0		;wrong, set to large.
DF9D: 3EFF    	select1:ld	a,0ffh		;clear the zero flag.
DF9F: B7      		or	a
DFA0: C9      		ret	
              	;
              	;   routine to home the disk track head and clear pointers.
              	;
DFA1: CDD9EA  	homedrv:call	home		;home the head.
DFA4: AF      		xor	a
DFA5: 2AB5E9  		ld	hl,(scratch2)	;set our track pointer also.
DFA8: 77      		ld	(hl),a
DFA9: 23      		inc	hl
DFAA: 77      		ld	(hl),a
DFAB: 2AB7E9  		ld	hl,(scratch3)	;and our sector pointer.
DFAE: 77      		ld	(hl),a
DFAF: 23      		inc	hl
DFB0: 77      		ld	(hl),a
DFB1: C9      		ret	
              	;
              	;   do the actual disk read and check the error return status.
              	;
DFB2: CD0AEB  	doread:	call	read
DFB5: C3BBDF  		jp	ioret
              	;
              	;   do the actual disk write and handle any bios error.
              	;
DFB8: CD0EEB  	dowrite:call	write
DFBB: B7      	ioret:	or	a
DFBC: C8      		ret	z		;return unless an error occured.
DFBD: 2109DC  		ld	hl,badsctr	;bad read/write on this sector.
DFC0: C34ADF  		jp	jumphl
              	;
              	;   routine to select the track and sector that the desired
              	; block number falls in.
              	;
DFC3: 2AEAE9  	trksec:	ld	hl,(filepos)	;get position of last accessed file
DFC6: 0E02    		ld	c,2		;in directory and compute sector #.
DFC8: CDEAE0  		call	shiftr		;sector #=file-position/4.
DFCB: 22E5E9  		ld	(blknmbr),hl	;save this as the block number of interest.
DFCE: 22ECE9  		ld	(cksumtbl),hl	;what's it doing here too?
              	;
              	;   if the sector number has already been set (blknmbr), enter
              	; at this point.
              	;
DFD1: 21E5E9  	trksec1:ld	hl,blknmbr
DFD4: 4E      		ld	c,(hl)		;move sector number into (bc).
DFD5: 23      		inc	hl
DFD6: 46      		ld	b,(hl)
DFD7: 2AB7E9  		ld	hl,(scratch3)	;get current sector number and
DFDA: 5E      		ld	e,(hl)		;move this into (de).
DFDB: 23      		inc	hl
DFDC: 56      		ld	d,(hl)
DFDD: 2AB5E9  		ld	hl,(scratch2)	;get current track number.
DFE0: 7E      		ld	a,(hl)		;and this into (hl).
DFE1: 23      		inc	hl
DFE2: 66      		ld	h,(hl)
DFE3: 6F      		ld	l,a
DFE4: 79      	trksec2:ld	a,c		;is desired sector before current one?
DFE5: 93      		sub	e
DFE6: 78      		ld	a,b
DFE7: 9A      		sbc	a,d
DFE8: D2FADF  		jp	nc,trksec3
DFEB: E5      		push	hl		;yes, decrement sectors by one track.
DFEC: 2AC1E9  		ld	hl,(sectors)	;get sectors per track.
DFEF: 7B      		ld	a,e
DFF0: 95      		sub	l
DFF1: 5F      		ld	e,a
DFF2: 7A      		ld	a,d
DFF3: 9C      		sbc	a,h
DFF4: 57      		ld	d,a		;now we have backed up one full track.
DFF5: E1      		pop	hl
DFF6: 2B      		dec	hl		;adjust track counter.
DFF7: C3E4DF  		jp	trksec2
DFFA: E5      	trksec3:push	hl		;desired sector is after current one.
DFFB: 2AC1E9  		ld	hl,(sectors)	;get sectors per track.
DFFE: 19      		add	hl,de		;bump sector pointer to next track.
DFFF: DA0FE0  		jp	c,trksec4
E002: 79      		ld	a,c		;is desired sector now before current one?
E003: 95      		sub	l
E004: 78      		ld	a,b
E005: 9C      		sbc	a,h
E006: DA0FE0  		jp	c,trksec4
E009: EB      		ex	de,hl		;not yes, increment track counter
E00A: E1      		pop	hl		;and continue until it is.
E00B: 23      		inc	hl
E00C: C3FADF  		jp	trksec3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
E00F: E1      	trksec4:pop	hl		;get track number (hl).
E010: C5      		push	bc
E011: D5      		push	de
E012: E5      		push	hl
E013: EB      		ex	de,hl
E014: 2ACEE9  		ld	hl,(offset)	;adjust for first track offset.
E017: 19      		add	hl,de
E018: 44      		ld	b,h
E019: 4D      		ld	c,l
E01A: CDFCEA  		call	settrk		;select this track.
E01D: D1      		pop	de		;reset current track pointer.
E01E: 2AB5E9  		ld	hl,(scratch2)
E021: 73      		ld	(hl),e
E022: 23      		inc	hl
E023: 72      		ld	(hl),d
E024: D1      		pop	de
E025: 2AB7E9  		ld	hl,(scratch3)	;reset the first sector on this track.
E028: 73      		ld	(hl),e
E029: 23      		inc	hl
E02A: 72      		ld	(hl),d
E02B: C1      		pop	bc
E02C: 79      		ld	a,c		;now subtract the desired one.
E02D: 93      		sub	e		;to make it relative (1-# sectors/track).
E02E: 4F      		ld	c,a
E02F: 78      		ld	a,b
E030: 9A      		sbc	a,d
E031: 47      		ld	b,a
E032: 2AD0E9  		ld	hl,(xlate)	;translate this sector according to this table.
E035: EB      		ex	de,hl
E036: CD15EB  		call	sectrn		;let the bios translate it.
E039: 4D      		ld	c,l
E03A: 44      		ld	b,h
E03B: C300EB  		jp	setsec		;and select it.
              	;
              	;   compute block number from record number (savnrec) and
              	; extent number (savext).
              	;
E03E: 21C3E9  	getblock: ld	hl,blkshft	;get logical to physical conversion.
E041: 4E      		ld	c,(hl)		;note that this is base 2 log of ratio.
E042: 3AE3E9  		ld	a,(savnrec)	;get record number.
E045: B7      	getblk1:or	a		;compute (a)=(a)/2^blkshft.
E046: 1F      		rra	
E047: 0D      		dec	c
E048: C245E0  		jp	nz,getblk1
E04B: 47      		ld	b,a		;save result in (b).
E04C: 3E08    		ld	a,8
E04E: 96      		sub	(hl)
E04F: 4F      		ld	c,a		;compute (c)=8-blkshft.
E050: 3AE2E9  		ld	a,(savext)
E053: 0D      	getblk2:dec	c		;compute (a)=savext*2^(8-blkshft).
E054: CA5CE0  		jp	z,getblk3
E057: B7      		or	a
E058: 17      		rla	
E059: C353E0  		jp	getblk2
E05C: 80      	getblk3:add	a,b
E05D: C9      		ret	
              	;
              	;   routine to extract the (bc) block byte from the fcb pointed
              	; to by (params). if this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; number is returned in (hl).
              	;
E05E: 2A43DF  	extblk:	ld	hl,(params)	;get fcb address.
E061: 111000  		ld	de,16		;block numbers start 16 bytes into fcb.
E064: 19      		add	hl,de
E065: 09      		add	hl,bc
E066: 3ADDE9  		ld	a,(bigdisk)	;are we using a big-disk?
E069: B7      		or	a
E06A: CA71E0  		jp	z,extblk1
E06D: 6E      		ld	l,(hl)		;no, extract an 8 bit number from the fcb.
E06E: 2600    		ld	h,0
E070: C9      		ret	
E071: 09      	extblk1:add	hl,bc		;yes, extract a 16 bit number.
E072: 5E      		ld	e,(hl)
E073: 23      		inc	hl
E074: 56      		ld	d,(hl)
E075: EB      		ex	de,hl		;return in (hl).
E076: C9      		ret	
              	;
              	;   compute block number.
              	;
E077: CD3EE0  	comblk:	call	getblock
E07A: 4F      		ld	c,a
E07B: 0600    		ld	b,0
E07D: CD5EE0  		call	extblk
E080: 22E5E9  		ld	(blknmbr),hl
E083: C9      		ret	
              	;
              	;   check for a zero block number (unused).
              	;
E084: 2AE5E9  	chkblk:	ld	hl,(blknmbr)
E087: 7D      		ld	a,l		;is it zero?
E088: B4      		or	h
E089: C9      		ret	
              	;
              	;   adjust physical block (blknmbr) and convert to logical
              	; sector (logsect). this is the starting sector of this block.
              	; the actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (blknmbr). this
              	; will still have to be adjusted for the track number.
              	;
E08A: 3AC3E9  	logical:ld	a,(blkshft)	;get log2(physical/logical sectors).
E08D: 2AE5E9  		ld	hl,(blknmbr)	;get physical sector desired.
E090: 29      	logicl1:add	hl,hl		;compute logical sector number.
E091: 3D      		dec	a		;note logical sectors are 128 bytes long.
E092: C290E0  		jp	nz,logicl1
E095: 22E7E9  		ld	(logsect),hl	;save logical sector.
E098: 3AC4E9  		ld	a,(blkmask)	;get block mask.
E09B: 4F      		ld	c,a
E09C: 3AE3E9  		ld	a,(savnrec)	;get next sector to access.
E09F: A1      		and	c		;extract the relative position within physical block.
E0A0: B5      		or	l		;and add it too logical sector.
E0A1: 6F      		ld	l,a
E0A2: 22E5E9  		ld	(blknmbr),hl	;and store.
E0A5: C9      		ret	
              	;
              	;   set (hl) to point to extent byte in fcb.
              	;
E0A6: 2A43DF  	setext:	ld	hl,(params)
E0A9: 110C00  		ld	de,12		;it is the twelth byte.
E0AC: 19      		add	hl,de
E0AD: C9      		ret	
              	;
              	;   set (hl) to point to record count byte in fcb and (de) to
              	; next record number byte.
              	;
E0AE: 2A43DF  	sethlde:ld	hl,(params)
E0B1: 110F00  		ld	de,15		;record count byte (#15).
E0B4: 19      		add	hl,de
E0B5: EB      		ex	de,hl
E0B6: 211100  		ld	hl,17		;next record number (#32).
E0B9: 19      		add	hl,de
E0BA: C9      		ret	
              	;
              	;   save current file data from fcb.
              	;
E0BB: CDAEE0  	strdata:call	sethlde
E0BE: 7E      		ld	a,(hl)		;get and store record count byte.
E0BF: 32E3E9  		ld	(savnrec),a
E0C2: EB      		ex	de,hl
E0C3: 7E      		ld	a,(hl)		;get and store next record number byte.
E0C4: 32E1E9  		ld	(savnxt),a
E0C7: CDA6E0  		call	setext		;point to extent byte.
E0CA: 3AC5E9  		ld	a,(extmask)	;get extent mask.
E0CD: A6      		and	(hl)
E0CE: 32E2E9  		ld	(savext),a	;and save extent here.
E0D1: C9      		ret	
              	;
              	;   set the next record to access. if (mode) is set to 2, then
              	; the last record byte (savnrec) has the correct number to access.
              	; for sequential access, (mode) will be equal to 1.
              	;
E0D2: CDAEE0  	setnrec:call	sethlde
E0D5: 3AD5E9  		ld	a,(mode)	;get sequential flag (=1).
E0D8: FE02    		cp	2		;a 2 indicates that no adder is needed.
E0DA: C2DEE0  		jp	nz,stnrec1
E0DD: AF      		xor	a		;clear adder (random access?).
E0DE: 4F      	stnrec1:ld	c,a
E0DF: 3AE3E9  		ld	a,(savnrec)	;get last record number.
E0E2: 81      		add	a,c		;increment record count.
E0E3: 77      		ld	(hl),a		;and set fcb's next record byte.
E0E4: EB      		ex	de,hl
E0E5: 3AE1E9  		ld	a,(savnxt)	;get next record byte from storage.
E0E8: 77      		ld	(hl),a		;and put this into fcb as number of records used.
E0E9: C9      		ret	
              	;
              	;   shift (hl) right (c) bits.
              	;
E0EA: 0C      	shiftr:	inc	c
E0EB: 0D      	shiftr1:dec	c
E0EC: C8      		ret	z
E0ED: 7C      		ld	a,h
E0EE: B7      		or	a
E0EF: 1F      		rra	
E0F0: 67      		ld	h,a
E0F1: 7D      		ld	a,l
E0F2: 1F      		rra	
E0F3: 6F      		ld	l,a
E0F4: C3EBE0  		jp	shiftr1
              	;
              	;   compute the check-sum for the directory buffer. return
              	; integer sum in (a).
              	;
E0F7: 0E80    	checksum: ld	c,128		;length of buffer.
E0F9: 2AB9E9  		ld	hl,(dirbuf)	;get its location.
E0FC: AF      		xor	a		;clear summation byte.
E0FD: 86      	chksum1:add	a,(hl)		;and compute sum ignoring carries.
E0FE: 23      		inc	hl
E0FF: 0D      		dec	c
E100: C2FDE0  		jp	nz,chksum1
E103: C9      		ret	
              	;
              	;   shift (hl) left (c) bits.
              	;
E104: 0C      	shiftl:	inc	c
E105: 0D      	shiftl1:dec	c
E106: C8      		ret	z
E107: 29      		add	hl,hl		;shift left 1 bit.
E108: C305E1  		jp	shiftl1
              	;
              	;   routine to set a bit in a 16 bit value contained in (bc).
              	; the bit set depends on the current drive selection.
              	;
E10B: C5      	setbit:	push	bc		;save 16 bit word.
E10C: 3A42DF  		ld	a,(active)	;get active drive.
E10F: 4F      		ld	c,a
E110: 210100  		ld	hl,1
E113: CD04E1  		call	shiftl		;shift bit 0 into place.
E116: C1      		pop	bc		;now 'or' this with the original word.
E117: 79      		ld	a,c
E118: B5      		or	l
E119: 6F      		ld	l,a		;low byte done, do high byte.
E11A: 78      		ld	a,b
E11B: B4      		or	h
E11C: 67      		ld	h,a
E11D: C9      		ret	
              	;
              	;   extract the write protect status bit for the current drive.
              	; the result is returned in (a), bit 0.
              	;
E11E: 2AADE9  	getwprt:ld	hl,(wrtprt)	;get status bytes.
E121: 3A42DF  		ld	a,(active)	;which drive is current?
E124: 4F      		ld	c,a
E125: CDEAE0  		call	shiftr		;shift status such that bit 0 is the
E128: 7D      		ld	a,l		;one of interest for this drive.
E129: E601    		and	01h		;and isolate it.
E12B: C9      		ret	
              	;
              	;   function to write protect the current disk.
              	;
E12C: 21ADE9  	wrtprtd:ld	hl,wrtprt	;point to status word.
E12F: 4E      		ld	c,(hl)		;set (bc) equal to the status.
E130: 23      		inc	hl
E131: 46      		ld	b,(hl)
E132: CD0BE1  		call	setbit		;and set this bit according to current drive.
E135: 22ADE9  		ld	(wrtprt),hl	;then save.
E138: 2AC8E9  		ld	hl,(dirsize)	;now save directory size limit.
E13B: 23      		inc	hl		;remember the last one.
E13C: EB      		ex	de,hl
E13D: 2AB3E9  		ld	hl,(scratch1)	;and store it here.
E140: 73      		ld	(hl),e		;put low byte.
E141: 23      		inc	hl
E142: 72      		ld	(hl),d		;then high byte.
E143: C9      		ret	
              	;
              	;   check for a read only file.
              	;
E144: CD5EE1  	chkrofl:call	fcb2hl		;set (hl) to file entry in directory buffer.
E147: 110900  	ckrof1:	ld	de,9		;look at bit 7 of the ninth byte.
E14A: 19      		add	hl,de
E14B: 7E      		ld	a,(hl)
E14C: 17      		rla	
E14D: D0      		ret	nc		;return if ok.
E14E: 210FDC  		ld	hl,rofile	;else, print error message and terminate.
E151: C34ADF  		jp	jumphl
              	;
              	;   check the write protect status of the active disk.
              	;
E154: CD1EE1  	chkwprt:call	getwprt
E157: C8      		ret	z		;return if ok.
E158: 210DDC  		ld	hl,rodisk	;else print message and terminate.
E15B: C34ADF  		jp	jumphl
              	;
              	;   routine to set (hl) pointing to the proper entry in the
              	; directory buffer.
              	;
E15E: 2AB9E9  	fcb2hl:	ld	hl,(dirbuf)	;get address of buffer.
E161: 3AE9E9  		ld	a,(fcbpos)	;relative position of file.
              	;
              	;   routine to add (a) to (hl).
              	;
E164: 85      	adda2hl:add	a,l
E165: 6F      		ld	l,a
E166: D0      		ret	nc
E167: 24      		inc	h		;take care of any carry.
E168: C9      		ret	
              	;
              	;   routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
E169: 2A43DF  	gets2:	ld	hl,(params)	;get address of fcb.
E16C: 110E00  		ld	de,14		;relative position of 's2'.
E16F: 19      		add	hl,de
E170: 7E      		ld	a,(hl)		;extract this byte.
E171: C9      		ret	
              	;
              	;   clear the 's2' byte in the fcb.
              	;
E172: CD69E1  	clears2:call	gets2		;this sets (hl) pointing to it.
E175: 3600    		ld	(hl),0		;now clear it.
E177: C9      		ret	
              	;
              	;   set bit 7 in the 's2' byte of the fcb.
              	;
E178: CD69E1  	sets2b7:call	gets2		;get the byte.
E17B: F680    		or	80h		;and set bit 7.
E17D: 77      		ld	(hl),a		;then store.
E17E: C9      		ret	
              	;
              	;   compare (filepos) with (scratch1) and set flags based on
              	; the difference. this checks to see if there are more file
              	; names in the directory. we are at (filepos) and there are
              	; (scratch1) of them to check.
              	;
E17F: 2AEAE9  	morefls:ld	hl,(filepos)	;we are here.
E182: EB      		ex	de,hl
E183: 2AB3E9  		ld	hl,(scratch1)	;and don't go past here.
E186: 7B      		ld	a,e		;compute difference but don't keep.
E187: 96      		sub	(hl)
E188: 23      		inc	hl
E189: 7A      		ld	a,d
E18A: 9E      		sbc	a,(hl)		;set carry if no more names.
E18B: C9      		ret	
              	;
              	;   call this routine to prevent (scratch1) from being greater
              	; than (filepos).
              	;
E18C: CD7FE1  	chknmbr:call	morefls		;scratch1 too big?
E18F: D8      		ret	c
E190: 13      		inc	de		;yes, reset it to (filepos).
E191: 72      		ld	(hl),d
E192: 2B      		dec	hl
E193: 73      		ld	(hl),e
E194: C9      		ret	
              	;
              	;   compute (hl)=(de)-(hl)
              	;
E195: 7B      	subhl:	ld	a,e		;compute difference.
E196: 95      		sub	l
E197: 6F      		ld	l,a		;store low byte.
E198: 7A      		ld	a,d
E199: 9C      		sbc	a,h
E19A: 67      		ld	h,a		;and then high byte.
E19B: C9      		ret	
              	;
              	;   set the directory checksum byte.
              	;
E19C: 0EFF    	setdir:	ld	c,0ffh
              	;
              	;   routine to set or compare the directory checksum byte. if
              	; (c)=0ffh, then this will set the checksum byte. else the byte
              	; will be checked. if the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
E19E: 2AECE9  	checkdir: ld	hl,(cksumtbl)
E1A1: EB      		ex	de,hl
E1A2: 2ACCE9  		ld	hl,(alloc1)
E1A5: CD95E1  		call	subhl
E1A8: D0      		ret	nc		;ok if (cksumtbl) > (alloc1), so return.
E1A9: C5      		push	bc
E1AA: CDF7E0  		call	checksum	;else compute checksum.
E1AD: 2ABDE9  		ld	hl,(chkvect)	;get address of checksum table.
E1B0: EB      		ex	de,hl
E1B1: 2AECE9  		ld	hl,(cksumtbl)
E1B4: 19      		add	hl,de		;set (hl) to point to byte for this drive.
E1B5: C1      		pop	bc
E1B6: 0C      		inc	c		;set or check ?
E1B7: CAC4E1  		jp	z,chkdir1
E1BA: BE      		cp	(hl)		;check them.
E1BB: C8      		ret	z		;return if they are the same.
E1BC: CD7FE1  		call	morefls		;not the same, do we care?
E1BF: D0      		ret	nc
E1C0: CD2CE1  		call	wrtprtd		;yes, mark this as write protected.
E1C3: C9      		ret	
E1C4: 77      	chkdir1:ld	(hl),a		;just set the byte.
E1C5: C9      		ret	
              	;
              	;   do a write to the directory of the current disk.
              	;
E1C6: CD9CE1  	dirwrite: call	setdir		;set checksum byte.
E1C9: CDE0E1  		call	dirdma		;set directory dma address.
E1CC: 0E01    		ld	c,1		;tell the bios to actually write.
E1CE: CDB8DF  		call	dowrite		;then do the write.
E1D1: C3DAE1  		jp	defdma
              	;
              	;   read from the directory.
              	;
E1D4: CDE0E1  	dirread:call	dirdma		;set the directory dma address.
E1D7: CDB2DF  		call	doread		;and read it.
              	;
              	;   routine to set the dma address to the users choice.
              	;
E1DA: 21B1E9  	defdma:	ld	hl,userdma	;reset the default dma address and return.
E1DD: C3E3E1  		jp	dirdma1
              	;
              	;   routine to set the dma address for directory work.
              	;
E1E0: 21B9E9  	dirdma:	ld	hl,dirbuf
              	;
              	;   set the dma address. on entry, (hl) points to
              	; word containing the desired dma address.
              	;
E1E3: 4E      	dirdma1:ld	c,(hl)
E1E4: 23      		inc	hl
E1E5: 46      		ld	b,(hl)		;setup (bc) and go to the bios to set it.
E1E6: C304EB  		jp	setdma
              	;
              	;   move the directory buffer into user's dma space.
              	;
E1E9: 2AB9E9  	movedir:ld	hl,(dirbuf)	;buffer is located here, and
E1EC: EB      		ex	de,hl
E1ED: 2AB1E9  		ld	hl,(userdma)	; put it here.
E1F0: 0E80    		ld	c,128		;this is its length.
E1F2: C34FDF  		jp	de2hl		;move it now and return.
              	;
              	;   check (filepos) and set the zero flag if it equals 0ffffh.
              	;
E1F5: 21EAE9  	ckfilpos: ld	hl,filepos
E1F8: 7E      		ld	a,(hl)
E1F9: 23      		inc	hl
E1FA: BE      		cp	(hl)		;are both bytes the same?
E1FB: C0      		ret	nz
E1FC: 3C      		inc	a		;yes, but are they each 0ffh?
E1FD: C9      		ret	
              	;
              	;   set location (filepos) to 0ffffh.
              	;
E1FE: 21FFFF  	stfilpos: ld	hl,0ffffh
E201: 22EAE9  		ld	(filepos),hl
E204: C9      		ret	
              	;
              	;   move on to the next file position within the current
              	; directory buffer. if no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. enter with (c)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
E205: 2AC8E9  	nxentry:ld	hl,(dirsize)	;get directory entry size limit.
E208: EB      		ex	de,hl
E209: 2AEAE9  		ld	hl,(filepos)	;get current count.
E20C: 23      		inc	hl		;go on to the next one.
E20D: 22EAE9  		ld	(filepos),hl
E210: CD95E1  		call	subhl		;(hl)=(dirsize)-(filepos)
E213: D219E2  		jp	nc,nxent1	;is there more room left?
E216: C3FEE1  		jp	stfilpos	;no. set this flag and return.
E219: 3AEAE9  	nxent1:	ld	a,(filepos)	;get file position within directory.
E21C: E603    		and	03h		;only look within this sector (only 4 entries fit).
E21E: 0605    		ld	b,5		;convert to relative position (32 bytes each).
E220: 87      	nxent2:	add	a,a		;note that this is not efficient code.
E221: 05      		dec	b		;5 'add a's would be better.
E222: C220E2  		jp	nz,nxent2
E225: 32E9E9  		ld	(fcbpos),a	;save it as position of fcb.
E228: B7      		or	a
E229: C0      		ret	nz		;return if we are within buffer.
E22A: C5      		push	bc
E22B: CDC3DF  		call	trksec		;we need the next directory sector.
E22E: CDD4E1  		call	dirread
E231: C1      		pop	bc
E232: C39EE1  		jp	checkdir
              	;
              	;   routine to to get a bit from the disk space allocation
              	; map. it is returned in (a), bit position 0. on entry to here,
              	; set (bc) to the block number on the disk to check.
              	; on return, (d) will contain the original bit position for
              	; this block number and (hl) will point to the address for it.
              	;
E235: 79      	ckbitmap: ld	a,c		;determine bit number of interest.
E236: E607    		and	07h		;compute (d)=(e)=(c and 7)+1.
E238: 3C      		inc	a
E239: 5F      		ld	e,a		;save particular bit number.
E23A: 57      		ld	d,a
              	;
              	;   compute (bc)=(bc)/8.
              	;
E23B: 79      		ld	a,c
E23C: 0F      		rrca			;now shift right 3 bits.
E23D: 0F      		rrca	
E23E: 0F      		rrca	
E23F: E61F    		and	1fh		;and clear bits 7,6,5.
E241: 4F      		ld	c,a
E242: 78      		ld	a,b
E243: 87      		add	a,a		;now shift (b) into bits 7,6,5.
E244: 87      		add	a,a
E245: 87      		add	a,a
E246: 87      		add	a,a
E247: 87      		add	a,a
E248: B1      		or	c		;and add in (c).
E249: 4F      		ld	c,a		;ok, (c) ha been completed.
E24A: 78      		ld	a,b		;is there a better way of doing this?
E24B: 0F      		rrca	
E24C: 0F      		rrca	
E24D: 0F      		rrca	
E24E: E61F    		and	1fh
E250: 47      		ld	b,a		;and now (b) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
E251: 2ABFE9  		ld	hl,(alocvect)
E254: 09      		add	hl,bc
E255: 7E      		ld	a,(hl)		;now get correct byte.
E256: 07      	ckbmap1:rlca			;get correct bit into position 0.
E257: 1D      		dec	e
E258: C256E2  		jp	nz,ckbmap1
E25B: C9      		ret	
              	;
              	;   set or clear the bit map such that block number (bc) will be marked
              	; as used. on entry, if (e)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
E25C: D5      	stbitmap: push	de
E25D: CD35E2  		call	ckbitmap	;get the byte of interest.
E260: E6FE    		and	0feh		;clear the affected bit.
E262: C1      		pop	bc
E263: B1      		or	c		;and now set it acording to (c).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (a) contains the value, (d) contains the bit
              	; position (1-8), and (hl) points to the address within the
              	; space allocation table for this byte.
              	;
E264: 0F      	stbmap1:rrca			;restore original bit position.
E265: 15      		dec	d
E266: C264E2  		jp	nz,stbmap1
E269: 77      		ld	(hl),a		;and stor byte in table.
E26A: C9      		ret	
              	;
              	;   set/clear space used bits in allocation map for this file.
              	; on entry, (c)=1 to set the map and (c)=0 to clear it.
              	;
E26B: CD5EE1  	setfile:call	fcb2hl		;get address of fcb
E26E: 111000  		ld	de,16
E271: 19      		add	hl,de		;get to block number bytes.
E272: C5      		push	bc
E273: 0E11    		ld	c,17		;check all 17 bytes (max) of table.
E275: D1      	setfl1:	pop	de
E276: 0D      		dec	c		;done all bytes yet?
E277: C8      		ret	z
E278: D5      		push	de
E279: 3ADDE9  		ld	a,(bigdisk)	;check disk size for 16 bit block numbers.
E27C: B7      		or	a
E27D: CA88E2  		jp	z,setfl2
E280: C5      		push	bc		;only 8 bit numbers. set (bc) to this one.
E281: E5      		push	hl
E282: 4E      		ld	c,(hl)		;get low byte from table, always
E283: 0600    		ld	b,0		;set high byte to zero.
E285: C38EE2  		jp	setfl3
E288: 0D      	setfl2:	dec	c		;for 16 bit block numbers, adjust counter.
E289: C5      		push	bc
E28A: 4E      		ld	c,(hl)		;now get both the low and high bytes.
E28B: 23      		inc	hl
E28C: 46      		ld	b,(hl)
E28D: E5      		push	hl
E28E: 79      	setfl3:	ld	a,c		;block used?
E28F: B0      		or	b
E290: CA9DE2  		jp	z,setfl4
E293: 2AC6E9  		ld	hl,(dsksize)	;is this block number within the
E296: 7D      		ld	a,l		;space on the disk?
E297: 91      		sub	c
E298: 7C      		ld	a,h
E299: 98      		sbc	a,b
E29A: D45CE2  		call	nc,stbitmap	;yes, set the proper bit.
E29D: E1      	setfl4:	pop	hl		;point to next block number in fcb.
E29E: 23      		inc	hl
E29F: C1      		pop	bc
E2A0: C375E2  		jp	setfl1
              	;
              	;   construct the space used allocation bit map for the active
              	; drive. if a file name starts with '$' and it is under the
              	; current user number, then (status) is set to minus 1. otherwise
              	; it is not set at all.
              	;
E2A3: 2AC6E9  	bitmap:	ld	hl,(dsksize)	;compute size of allocation table.
E2A6: 0E03    		ld	c,3
E2A8: CDEAE0  		call	shiftr		;(hl)=(hl)/8.
E2AB: 23      		inc	hl		;at lease 1 byte.
E2AC: 44      		ld	b,h
E2AD: 4D      		ld	c,l		;set (bc) to the allocation table length.
              	;
              	;   initialize the bitmap for this drive. right now, the first
              	; two bytes are specified by the disk parameter block. however
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. for example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
E2AE: 2ABFE9  		ld	hl,(alocvect)	;now zero out the table now.
E2B1: 3600    	bitmap1:ld	(hl),0
E2B3: 23      		inc	hl
E2B4: 0B      		dec	bc
E2B5: 78      		ld	a,b
E2B6: B1      		or	c
E2B7: C2B1E2  		jp	nz,bitmap1
E2BA: 2ACAE9  		ld	hl,(alloc0)	;get initial space used by directory.
E2BD: EB      		ex	de,hl
E2BE: 2ABFE9  		ld	hl,(alocvect)	;and put this into map.
E2C1: 73      		ld	(hl),e
E2C2: 23      		inc	hl
E2C3: 72      		ld	(hl),d
              	;
              	;   end of initialization portion.
              	;
E2C4: CDA1DF  		call	homedrv		;now home the drive.
E2C7: 2AB3E9  		ld	hl,(scratch1)
E2CA: 3603    		ld	(hl),3		;force next directory request to read
E2CC: 23      		inc	hl		;in a sector.
E2CD: 3600    		ld	(hl),0
E2CF: CDFEE1  		call	stfilpos	;clear initial file position also.
E2D2: 0EFF    	bitmap2:ld	c,0ffh		;read next file name in directory
E2D4: CD05E2  		call	nxentry		;and set checksum byte.
E2D7: CDF5E1  		call	ckfilpos	;is there another file?
E2DA: C8      		ret	z
E2DB: CD5EE1  		call	fcb2hl		;yes, get its address.
E2DE: 3EE5    		ld	a,0e5h
E2E0: BE      		cp	(hl)		;empty file entry?
E2E1: CAD2E2  		jp	z,bitmap2
E2E4: 3A41DF  		ld	a,(userno)	;no, correct user number?
E2E7: BE      		cp	(hl)
E2E8: C2F6E2  		jp	nz,bitmap3
E2EB: 23      		inc	hl
E2EC: 7E      		ld	a,(hl)		;yes, does name start with a '$'?
E2ED: D624    		sub	'$'
E2EF: C2F6E2  		jp	nz,bitmap3
E2F2: 3D      		dec	a		;yes, set atatus to minus one.
E2F3: 3245DF  		ld	(status),a
E2F6: 0E01    	bitmap3:ld	c,1		;now set this file's space as used in bit map.
E2F8: CD6BE2  		call	setfile
E2FB: CD8CE1  		call	chknmbr		;keep (scratch1) in bounds.
E2FE: C3D2E2  		jp	bitmap2
              	;
              	;   set the status (status) and return.
              	;
E301: 3AD4E9  	ststatus: ld	a,(fndstat)
E304: C301DF  		jp	setstat
              	;
              	;   check extents in (a) and (c). set the zero flag if they
              	; are the same. the number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (extmask+1).
              	; no registers are modified.
              	;
E307: C5      	samext:	push	bc
E308: F5      		push	af
E309: 3AC5E9  		ld	a,(extmask)	;get extent mask and use it to
E30C: 2F      		cpl			;to compare both extent numbers.
E30D: 47      		ld	b,a		;save resulting mask here.
E30E: 79      		ld	a,c		;mask first extent and save in (c).
E30F: A0      		and	b
E310: 4F      		ld	c,a
E311: F1      		pop	af		;now mask second extent and compare
E312: A0      		and	b		;with the first one.
E313: 91      		sub	c
E314: E61F    		and	1fh		;(* only check buts 0-4 *)
E316: C1      		pop	bc		;the zero flag is set if they are the same.
E317: C9      		ret			;restore (bc) and return.
              	;
              	;   search for the first occurence of a file name. on entry,
              	; register (c) should contain the number of bytes of the fcb
              	; that must match.
              	;
E318: 3EFF    	findfst:ld	a,0ffh
E31A: 32D4E9  		ld	(fndstat),a
E31D: 21D8E9  		ld	hl,counter	;save character count.
E320: 71      		ld	(hl),c
E321: 2A43DF  		ld	hl,(params)	;get filename to match.
E324: 22D9E9  		ld	(savefcb),hl	;and save.
E327: CDFEE1  		call	stfilpos	;clear initial file position (set to 0ffffh).
E32A: CDA1DF  		call	homedrv		;home the drive.
              	;
              	;   entry to locate the next occurence of a filename within the
              	; directory. the disk is not expected to have been changed. if
              	; it was, then it will be write protected.
              	;
E32D: 0E00    	findnxt:ld	c,0		;write protect the disk if changed.
E32F: CD05E2  		call	nxentry		;get next filename entry in directory.
E332: CDF5E1  		call	ckfilpos	;is file position = 0ffffh?
E335: CA94E3  		jp	z,fndnxt6	;yes, exit now then.
E338: 2AD9E9  		ld	hl,(savefcb)	;set (de) pointing to filename to match.
E33B: EB      		ex	de,hl
E33C: 1A      		ld	a,(de)
E33D: FEE5    		cp	0e5h		;empty directory entry?
E33F: CA4AE3  		jp	z,fndnxt1	;(* are we trying to reserect erased entries? *)
E342: D5      		push	de
E343: CD7FE1  		call	morefls		;more files in directory?
E346: D1      		pop	de
E347: D294E3  		jp	nc,fndnxt6	;no more. exit now.
E34A: CD5EE1  	fndnxt1:call	fcb2hl		;get address of this fcb in directory.
E34D: 3AD8E9  		ld	a,(counter)	;get number of bytes (characters) to check.
E350: 4F      		ld	c,a
E351: 0600    		ld	b,0		;initialize byte position counter.
E353: 79      	fndnxt2:ld	a,c		;are we done with the compare?
E354: B7      		or	a
E355: CA83E3  		jp	z,fndnxt5
E358: 1A      		ld	a,(de)		;no, check next byte.
E359: FE3F    		cp	'?'		;don't care about this character?
E35B: CA7CE3  		jp	z,fndnxt4
E35E: 78      		ld	a,b		;get bytes position in fcb.
E35F: FE0D    		cp	13		;don't care about the thirteenth byte either.
E361: CA7CE3  		jp	z,fndnxt4
E364: FE0C    		cp	12		;extent byte?
E366: 1A      		ld	a,(de)
E367: CA73E3  		jp	z,fndnxt3
E36A: 96      		sub	(hl)		;otherwise compare characters.
E36B: E67F    		and	7fh
E36D: C22DE3  		jp	nz,findnxt	;not the same, check next entry.
E370: C37CE3  		jp	fndnxt4		;so far so good, keep checking.
E373: C5      	fndnxt3:push	bc		;check the extent byte here.
E374: 4E      		ld	c,(hl)
E375: CD07E3  		call	samext
E378: C1      		pop	bc
E379: C22DE3  		jp	nz,findnxt	;not the same, look some more.
              	;
              	;   so far the names compare. bump pointers to the next byte
              	; and continue until all (c) characters have been checked.
              	;
E37C: 13      	fndnxt4:inc	de		;bump pointers.
E37D: 23      		inc	hl
E37E: 04      		inc	b
E37F: 0D      		dec	c		;adjust character counter.
E380: C353E3  		jp	fndnxt2
E383: 3AEAE9  	fndnxt5:ld	a,(filepos)	;return the position of this entry.
E386: E603    		and	03h
E388: 3245DF  		ld	(status),a
E38B: 21D4E9  		ld	hl,fndstat
E38E: 7E      		ld	a,(hl)
E38F: 17      		rla	
E390: D0      		ret	nc
E391: AF      		xor	a
E392: 77      		ld	(hl),a
E393: C9      		ret	
              	;
              	;   filename was not found. set appropriate status.
              	;
E394: CDFEE1  	fndnxt6:call	stfilpos	;set (filepos) to 0ffffh.
E397: 3EFF    		ld	a,0ffh		;say not located.
E399: C301DF  		jp	setstat
              	;
              	;   erase files from the directory. only the first byte of the
              	; fcb will be affected. it is set to (e5).
              	;
E39C: CD54E1  	erafile:call	chkwprt		;is disk write protected?
E39F: 0E0C    		ld	c,12		;only compare file names.
E3A1: CD18E3  		call	findfst		;get first file name.
E3A4: CDF5E1  	erafil1:call	ckfilpos	;any found?
E3A7: C8      		ret	z		;nope, we must be done.
E3A8: CD44E1  		call	chkrofl		;is file read only?
E3AB: CD5EE1  		call	fcb2hl		;nope, get address of fcb and
E3AE: 36E5    		ld	(hl),0e5h	;set first byte to 'empty'.
E3B0: 0E00    		ld	c,0		;clear the space from the bit map.
E3B2: CD6BE2  		call	setfile
E3B5: CDC6E1  		call	dirwrite	;now write the directory sector back out.
E3B8: CD2DE3  		call	findnxt		;find the next file name.
E3BB: C3A4E3  		jp	erafil1		;and repeat process.
              	;
              	;   look through the space allocation map (bit map) for the
              	; next available block. start searching at block number (bc-1).
              	; the search procedure is to look for an empty block that is
              	; before the starting block. if not empty, look at a later
              	; block number. in this way, we return the closest empty block
              	; on either side of the 'target' block number. this will speed
              	; access on random devices. for serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   on return, (de)= block number that is empty and (hl) =0
              	; if no empry block was found.
              	;
E3BE: 50      	fndspace: ld	d,b		;set (de) as the block that is checked.
E3BF: 59      		ld	e,c
              	;
              	;   look before target block. registers (bc) are used as the lower
              	; pointer and (de) as the upper pointer.
              	;
E3C0: 79      	fndspa1:ld	a,c		;is block 0 specified?
E3C1: B0      		or	b
E3C2: CAD1E3  		jp	z,fndspa2
E3C5: 0B      		dec	bc		;nope, check previous block.
E3C6: D5      		push	de
E3C7: C5      		push	bc
E3C8: CD35E2  		call	ckbitmap
E3CB: 1F      		rra			;is this block empty?
E3CC: D2ECE3  		jp	nc,fndspa3	;yes. use this.
              	;
              	;   note that the above logic gets the first block that it finds
              	; that is empty. thus a file could be written 'backward' making
              	; it very slow to access. this could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; this should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
E3CF: C1      		pop	bc		;nope, check some more.
E3D0: D1      		pop	de
              	;
              	;   now look after target block.
              	;
E3D1: 2AC6E9  	fndspa2:ld	hl,(dsksize)	;is block (de) within disk limits?
E3D4: 7B      		ld	a,e
E3D5: 95      		sub	l
E3D6: 7A      		ld	a,d
E3D7: 9C      		sbc	a,h
E3D8: D2F4E3  		jp	nc,fndspa4
E3DB: 13      		inc	de		;yes, move on to next one.
E3DC: C5      		push	bc
E3DD: D5      		push	de
E3DE: 42      		ld	b,d
E3DF: 4B      		ld	c,e
E3E0: CD35E2  		call	ckbitmap	;check it.
E3E3: 1F      		rra			;empty?
E3E4: D2ECE3  		jp	nc,fndspa3
E3E7: D1      		pop	de		;nope, continue searching.
E3E8: C1      		pop	bc
E3E9: C3C0E3  		jp	fndspa1
              	;
              	;   empty block found. set it as used and return with (hl)
              	; pointing to it (true?).
              	;
E3EC: 17      	fndspa3:rla			;reset byte.
E3ED: 3C      		inc	a		;and set bit 0.
E3EE: CD64E2  		call	stbmap1		;update bit map.
E3F1: E1      		pop	hl		;set return registers.
E3F2: D1      		pop	de
E3F3: C9      		ret	
              	;
              	;   free block was not found. if (bc) is not zero, then we have
              	; not checked all of the disk space.
              	;
E3F4: 79      	fndspa4:ld	a,c
E3F5: B0      		or	b
E3F6: C2C0E3  		jp	nz,fndspa1
E3F9: 210000  		ld	hl,0		;set 'not found' status.
E3FC: C9      		ret	
              	;
              	;   move a complete fcb entry into the directory and write it.
              	;
E3FD: 0E00    	fcbset:	ld	c,0
E3FF: 1E20    		ld	e,32		;length of each entry.
              	;
              	;   move (e) bytes from the fcb pointed to by (params) into
              	; fcb in directory starting at relative byte (c). this updated
              	; directory buffer is then written to the disk.
              	;
E401: D5      	update:	push	de
E402: 0600    		ld	b,0		;set (bc) to relative byte position.
E404: 2A43DF  		ld	hl,(params)	;get address of fcb.
E407: 09      		add	hl,bc		;compute starting byte.
E408: EB      		ex	de,hl
E409: CD5EE1  		call	fcb2hl		;get address of fcb to update in directory.
E40C: C1      		pop	bc		;set (c) to number of bytes to change.
E40D: CD4FDF  		call	de2hl
E410: CDC3DF  	update1:call	trksec		;determine the track and sector affected.
E413: C3C6E1  		jp	dirwrite	;then write this sector out.
              	;
              	;   routine to change the name of all files on the disk with a
              	; specified name. the fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
E416: CD54E1  	chgnames: call	chkwprt		;check for a write protected disk.
E419: 0E0C    		ld	c,12		;match first 12 bytes of fcb only.
E41B: CD18E3  		call	findfst		;get first name.
E41E: 2A43DF  		ld	hl,(params)	;get address of fcb.
E421: 7E      		ld	a,(hl)		;get user number.
E422: 111000  		ld	de,16		;move over to desired name.
E425: 19      		add	hl,de
E426: 77      		ld	(hl),a		;keep same user number.
E427: CDF5E1  	chgnam1:call	ckfilpos	;any matching file found?
E42A: C8      		ret	z		;no, we must be done.
E42B: CD44E1  		call	chkrofl		;check for read only file.
E42E: 0E10    		ld	c,16		;start 16 bytes into fcb.
E430: 1E0C    		ld	e,12		;and update the first 12 bytes of directory.
E432: CD01E4  		call	update
E435: CD2DE3  		call	findnxt		;get te next file name.
E438: C327E4  		jp	chgnam1		;and continue.
              	;
              	;   update a files attributes. the procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). no other changes
              	; are made.
              	;
E43B: 0E0C    	saveattr: ld	c,12		;match first 12 bytes.
E43D: CD18E3  		call	findfst		;look for first filename.
E440: CDF5E1  	savatr1:call	ckfilpos	;was one found?
E443: C8      		ret	z		;nope, we must be done.
E444: 0E00    		ld	c,0		;yes, update the first 12 bytes now.
E446: 1E0C    		ld	e,12
E448: CD01E4  		call	update		;update filename and write directory.
E44B: CD2DE3  		call	findnxt		;and get the next file.
E44E: C340E4  		jp	savatr1		;then continue until done.
              	;
              	;  open a file (name specified in fcb).
              	;
E451: 0E0F    	openit:	ld	c,15		;compare the first 15 bytes.
E453: CD18E3  		call	findfst		;get the first one in directory.
E456: CDF5E1  		call	ckfilpos	;any at all?
E459: C8      		ret	z
E45A: CDA6E0  	openit1:call	setext		;point to extent byte within users fcb.
E45D: 7E      		ld	a,(hl)		;and get it.
E45E: F5      		push	af		;save it and address.
E45F: E5      		push	hl
E460: CD5EE1  		call	fcb2hl		;point to fcb in directory.
E463: EB      		ex	de,hl
E464: 2A43DF  		ld	hl,(params)	;this is the users copy.
E467: 0E20    		ld	c,32		;move it into users space.
E469: D5      		push	de
E46A: CD4FDF  		call	de2hl
E46D: CD78E1  		call	sets2b7		;set bit 7 in 's2' byte (unmodified).
E470: D1      		pop	de		;now get the extent byte from this fcb.
E471: 210C00  		ld	hl,12
E474: 19      		add	hl,de
E475: 4E      		ld	c,(hl)		;into (c).
E476: 210F00  		ld	hl,15		;now get the record count byte into (b).
E479: 19      		add	hl,de
E47A: 46      		ld	b,(hl)
E47B: E1      		pop	hl		;keep the same extent as the user had originally.
E47C: F1      		pop	af
E47D: 77      		ld	(hl),a
E47E: 79      		ld	a,c		;is it the same as in the directory fcb?
E47F: BE      		cp	(hl)
E480: 78      		ld	a,b		;if yes, then use the same record count.
E481: CA8BE4  		jp	z,openit2
E484: 3E00    		ld	a,0		;if the user specified an extent greater than
E486: DA8BE4  		jp	c,openit2	;the one in the directory, then set record count to 0.
E489: 3E80    		ld	a,128		;otherwise set to maximum.
E48B: 2A43DF  	openit2:ld	hl,(params)	;set record count in users fcb to (a).
E48E: 110F00  		ld	de,15
E491: 19      		add	hl,de		;compute relative position.
E492: 77      		ld	(hl),a		;and set the record count.
E493: C9      		ret	
              	;
              	;   move two bytes from (de) to (hl) if (and only if) (hl)
              	; point to a zero value (16 bit).
              	;   return with zero flag set it (de) was moved. registers (de)
              	; and (hl) are not changed. however (a) is.
              	;
E494: 7E      	moveword: ld	a,(hl)		;check for a zero word.
E495: 23      		inc	hl
E496: B6      		or	(hl)		;both bytes zero?
E497: 2B      		dec	hl
E498: C0      		ret	nz		;nope, just return.
E499: 1A      		ld	a,(de)		;yes, move two bytes from (de) into
E49A: 77      		ld	(hl),a		;this zero space.
E49B: 13      		inc	de
E49C: 23      		inc	hl
E49D: 1A      		ld	a,(de)
E49E: 77      		ld	(hl),a
E49F: 1B      		dec	de		;don't disturb these registers.
E4A0: 2B      		dec	hl
E4A1: C9      		ret	
              	;
              	;   get here to close a file specified by (fcb).
              	;
E4A2: AF      	closeit:xor	a		;clear status and file position bytes.
E4A3: 3245DF  		ld	(status),a
E4A6: 32EAE9  		ld	(filepos),a
E4A9: 32EBE9  		ld	(filepos+1),a
E4AC: CD1EE1  		call	getwprt		;get write protect bit for this drive.
E4AF: C0      		ret	nz		;just return if it is set.
E4B0: CD69E1  		call	gets2		;else get the 's2' byte.
E4B3: E680    		and	80h		;and look at bit 7 (file unmodified?).
E4B5: C0      		ret	nz		;just return if set.
E4B6: 0E0F    		ld	c,15		;else look up this file in directory.
E4B8: CD18E3  		call	findfst
E4BB: CDF5E1  		call	ckfilpos	;was it found?
E4BE: C8      		ret	z		;just return if not.
E4BF: 011000  		ld	bc,16		;set (hl) pointing to records used section.
E4C2: CD5EE1  		call	fcb2hl
E4C5: 09      		add	hl,bc
E4C6: EB      		ex	de,hl
E4C7: 2A43DF  		ld	hl,(params)	;do the same for users specified fcb.
E4CA: 09      		add	hl,bc
E4CB: 0E10    		ld	c,16		;this many bytes are present in this extent.
E4CD: 3ADDE9  	closeit1: ld	a,(bigdisk)	;8 or 16 bit record numbers?
E4D0: B7      		or	a
E4D1: CAE8E4  		jp	z,closeit4
E4D4: 7E      		ld	a,(hl)		;just 8 bit. get one from users fcb.
E4D5: B7      		or	a
E4D6: 1A      		ld	a,(de)		;now get one from directory fcb.
E4D7: C2DBE4  		jp	nz,closeit2
E4DA: 77      		ld	(hl),a		;users byte was zero. update from directory.
E4DB: B7      	closeit2: or	a
E4DC: C2E1E4  		jp	nz,closeit3
E4DF: 7E      		ld	a,(hl)		;directories byte was zero, update from users fcb.
E4E0: 12      		ld	(de),a
E4E1: BE      	closeit3: cp	(hl)		;if neither one of these bytes were zero,
E4E2: C21FE5  		jp	nz,closeit7	;then close error if they are not the same.
E4E5: C3FDE4  		jp	closeit5	;ok so far, get to next byte in fcbs.
E4E8: CD94E4  	closeit4: call	moveword	;update users fcb if it is zero.
E4EB: EB      		ex	de,hl
E4EC: CD94E4  		call	moveword	;update directories fcb if it is zero.
E4EF: EB      		ex	de,hl
E4F0: 1A      		ld	a,(de)		;if these two values are no different,
E4F1: BE      		cp	(hl)		;then a close error occured.
E4F2: C21FE5  		jp	nz,closeit7
E4F5: 13      		inc	de		;check second byte.
E4F6: 23      		inc	hl
E4F7: 1A      		ld	a,(de)
E4F8: BE      		cp	(hl)
E4F9: C21FE5  		jp	nz,closeit7
E4FC: 0D      		dec	c		;remember 16 bit values.
E4FD: 13      	closeit5: inc	de		;bump to next item in table.
E4FE: 23      		inc	hl
E4FF: 0D      		dec	c		;there are 16 entries only.
E500: C2CDE4  		jp	nz,closeit1	;continue if more to do.
E503: 01ECFF  		ld	bc,0ffech	;backup 20 places (extent byte).
E506: 09      		add	hl,bc
E507: EB      		ex	de,hl
E508: 09      		add	hl,bc
E509: 1A      		ld	a,(de)
E50A: BE      		cp	(hl)		;directory's extent already greater than the
E50B: DA17E5  		jp	c,closeit6	;users extent?
E50E: 77      		ld	(hl),a		;no, update directory extent.
E50F: 010300  		ld	bc,3		;and update the record count byte in
E512: 09      		add	hl,bc		;directories fcb.
E513: EB      		ex	de,hl
E514: 09      		add	hl,bc
E515: 7E      		ld	a,(hl)		;get from user.
E516: 12      		ld	(de),a		;and put in directory.
E517: 3EFF    	closeit6: ld	a,0ffh		;set 'was open and is now closed' byte.
E519: 32D2E9  		ld	(closeflg),a
E51C: C310E4  		jp	update1		;update the directory now.
E51F: 2145DF  	closeit7: ld	hl,status	;set return status and then return.
E522: 35      		dec	(hl)
E523: C9      		ret	
              	;
              	;   routine to get the next empty space in the directory. it
              	; will then be cleared for use.
              	;
E524: CD54E1  	getempty: call	chkwprt		;make sure disk is not write protected.
E527: 2A43DF  		ld	hl,(params)	;save current parameters (fcb).
E52A: E5      		push	hl
E52B: 21ACE9  		ld	hl,emptyfcb	;use special one for empty space.
E52E: 2243DF  		ld	(params),hl
E531: 0E01    		ld	c,1		;search for first empty spot in directory.
E533: CD18E3  		call	findfst		;(* only check first byte *)
E536: CDF5E1  		call	ckfilpos	;none?
E539: E1      		pop	hl
E53A: 2243DF  		ld	(params),hl	;restore original fcb address.
E53D: C8      		ret	z		;return if no more space.
E53E: EB      		ex	de,hl
E53F: 210F00  		ld	hl,15		;point to number of records for this file.
E542: 19      		add	hl,de
E543: 0E11    		ld	c,17		;and clear all of this space.
E545: AF      		xor	a
E546: 77      	getmt1:	ld	(hl),a
E547: 23      		inc	hl
E548: 0D      		dec	c
E549: C246E5  		jp	nz,getmt1
E54C: 210D00  		ld	hl,13		;clear the 's1' byte also.
E54F: 19      		add	hl,de
E550: 77      		ld	(hl),a
E551: CD8CE1  		call	chknmbr		;keep (scratch1) within bounds.
E554: CDFDE3  		call	fcbset		;write out this fcb entry to directory.
E557: C378E1  		jp	sets2b7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   routine to close the current extent and open the next one
              	; for reading.
              	;
E55A: AF      	getnext:xor	a
E55B: 32D2E9  		ld	(closeflg),a	;clear close flag.
E55E: CDA2E4  		call	closeit		;close this extent.
E561: CDF5E1  		call	ckfilpos
E564: C8      		ret	z		;not there???
E565: 2A43DF  		ld	hl,(params)	;get extent byte.
E568: 010C00  		ld	bc,12
E56B: 09      		add	hl,bc
E56C: 7E      		ld	a,(hl)		;and increment it.
E56D: 3C      		inc	a
E56E: E61F    		and	1fh		;keep within range 0-31.
E570: 77      		ld	(hl),a
E571: CA83E5  		jp	z,gtnext1	;overflow?
E574: 47      		ld	b,a		;mask extent byte.
E575: 3AC5E9  		ld	a,(extmask)
E578: A0      		and	b
E579: 21D2E9  		ld	hl,closeflg	;check close flag (0ffh is ok).
E57C: A6      		and	(hl)
E57D: CA8EE5  		jp	z,gtnext2	;if zero, we must read in next extent.
E580: C3ACE5  		jp	gtnext3		;else, it is already in memory.
E583: 010200  	gtnext1:ld	bc,2		;point to the 's2' byte.
E586: 09      		add	hl,bc
E587: 34      		inc	(hl)		;and bump it.
E588: 7E      		ld	a,(hl)		;too many extents?
E589: E60F    		and	0fh
E58B: CAB6E5  		jp	z,gtnext5	;yes, set error code.
              	;
              	;   get here to open the next extent.
              	;
E58E: 0E0F    	gtnext2:ld	c,15		;set to check first 15 bytes of fcb.
E590: CD18E3  		call	findfst		;find the first one.
E593: CDF5E1  		call	ckfilpos	;none available?
E596: C2ACE5  		jp	nz,gtnext3
E599: 3AD3E9  		ld	a,(rdwrtflg)	;no extent present. can we open an empty one?
E59C: 3C      		inc	a		;0ffh means reading (so not possible).
E59D: CAB6E5  		jp	z,gtnext5	;or an error.
E5A0: CD24E5  		call	getempty	;we are writing, get an empty entry.
E5A3: CDF5E1  		call	ckfilpos	;none?
E5A6: CAB6E5  		jp	z,gtnext5	;error if true.
E5A9: C3AFE5  		jp	gtnext4		;else we are almost done.
E5AC: CD5AE4  	gtnext3:call	openit1		;open this extent.
E5AF: CDBBE0  	gtnext4:call	strdata		;move in updated data (rec #, extent #, etc.)
E5B2: AF      		xor	a		;clear status and return.
E5B3: C301DF  		jp	setstat
              	;
              	;   error in extending the file. too many extents were needed
              	; or not enough space on the disk.
              	;
E5B6: CD05DF  	gtnext5:call	ioerr1		;set error code, clear bit 7 of 's2'
E5B9: C378E1  		jp	sets2b7		;so this is not written on a close.
              	;
              	;   read a sequential file.
              	;
E5BC: 3E01    	rdseq:	ld	a,1		;set sequential access mode.
E5BE: 32D5E9  		ld	(mode),a
E5C1: 3EFF    	rdseq1:	ld	a,0ffh		;don't allow reading unwritten space.
E5C3: 32D3E9  		ld	(rdwrtflg),a
E5C6: CDBBE0  		call	strdata		;put rec# and ext# into fcb.
E5C9: 3AE3E9  		ld	a,(savnrec)	;get next record to read.
E5CC: 21E1E9  		ld	hl,savnxt	;get number of records in extent.
E5CF: BE      		cp	(hl)		;within this extent?
E5D0: DAE6E5  		jp	c,rdseq2
E5D3: FE80    		cp	128		;no. is this extent fully used?
E5D5: C2FBE5  		jp	nz,rdseq3	;no. end-of-file.
E5D8: CD5AE5  		call	getnext		;yes, open the next one.
E5DB: AF      		xor	a		;reset next record to read.
E5DC: 32E3E9  		ld	(savnrec),a
E5DF: 3A45DF  		ld	a,(status)	;check on open, successful?
E5E2: B7      		or	a
E5E3: C2FBE5  		jp	nz,rdseq3	;no, error.
E5E6: CD77E0  	rdseq2:	call	comblk		;ok. compute block number to read.
E5E9: CD84E0  		call	chkblk		;check it. within bounds?
E5EC: CAFBE5  		jp	z,rdseq3	;no, error.
E5EF: CD8AE0  		call	logical		;convert (blknmbr) to logical sector (128 byte).
E5F2: CDD1DF  		call	trksec1		;set the track and sector for this block #.
E5F5: CDB2DF  		call	doread		;and read it.
E5F8: C3D2E0  		jp	setnrec		;and set the next record to be accessed.
              	;
              	;   read error occured. set status and return.
              	;
E5FB: C305DF  	rdseq3:	jp	ioerr1
              	;
              	;   write the next sequential record.
              	;
E5FE: 3E01    	wtseq:	ld	a,1		;set sequential access mode.
E600: 32D5E9  		ld	(mode),a
E603: 3E00    	wtseq1:	ld	a,0		;allow an addition empty extent to be opened.
E605: 32D3E9  		ld	(rdwrtflg),a
E608: CD54E1  		call	chkwprt		;check write protect status.
E60B: 2A43DF  		ld	hl,(params)
E60E: CD47E1  		call	ckrof1		;check for read only file, (hl) already set to fcb.
E611: CDBBE0  		call	strdata		;put updated data into fcb.
E614: 3AE3E9  		ld	a,(savnrec)	;get record number to write.
E617: FE80    		cp	128		;within range?
E619: D205DF  		jp	nc,ioerr1	;no, error(?).
E61C: CD77E0  		call	comblk		;compute block number.
E61F: CD84E0  		call	chkblk		;check number.
E622: 0E00    		ld	c,0		;is there one to write to?
E624: C26EE6  		jp	nz,wtseq6	;yes, go do it.
E627: CD3EE0  		call	getblock	;get next block number within fcb to use.
E62A: 32D7E9  		ld	(relblock),a	;and save.
E62D: 010000  		ld	bc,0		;start looking for space from the start
E630: B7      		or	a		;if none allocated as yet.
E631: CA3BE6  		jp	z,wtseq2
E634: 4F      		ld	c,a		;extract previous block number from fcb
E635: 0B      		dec	bc		;so we can be closest to it.
E636: CD5EE0  		call	extblk
E639: 44      		ld	b,h
E63A: 4D      		ld	c,l
E63B: CDBEE3  	wtseq2:	call	fndspace	;find the next empty block nearest number (bc).
E63E: 7D      		ld	a,l		;check for a zero number.
E63F: B4      		or	h
E640: C248E6  		jp	nz,wtseq3
E643: 3E02    		ld	a,2		;no more space?
E645: C301DF  		jp	setstat
E648: 22E5E9  	wtseq3:	ld	(blknmbr),hl	;save block number to access.
E64B: EB      		ex	de,hl		;put block number into (de).
E64C: 2A43DF  		ld	hl,(params)	;now we must update the fcb for this
E64F: 011000  		ld	bc,16		;newly allocated block.
E652: 09      		add	hl,bc
E653: 3ADDE9  		ld	a,(bigdisk)	;8 or 16 bit block numbers?
E656: B7      		or	a
E657: 3AD7E9  		ld	a,(relblock)	;(* update this entry *)
E65A: CA64E6  		jp	z,wtseq4	;zero means 16 bit ones.
E65D: CD64E1  		call	adda2hl		;(hl)=(hl)+(a)
E660: 73      		ld	(hl),e		;store new block number.
E661: C36CE6  		jp	wtseq5
E664: 4F      	wtseq4:	ld	c,a		;compute spot in this 16 bit table.
E665: 0600    		ld	b,0
E667: 09      		add	hl,bc
E668: 09      		add	hl,bc
E669: 73      		ld	(hl),e		;stuff block number (de) there.
E66A: 23      		inc	hl
E66B: 72      		ld	(hl),d
E66C: 0E02    	wtseq5:	ld	c,2		;set (c) to indicate writing to un-used disk space.
E66E: 3A45DF  	wtseq6:	ld	a,(status)	;are we ok so far?
E671: B7      		or	a
E672: C0      		ret	nz
E673: C5      		push	bc		;yes, save write flag for bios (register c).
E674: CD8AE0  		call	logical		;convert (blknmbr) over to loical sectors.
E677: 3AD5E9  		ld	a,(mode)	;get access mode flag (1=sequential,
E67A: 3D      		dec	a		;0=random, 2=special?).
E67B: 3D      		dec	a
E67C: C2BBE6  		jp	nz,wtseq9
              	;
              	;   special random i/o from function #40. maybe for m/pm, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
E67F: C1      		pop	bc
E680: C5      		push	bc
E681: 79      		ld	a,c		;get write status flag (2=writing unused space).
E682: 3D      		dec	a
E683: 3D      		dec	a
E684: C2BBE6  		jp	nz,wtseq9
E687: E5      		push	hl
E688: 2AB9E9  		ld	hl,(dirbuf)	;zero out the directory buffer.
E68B: 57      		ld	d,a		;note that (a) is zero here.
E68C: 77      	wtseq7:	ld	(hl),a
E68D: 23      		inc	hl
E68E: 14      		inc	d		;do 128 bytes.
E68F: F28CE6  		jp	p,wtseq7
E692: CDE0E1  		call	dirdma		;tell the bios the dma address for directory access.
E695: 2AE7E9  		ld	hl,(logsect)	;get sector that starts current block.
E698: 0E02    		ld	c,2		;set 'writing to unused space' flag.
E69A: 22E5E9  	wtseq8:	ld	(blknmbr),hl	;save sector to write.
E69D: C5      		push	bc
E69E: CDD1DF  		call	trksec1		;determine its track and sector numbers.
E6A1: C1      		pop	bc
E6A2: CDB8DF  		call	dowrite		;now write out 128 bytes of zeros.
E6A5: 2AE5E9  		ld	hl,(blknmbr)	;get sector number.
E6A8: 0E00    		ld	c,0		;set normal write flag.
E6AA: 3AC4E9  		ld	a,(blkmask)	;determine if we have written the entire
E6AD: 47      		ld	b,a		;physical block.
E6AE: A5      		and	l
E6AF: B8      		cp	b
E6B0: 23      		inc	hl		;prepare for the next one.
E6B1: C29AE6  		jp	nz,wtseq8	;continue until (blkmask+1) sectors written.
E6B4: E1      		pop	hl		;reset next sector number.
E6B5: 22E5E9  		ld	(blknmbr),hl
E6B8: CDDAE1  		call	defdma		;and reset dma address.
              	;
              	;   normal disk write. set the desired track and sector then
              	; do the actual write.
              	;
E6BB: CDD1DF  	wtseq9:	call	trksec1		;determine track and sector for this write.
E6BE: C1      		pop	bc		;get write status flag.
E6BF: C5      		push	bc
E6C0: CDB8DF  		call	dowrite		;and write this out.
E6C3: C1      		pop	bc
E6C4: 3AE3E9  		ld	a,(savnrec)	;get number of records in file.
E6C7: 21E1E9  		ld	hl,savnxt	;get last record written.
E6CA: BE      		cp	(hl)
E6CB: DAD2E6  		jp	c,wtseq10
E6CE: 77      		ld	(hl),a		;we have to update record count.
E6CF: 34      		inc	(hl)
E6D0: 0E02    		ld	c,2
              	;
              	;*   this area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the bios.
              	;
E6D2: 00      	wtseq10:nop			;was 'dcr c'
E6D3: 00      		nop			;was 'dcr c'
E6D4: 210000  		ld	hl,0		;was 'jnz wtseq99'
              	;
              	; *   end of patch.
              	;
E6D7: F5      		push	af
E6D8: CD69E1  		call	gets2		;set 'extent written to' flag.
E6DB: E67F    		and	7fh		;(* clear bit 7 *)
E6DD: 77      		ld	(hl),a
E6DE: F1      		pop	af		;get record count for this extent.
E6DF: FE7F    	wtseq99:cp	127		;is it full?
E6E1: C200E7  		jp	nz,wtseq12
E6E4: 3AD5E9  		ld	a,(mode)	;yes, are we in sequential mode?
E6E7: FE01    		cp	1
E6E9: C200E7  		jp	nz,wtseq12
E6EC: CDD2E0  		call	setnrec		;yes, set next record number.
E6EF: CD5AE5  		call	getnext		;and get next empty space in directory.
E6F2: 2145DF  		ld	hl,status	;ok?
E6F5: 7E      		ld	a,(hl)
E6F6: B7      		or	a
E6F7: C2FEE6  		jp	nz,wtseq11
E6FA: 3D      		dec	a		;yes, set record count to -1.
E6FB: 32E3E9  		ld	(savnrec),a
E6FE: 3600    	wtseq11:ld	(hl),0		;clear status.
E700: C3D2E0  	wtseq12:jp	setnrec		;set next record to access.
              	;
              	;   for random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. these bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   on entry, register (c) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. otherwise,
              	; another extent will be opened (for writing) if required.
              	;
E703: AF      	position: xor	a		;set random i/o flag.
E704: 32D5E9  		ld	(mode),a
              	;
              	;   special entry (function #40). m/pm ?
              	;
E707: C5      	positn1:push	bc		;save read/write flag.
E708: 2A43DF  		ld	hl,(params)	;get address of fcb.
E70B: EB      		ex	de,hl
E70C: 212100  		ld	hl,33		;now get byte 'r0'.
E70F: 19      		add	hl,de
E710: 7E      		ld	a,(hl)
E711: E67F    		and	7fh		;keep bits 0-6 for the record number to access.
E713: F5      		push	af
E714: 7E      		ld	a,(hl)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
E715: 17      		rla	
E716: 23      		inc	hl
E717: 7E      		ld	a,(hl)
E718: 17      		rla	
E719: E61F    		and	1fh		;and save this in bits 0-4 of (c).
E71B: 4F      		ld	c,a		;this is the extent byte.
E71C: 7E      		ld	a,(hl)		;now get the extra extent byte.
E71D: 1F      		rra	
E71E: 1F      		rra	
E71F: 1F      		rra	
E720: 1F      		rra	
E721: E60F    		and	0fh
E723: 47      		ld	b,a		;and save it in (b).
E724: F1      		pop	af		;get record number back to (a).
E725: 23      		inc	hl		;check overflow byte 'r2'.
E726: 6E      		ld	l,(hl)
E727: 2C      		inc	l
E728: 2D      		dec	l
E729: 2E06    		ld	l,6		;prepare for error.
E72B: C28BE7  		jp	nz,positn5	;out of disk space error.
E72E: 212000  		ld	hl,32		;store record number into fcb.
E731: 19      		add	hl,de
E732: 77      		ld	(hl),a
E733: 210C00  		ld	hl,12		;and now check the extent byte.
E736: 19      		add	hl,de
E737: 79      		ld	a,c
E738: 96      		sub	(hl)		;same extent as before?
E739: C247E7  		jp	nz,positn2
E73C: 210E00  		ld	hl,14		;yes, check extra extent byte 's2' also.
E73F: 19      		add	hl,de
E740: 78      		ld	a,b
E741: 96      		sub	(hl)
E742: E67F    		and	7fh
E744: CA7FE7  		jp	z,positn3	;same, we are almost done then.
              	;
              	;  get here when another extent is required.
              	;
E747: C5      	positn2:push	bc
E748: D5      		push	de
E749: CDA2E4  		call	closeit		;close current extent.
E74C: D1      		pop	de
E74D: C1      		pop	bc
E74E: 2E03    		ld	l,3		;prepare for error.
E750: 3A45DF  		ld	a,(status)
E753: 3C      		inc	a
E754: CA84E7  		jp	z,positn4	;close error.
E757: 210C00  		ld	hl,12		;put desired extent into fcb now.
E75A: 19      		add	hl,de
E75B: 71      		ld	(hl),c
E75C: 210E00  		ld	hl,14		;and store extra extent byte 's2'.
E75F: 19      		add	hl,de
E760: 70      		ld	(hl),b
E761: CD51E4  		call	openit		;try and get this extent.
E764: 3A45DF  		ld	a,(status)	;was it there?
E767: 3C      		inc	a
E768: C27FE7  		jp	nz,positn3
E76B: C1      		pop	bc		;no. can we create a new one (writing?).
E76C: C5      		push	bc
E76D: 2E04    		ld	l,4		;prepare for error.
E76F: 0C      		inc	c
E770: CA84E7  		jp	z,positn4	;nope, reading unwritten space error.
E773: CD24E5  		call	getempty	;yes we can, try to find space.
E776: 2E05    		ld	l,5		;prepare for error.
E778: 3A45DF  		ld	a,(status)
E77B: 3C      		inc	a
E77C: CA84E7  		jp	z,positn4	;out of space?
              	;
              	;   normal return location. clear error code and return.
              	;
E77F: C1      	positn3:pop	bc		;restore stack.
E780: AF      		xor	a		;and clear error code byte.
E781: C301DF  		jp	setstat
              	;
              	;   error. set the 's2' byte to indicate this (why?).
              	;
E784: E5      	positn4:push	hl
E785: CD69E1  		call	gets2
E788: 36C0    		ld	(hl),0c0h
E78A: E1      		pop	hl
              	;
              	;   return with error code (presently in l).
              	;
E78B: C1      	positn5:pop	bc
E78C: 7D      		ld	a,l		;get error code.
E78D: 3245DF  		ld	(status),a
E790: C378E1  		jp	sets2b7
              	;
              	;   read a random record.
              	;
E793: 0EFF    	readran:ld	c,0ffh		;set 'read' status.
E795: CD03E7  		call	position	;position the file to proper record.
E798: CCC1E5  		call	z,rdseq1	;and read it as usual (if no errors).
E79B: C9      		ret	
              	;
              	;   write to a random record.
              	;
E79C: 0E00    	writeran: ld	c,0		;set 'writing' flag.
E79E: CD03E7  		call	position	;position the file to proper record.
E7A1: CC03E6  		call	z,wtseq1	;and write as usual (if no errors).
E7A4: C9      		ret	
              	;
              	;   compute the random record number. enter with (hl) pointing
              	; to a fcb an (de) contains a relative location of a record
              	; number. on exit, (c) contains the 'r0' byte, (b) the 'r1'
              	; byte, and (a) the 'r2' byte.
              	;
              	;   on return, the zero flag is set if the record is within
              	; bounds. otherwise, an overflow occured.
              	;
E7A5: EB      	comprand: ex	de,hl		;save fcb pointer in (de).
E7A6: 19      		add	hl,de		;compute relative position of record #.
E7A7: 4E      		ld	c,(hl)		;get record number into (bc).
E7A8: 0600    		ld	b,0
E7AA: 210C00  		ld	hl,12		;now get extent.
E7AD: 19      		add	hl,de
E7AE: 7E      		ld	a,(hl)		;compute (bc)=(record #)+(extent)*128.
E7AF: 0F      		rrca			;move lower bit into bit 7.
E7B0: E680    		and	80h		;and ignore all other bits.
E7B2: 81      		add	a,c		;add to our record number.
E7B3: 4F      		ld	c,a
E7B4: 3E00    		ld	a,0		;take care of any carry.
E7B6: 88      		adc	a,b
E7B7: 47      		ld	b,a
E7B8: 7E      		ld	a,(hl)		;now get the upper bits of extent into
E7B9: 0F      		rrca			;bit positions 0-3.
E7BA: E60F    		and	0fh		;and ignore all others.
E7BC: 80      		add	a,b		;add this in to 'r1' byte.
E7BD: 47      		ld	b,a
E7BE: 210E00  		ld	hl,14		;get the 's2' byte (extra extent).
E7C1: 19      		add	hl,de
E7C2: 7E      		ld	a,(hl)
E7C3: 87      		add	a,a		;and shift it left 4 bits (bits 4-7).
E7C4: 87      		add	a,a
E7C5: 87      		add	a,a
E7C6: 87      		add	a,a
E7C7: F5      		push	af		;save carry flag (bit 0 of flag byte).
E7C8: 80      		add	a,b		;now add extra extent into 'r1'.
E7C9: 47      		ld	b,a
E7CA: F5      		push	af		;and save carry (overflow byte 'r2').
E7CB: E1      		pop	hl		;bit 0 of (l) is the overflow indicator.
E7CC: 7D      		ld	a,l
E7CD: E1      		pop	hl		;and same for first carry flag.
E7CE: B5      		or	l		;either one of these set?
E7CF: E601    		and	01h		;only check the carry flags.
E7D1: C9      		ret	
              	;
              	;   routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; this reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. this is used to compute the space used
              	; by a random file.
              	;
E7D2: 0E0C    	ransize:ld	c,12		;look thru directory for first entry with
E7D4: CD18E3  		call	findfst		;this name.
E7D7: 2A43DF  		ld	hl,(params)	;zero out the 'r0, r1, r2' bytes.
E7DA: 112100  		ld	de,33
E7DD: 19      		add	hl,de
E7DE: E5      		push	hl
E7DF: 72      		ld	(hl),d		;note that (d)=0.
E7E0: 23      		inc	hl
E7E1: 72      		ld	(hl),d
E7E2: 23      		inc	hl
E7E3: 72      		ld	(hl),d
E7E4: CDF5E1  	ransiz1:call	ckfilpos	;is there an extent to process?
E7E7: CA0CE8  		jp	z,ransiz3	;no, we are done.
E7EA: CD5EE1  		call	fcb2hl		;set (hl) pointing to proper fcb in dir.
E7ED: 110F00  		ld	de,15		;point to last record in extent.
E7F0: CDA5E7  		call	comprand	;and compute random parameters.
E7F3: E1      		pop	hl
E7F4: E5      		push	hl		;now check these values against those
E7F5: 5F      		ld	e,a		;already in fcb.
E7F6: 79      		ld	a,c		;the carry flag will be set if those
E7F7: 96      		sub	(hl)		;in the fcb represent a larger size than
E7F8: 23      		inc	hl		;this extent does.
E7F9: 78      		ld	a,b
E7FA: 9E      		sbc	a,(hl)
E7FB: 23      		inc	hl
E7FC: 7B      		ld	a,e
E7FD: 9E      		sbc	a,(hl)
E7FE: DA06E8  		jp	c,ransiz2
E801: 73      		ld	(hl),e		;we found a larger (in size) extent.
E802: 2B      		dec	hl		;stuff these values into fcb.
E803: 70      		ld	(hl),b
E804: 2B      		dec	hl
E805: 71      		ld	(hl),c
E806: CD2DE3  	ransiz2:call	findnxt		;now get the next extent.
E809: C3E4E7  		jp	ransiz1		;continue til all done.
E80C: E1      	ransiz3:pop	hl		;we are done, restore the stack and
E80D: C9      		ret			;return.
              	;
              	;   function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
E80E: 2A43DF  	setran:	ld	hl,(params)	;point to fcb.
E811: 112000  		ld	de,32		;and to last used record.
E814: CDA5E7  		call	comprand	;compute random position.
E817: 212100  		ld	hl,33		;now stuff these values into fcb.
E81A: 19      		add	hl,de
E81B: 71      		ld	(hl),c		;move 'r0'.
E81C: 23      		inc	hl
E81D: 70      		ld	(hl),b		;and 'r1'.
E81E: 23      		inc	hl
E81F: 77      		ld	(hl),a		;and lastly 'r2'.
E820: C9      		ret	
              	;
              	;   this routine select the drive specified in (active) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
E821: 2AAFE9  	logindrv: ld	hl,(login)	;get the login vector.
E824: 3A42DF  		ld	a,(active)	;get the default drive.
E827: 4F      		ld	c,a
E828: CDEAE0  		call	shiftr		;position active bit for this drive
E82B: E5      		push	hl		;into bit 0.
E82C: EB      		ex	de,hl
E82D: CD59DF  		call	select		;select this drive.
E830: E1      		pop	hl
E831: CC47DF  		call	z,slcterr	;valid drive?
E834: 7D      		ld	a,l		;is this a newly activated drive?
E835: 1F      		rra	
E836: D8      		ret	c
E837: 2AAFE9  		ld	hl,(login)	;yes, update the login vector.
E83A: 4D      		ld	c,l
E83B: 44      		ld	b,h
E83C: CD0BE1  		call	setbit
E83F: 22AFE9  		ld	(login),hl	;and save.
E842: C3A3E2  		jp	bitmap		;now update the bitmap.
              	;
              	;   function to set the active disk number.
              	;
E845: 3AD6E9  	setdsk:	ld	a,(eparam)	;get parameter passed and see if this
E848: 2142DF  		ld	hl,active	;represents a change in drives.
E84B: BE      		cp	(hl)
E84C: C8      		ret	z
E84D: 77      		ld	(hl),a		;yes it does, log it in.
E84E: C321E8  		jp	logindrv
              	;
              	;   this is the 'auto disk select' routine. the firsst byte
              	; of the fcb is examined for a drive specification. if non
              	; zero then the drive will be selected and loged in.
              	;
E851: 3EFF    	autosel:ld	a,0ffh		;say 'auto-select activated'.
E853: 32DEE9  		ld	(auto),a
E856: 2A43DF  		ld	hl,(params)	;get drive specified.
E859: 7E      		ld	a,(hl)
E85A: E61F    		and	1fh		;look at lower 5 bits.
E85C: 3D      		dec	a		;adjust for (1=a, 2=b) etc.
E85D: 32D6E9  		ld	(eparam),a	;and save for the select routine.
E860: FE1E    		cp	1eh		;check for 'no change' condition.
E862: D275E8  		jp	nc,autosl1	;yes, don't change.
E865: 3A42DF  		ld	a,(active)	;we must change, save currently active
E868: 32DFE9  		ld	(olddrv),a	;drive.
E86B: 7E      		ld	a,(hl)		;and save first byte of fcb also.
E86C: 32E0E9  		ld	(autoflag),a	;this must be non-zero.
E86F: E6E0    		and	0e0h		;whats this for (bits 6,7 are used for
E871: 77      		ld	(hl),a		;something)?
E872: CD45E8  		call	setdsk		;select and log in this drive.
E875: 3A41DF  	autosl1:ld	a,(userno)	;move user number into fcb.
E878: 2A43DF  		ld	hl,(params)	;(* upper half of first byte *)
E87B: B6      		or	(hl)
E87C: 77      		ld	(hl),a
E87D: C9      		ret			;and return (all done).
              	;
              	;   function to return the current cp/m version number.
              	;
E87E: 3E22    	getver:	ld	a,022h		;version 2.2
E880: C301DF  		jp	setstat
              	;
              	;   function to reset the disk system.
              	;
E883: 210000  	rstdsk:	ld	hl,0		;clear write protect status and log
E886: 22ADE9  		ld	(wrtprt),hl	;in vector.
E889: 22AFE9  		ld	(login),hl
E88C: AF      		xor	a		;select drive 'a'.
E88D: 3242DF  		ld	(active),a
E890: 218000  		ld	hl,tbuff	;setup default dma address.
E893: 22B1E9  		ld	(userdma),hl
E896: CDDAE1  		call	defdma
E899: C321E8  		jp	logindrv	;now log in drive 'a'.
              	;
              	;   function to open a specified file.
              	;
E89C: CD72E1  	openfil:call	clears2		;clear 's2' byte.
E89F: CD51E8  		call	autosel		;select proper disk.
E8A2: C351E4  		jp	openit		;and open the file.
              	;
              	;   function to close a specified file.
              	;
E8A5: CD51E8  	closefil: call	autosel		;select proper disk.
E8A8: C3A2E4  		jp	closeit		;and close the file.
              	;
              	;   function to return the first occurence of a specified file
              	; name. if the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
E8AB: 0E00    	getfst:	ld	c,0		;prepare for special search.
E8AD: EB      		ex	de,hl
E8AE: 7E      		ld	a,(hl)		;is first byte a '?'?
E8AF: FE3F    		cp	'?'
E8B1: CAC2E8  		jp	z,getfst1	;yes, just get very first entry (zero length match).
E8B4: CDA6E0  		call	setext		;get the extension byte from fcb.
E8B7: 7E      		ld	a,(hl)		;is it '?'? if yes, then we want
E8B8: FE3F    		cp	'?'		;an entry with a specific 's2' byte.
E8BA: C472E1  		call	nz,clears2	;otherwise, look for a zero 's2' byte.
E8BD: CD51E8  		call	autosel		;select proper drive.
E8C0: 0E0F    		ld	c,15		;compare bytes 0-14 in fcb (12&13 excluded).
E8C2: CD18E3  	getfst1:call	findfst		;find an entry and then move it into
E8C5: C3E9E1  		jp	movedir		;the users dma space.
              	;
              	;   function to return the next occurence of a file name.
              	;
E8C8: 2AD9E9  	getnxt:	ld	hl,(savefcb)	;restore pointers. note that no
E8CB: 2243DF  		ld	(params),hl	;other dbos calls are allowed.
E8CE: CD51E8  		call	autosel		;no error will be returned, but the
E8D1: CD2DE3  		call	findnxt		;results will be wrong.
E8D4: C3E9E1  		jp	movedir
              	;
              	;   function to delete a file by name.
              	;
E8D7: CD51E8  	delfile:call	autosel		;select proper drive.
E8DA: CD9CE3  		call	erafile		;erase the file.
E8DD: C301E3  		jp	ststatus	;set status and return.
              	;
              	;   function to execute a sequential read of the specified
              	; record number.
              	;
E8E0: CD51E8  	readseq:call	autosel		;select proper drive then read.
E8E3: C3BCE5  		jp	rdseq
              	;
              	;   function to write the net sequential record.
              	;
E8E6: CD51E8  	wrtseq:	call	autosel		;select proper drive then write.
E8E9: C3FEE5  		jp	wtseq
              	;
              	;   create a file function.
              	;
E8EC: CD72E1  	fcreate:call	clears2		;clear the 's2' byte on all creates.
E8EF: CD51E8  		call	autosel		;select proper drive and get the next
E8F2: C324E5  		jp	getempty	;empty directory space.
              	;
              	;   function to rename a file.
              	;
E8F5: CD51E8  	renfile:call	autosel		;select proper drive and then switch
E8F8: CD16E4  		call	chgnames	;file names.
E8FB: C301E3  		jp	ststatus
              	;
              	;   function to return the login vector.
              	;
E8FE: 2AAFE9  	getlog:	ld	hl,(login)
E901: C329E9  		jp	getprm1
              	;
              	;   function to return the current disk assignment.
              	;
E904: 3A42DF  	getcrnt:ld	a,(active)
E907: C301DF  		jp	setstat
              	;
              	;   function to set the dma address.
              	;
E90A: EB      	putdma:	ex	de,hl
E90B: 22B1E9  		ld	(userdma),hl	;save in our space and then get to
E90E: C3DAE1  		jp	defdma		;the bios with this also.
              	;
              	;   function to return the allocation vector.
              	;
E911: 2ABFE9  	getaloc:ld	hl,(alocvect)
E914: C329E9  		jp	getprm1
              	;
              	;   function to return the read-only status vector.
              	;
E917: 2AADE9  	getrov:	ld	hl,(wrtprt)
E91A: C329E9  		jp	getprm1
              	;
              	;   function to set the file attributes (read-only, system).
              	;
E91D: CD51E8  	setattr:call	autosel		;select proper drive then save attributes.
E920: CD3BE4  		call	saveattr
E923: C301E3  		jp	ststatus
              	;
              	;   function to return the address of the disk parameter block
              	; for the current drive.
              	;
E926: 2ABBE9  	getparm:ld	hl,(diskpb)
E929: 2245DF  	getprm1:ld	(status),hl
E92C: C9      		ret	
              	;
              	;   function to get or set the user number. if (e) was (ff)
              	; then this is a request to return the current user number.
              	; else set the user number from (e).
              	;
E92D: 3AD6E9  	getuser:ld	a,(eparam)	;get parameter.
E930: FEFF    		cp	0ffh		;get user number?
E932: C23BE9  		jp	nz,setuser
E935: 3A41DF  		ld	a,(userno)	;yes, just do it.
E938: C301DF  		jp	setstat
E93B: E61F    	setuser:and	1fh		;no, we should set it instead. keep low
E93D: 3241DF  		ld	(userno),a	;bits (0-4) only.
E940: C9      		ret	
              	;
              	;   function to read a random record from a file.
              	;
E941: CD51E8  	rdrandom: call	autosel		;select proper drive and read.
E944: C393E7  		jp	readran
              	;
              	;   function to compute the file size for random files.
              	;
E947: CD51E8  	wtrandom: call	autosel		;select proper drive and write.
E94A: C39CE7  		jp	writeran
              	;
              	;   function to compute the size of a random file.
              	;
E94D: CD51E8  	filesize: call	autosel		;select proper drive and check file length
E950: C3D2E7  		jp	ransize
              	;
              	;   function #37. this allows a program to log off any drives.
              	; on entry, set (de) to contain a word with bits set for those
              	; drives that are to be logged off. the log-in vector and the
              	; write protect vector will be updated. this must be a m/pm
              	; special function.
              	;
E953: 2A43DF  	logoff:	ld	hl,(params)	;get drives to log off.
E956: 7D      		ld	a,l		;for each bit that is set, we want
E957: 2F      		cpl			;to clear that bit in (login)
E958: 5F      		ld	e,a		;and (wrtprt).
E959: 7C      		ld	a,h
E95A: 2F      		cpl	
E95B: 2AAFE9  		ld	hl,(login)	;reset the login vector.
E95E: A4      		and	h
E95F: 57      		ld	d,a
E960: 7D      		ld	a,l
E961: A3      		and	e
E962: 5F      		ld	e,a
E963: 2AADE9  		ld	hl,(wrtprt)
E966: EB      		ex	de,hl
E967: 22AFE9  		ld	(login),hl	;and save.
E96A: 7D      		ld	a,l		;now do the write protect vector.
E96B: A3      		and	e
E96C: 6F      		ld	l,a
E96D: 7C      		ld	a,h
E96E: A2      		and	d
E96F: 67      		ld	h,a
E970: 22ADE9  		ld	(wrtprt),hl	;and save. all done.
E973: C9      		ret	
              	;
              	;   get here to return to the user.
              	;
E974: 3ADEE9  	goback:	ld	a,(auto)	;was auto select activated?
E977: B7      		or	a
E978: CA91E9  		jp	z,goback1
E97B: 2A43DF  		ld	hl,(params)	;yes, but was a change made?
E97E: 3600    		ld	(hl),0		;(* reset first byte of fcb *)
E980: 3AE0E9  		ld	a,(autoflag)
E983: B7      		or	a
E984: CA91E9  		jp	z,goback1
E987: 77      		ld	(hl),a		;yes, reset first byte properly.
E988: 3ADFE9  		ld	a,(olddrv)	;and get the old drive and select it.
E98B: 32D6E9  		ld	(eparam),a
E98E: CD45E8  		call	setdsk
E991: 2A0FDF  	goback1:ld	hl,(usrstack)	;reset the users stack pointer.
E994: F9      		ld	sp,hl
E995: 2A45DF  		ld	hl,(status)	;get return status.
E998: 7D      		ld	a,l		;force version 1.4 compatability.
E999: 44      		ld	b,h
E99A: C9      		ret			;and go back to user.
              	;
              	;   function #40. this is a special entry to do random i/o.
              	; for the case where we are writing to unused disk space, this
              	; space will be zeroed out first. this must be a m/pm special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
E99B: CD51E8  	wtspecl:call	autosel		;select proper drive.
E99E: 3E02    		ld	a,2		;use special write mode.
E9A0: 32D5E9  		ld	(mode),a
E9A3: 0E00    		ld	c,0		;set write indicator.
E9A5: CD07E7  		call	positn1		;position the file.
E9A8: CC03E6  		call	z,wtseq1	;and write (if no errors).
E9AB: C9      		ret	
              	;
              	;**************************************************************
              	;*
              	;*     bdos data storage pool.
              	;*
              	;**************************************************************
              	;
E9AC: E5      	emptyfcb: defb	0e5h		;empty directory segment indicator.
E9AD: 0000    	wrtprt:	defw	0		;write protect status for all 16 drives.
E9AF: 0000    	login:	defw	0		;drive active word (1 bit per drive).
E9B1: 8000    	userdma:defw	080h		;user's dma address (defaults to 80h).
              	;
              	;   scratch areas from parameter block.
              	;
E9B3: 0000    	scratch1: defw	0		;relative position within dir segment for file (0-3).
E9B5: 0000    	scratch2: defw	0		;last selected track number.
E9B7: 0000    	scratch3: defw	0		;last selected sector number.
              	;
              	;   disk storage areas from parameter block.
              	;
E9B9: 0000    	dirbuf:	defw	0		;address of directory buffer to use.
E9BB: 0000    	diskpb:	defw	0		;contains address of disk parameter block.
E9BD: 0000    	chkvect:defw	0		;address of check vector.
E9BF: 0000    	alocvect: defw	0		;address of allocation vector (bit map).
              	;
              	;   parameter block returned from the bios.
              	;
E9C1: 0000    	sectors:defw	0		;sectors per track from bios.
E9C3: 00      	blkshft:defb	0		;block shift.
E9C4: 00      	blkmask:defb	0		;block mask.
E9C5: 00      	extmask:defb	0		;extent mask.
E9C6: 0000    	dsksize:defw	0		;disk size from bios (number of blocks-1).
E9C8: 0000    	dirsize:defw	0		;directory size.
E9CA: 0000    	alloc0:	defw	0		;storage for first bytes of bit map (dir space used).
E9CC: 0000    	alloc1:	defw	0
E9CE: 0000    	offset:	defw	0		;first usable track number.
E9D0: 0000    	xlate:	defw	0		;sector translation table address.
              	;
              	;
E9D2: 00      	closeflg: defb	0		;close flag (=0ffh is extent written ok).
E9D3: 00      	rdwrtflg: defb	0		;read/write flag (0ffh=read, 0=write).
E9D4: 00      	fndstat:defb	0		;filename found status (0=found first entry).
E9D5: 00      	mode:	defb	0		;i/o mode select (0=random, 1=sequential, 2=special random).
E9D6: 00      	eparam:	defb	0		;storage for register (e) on entry to bdos.
E9D7: 00      	relblock: defb	0		;relative position within fcb of block number written.
E9D8: 00      	counter:defb	0		;byte counter for directory name searches.
E9D9: 00000000	savefcb:defw	0,0		;save space for address of fcb (for directory searches).
E9DD: 00      	bigdisk:defb	0		;if =0 then disk is > 256 blocks long.
E9DE: 00      	auto:	defb	0		;if non-zero, then auto select activated.
E9DF: 00      	olddrv:	defb	0		;on auto select, storage for previous drive.
E9E0: 00      	autoflag: defb	0		;if non-zero, then auto select changed drives.
E9E1: 00      	savnxt:	defb	0		;storage for next record number to access.
E9E2: 00      	savext:	defb	0		;storage for extent number of file.
E9E3: 0000    	savnrec:defw	0		;storage for number of records in file.
E9E5: 0000    	blknmbr:defw	0		;block number (physical sector) used within a file or logical sect
E9E7: 0000    	logsect:defw	0		;starting logical (128 byte) sector of block (physical sector).
E9E9: 00      	fcbpos:	defb	0		;relative position within buffer for fcb of file of interest.
E9EA: 0000    	filepos:defw	0		;files position within directory (0 to max entries -1).
              	;
              	;   disk directory buffer checksum bytes. one for each of the
              	; 16 possible drives.
              	;
E9EC: 00000000	cksumtbl: defb	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E9F0: 00...   	
              	
E9FC: 00000000		defb	0,0,0,0
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
              	
              	#include "../bios.asm"
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   B O O T   R O U T I N E S
              	;*
              	;**************************************************************
              	;
              	
              	;
              	;**************************************************************
              	;*
              	;*          B I O S   J U M P   T A B L E
              	;*
              	;*    This isn't actually used by the BDOS, but
              	;*    some applications (*cough* MBASIC) use it
              	;*    to directly address BIOS calls to get around
              	;*    the BDOS.
              	;*
              	;**************************************************************
              	;
EA00: C333EA  		jp	boot
EA03: C346EA  	wbootin:jp	wboot	; Indirection to wboot, used by MBASIC
EA06: C3A0EA  		jp	const
EA09: C3ABEA  		jp	conin
EA0C: C3B7EA  		jp	conout
EA0F: C3C3EA  		jp	list
EA12: C3C7EA  		jp	punch
EA15: C3CBEA  		jp	reader
EA18: C3D9EA  		jp	home
EA1B: C3DEEA  		jp	seldsk
EA1E: C3FCEA  		jp	settrk
EA21: C300EB  		jp	setsec
EA24: C304EB  		jp	setdma
EA27: C30AEB  		jp	read
EA2A: C30EEB  		jp	write
EA2D: C312EB  		jp	prstat
EA30: C315EB  		jp	sectrn
              	
              	; Cold boot entry
              	; Sets up some lower CP/M memory areas, and tells the INIT
              	; program to run on CP/M startup.
EA33: 3100D4  	boot:	ld	sp,cbase
              	
              		; Run the warm boot common code
EA36: CD5DEA  		call	wbootr
              		
              		; Special conditions for a cold boot
EA39: CD5EEB  		call	cbinit
              	
              		; Jump to CP/M
EA3C: 0E00    		ld	c,default
EA3E: C300D4  		jp	cbase
              	
              	
              	; Error boot entry
              	; Kinda like warm boot, but drive is reset to default
EA41: 3E00    	eboot:	ld	a,default
EA43: 320400  		ld	(tdrive),a
              	
              	; Warm boot entry
              	; Mainly just calls wbootr and manages IOBYTE
EA46: 3100D4  	wboot:	ld	sp,cbase
              	
              		; Save current drive + user
EA49: 3A0400  		ld	a,(tdrive)
EA4C: F5      		push	af
              	
              		; Save IOBYTE
EA4D: 3A0300  		ld	a,(iobyte)
EA50: F5      		push	af
              	
              		; Warm boot
EA51: CD5DEA  		call	wbootr
              		
              		; Restore IOBYTE
EA54: F1      		pop	af
EA55: 320300  		ld	(iobyte),a
              		
              		; Restore tdrive and warm boot
EA58: F1      		pop	af
EA59: 4F      		ld	c,a
EA5A: C300D4  		jp	cbase
              	
              	; Warm boot routine
              	; Sends init signal to device bus, loads CCP, and inits CP/M
              	; Does not actually jump to CP/M just yet
EA5D: F3      	wbootr:	di
              		
              		; Zero out BSS
EA5E: AF      		xor	a
EA5F: 215EF9  		ld	hl,_TEXT_end
EA62: 77      		ld	(hl),a
EA63: 115FF9  		ld	de,_TEXT_end+1
EA66: 018004  		ld	bc,_BSS_size
EA69: EDB0    		ldir
              	
              		; Send init signals to all devices
EA6B: 0600    		ld	b,0
EA6D: C5      	wboot0:	push	bc
EA6E: 2170EB  		ld	hl,bdevsw
EA71: 78      		ld	a,b
EA72: CD2DEB  		call	swindir
EA75: AF      		xor	a
EA76: 14      		inc	d
EA77: CC4AEB  		call	z,callmj
EA7A: C1      		pop	bc
EA7B: 04      		inc	b
EA7C: 3E14    		ld	a,20
EA7E: B8      		cp	b
EA7F: 20EC    		jr	nz,wboot0
              	
              		; Turn off batch mode
EA81: 3E00    		ld	a,0
EA83: 32E2D4  		ld	(batch),a
              	
              		; Load the CCP
EA86: CD6AEB  		call	resccp
              	
              		; Call config init
EA89: CD4FEB  		call	wbinit
              		
              		; Set up lower memory
EA8C: 2198EA  		ld	hl,cpmlow
EA8F: 110000  		ld	de,0
EA92: 010800  		ld	bc,8
EA95: EDB0    		ldir
              	
              	
              		; Return
EA97: C9      		ret
              	
              	
              	; This is not a true function, but a block of code to be copied
              	; to CP/M lower memory
EA98: C303EA  	cpmlow:	jp	wbootin	; Call jump table version instead
EA9B: 81      		defb	0x81	; Default IOBYTE
EA9C: 00      		defb	0	; Default drive
EA9D: C306DC  		jp	fbase	; BDOS entry 
              	
              	
              	; Console status
              	;
              	; Returns a=0xFF if there is a character
              	; uses: all
              	; Defaults to device 0 right now
EAA0: 0600    	const:	ld	b,0
EAA2: CD1EEB  		call	cdindir
EAA5: 14      		inc	d
EAA6: C0      		ret	nz
EAA7: 3C      		inc	a
EAA8: C34AEB  		jp	callmj
              		
              	; Console read
              	;
              	; Returns character in a
              	; uses: all
              	; Defaults to device 0 right now
EAAB: 0600    	conin:	ld	b,0
EAAD: CD1EEB  		call	cdindir
EAB0: 14      		inc	d
EAB1: C0      		ret	nz
EAB2: 3E02    		ld	a,2
EAB4: C34AEB  		jp	callmj
              		
              	; Console write
              	; c = Character to display
              	;
              	; uses: all
              	; Defaults to device 0 right now
EAB7: 0600    	conout:	ld	b,0
EAB9: CD1EEB  	chrout:	call	cdindir
EABC: 14      		inc	d
EABD: C0      		ret	nz
EABE: 3E03    		ld	a,3
EAC0: C34AEB  		jp	callmj
              		
              	; Printer write
              	; c = Character to print
              	;
              	; uses: all
EAC3: 0606    	list:	ld	b,6
EAC5: 18F2    		jr	chrout
              	
              	; Punch (or auxiliary) write
              	; c = Character to punch
              	;
EAC7: 0604    	punch:	ld	b,4
EAC9: 18EE    		jr	chrout
              	
              	; Reader (or auxiliary) read
              	;
              	; Returns character in a, or a=0x1A
EACB: 0602    	reader:	ld	b,2
EACD: CD1EEB  		call	cdindir
EAD0: 14      		inc	d
EAD1: 3E1A    		ld	a,0x1A
EAD3: C0      		ret	nz
EAD4: 3E02    		ld	a,2
EAD6: C34AEB  		jp	callmj
              		
              	; Move the current drive to track 0
              	;
              	; uses: all
EAD9: 3E01    	home:	ld	a,1
EADB: C3F6EA  		jp	callbd
              		
              	; Selects a block device
              	; c = Device to select
              	; e = Disk logging status
              	;
              	; return hl=0 if device not valid
              	; uses: all
EADE: 79      	seldsk:	ld	a,c
EADF: 43      		ld	b,e
EAE0: 2170EB  		ld	hl,bdevsw
EAE3: CD2DEB  		call	swindir
EAE6: 22F7EA  		ld	(callbd+1),hl
EAE9: 210000  		ld	hl,0
EAEC: 14      		inc	d
EAED: C0      		ret	nz
EAEE: 2A4BEB  		ld	hl,(callmj+1)
EAF1: 22FAEA  		ld	(callbd+4),hl
EAF4: 3E02    		ld	a,2
              		; Pass b = logging status, c = device #
              		
              	; Small stub to jump to the currently selected block device
              	; Also records hl as argument
              	;
              	; We love self-modfiying code!
EAF6: 21      	callbd:	defb	0x21
EAF7: 0000    		defw	0
EAF9: C3      		defb	0xC3
EAFA: 0000    		defw	0
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	;
              	; uses: all
EAFC: 3E03    	settrk:	ld	a,3
EAFE: 18F6    		jr	callbd
              		
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	;
              	; uses: all
EB00: 3E04    	setsec:	ld	a,4
EB02: 18F2    		jr	callbd
              	
              	; Sets the DMA address of the selected block device
              	; bc = DMA address
              	;
              	; uses: all
EB04: 60      	setdma:	ld	h,b
EB05: 69      		ld	l,c
EB06: 224DEB  		ld	(biodma),hl
EB09: C9      		ret
              		
              	; Reads the configured block from the selected block device
              	;
              	; uses: all
EB0A: 3E05    	read:	ld	a,5
EB0C: 18E8    		jr	callbd
              	
              	; Writes the configured block to the selected block device
              	; c = Deferred mode
              	;
              	; uses: all
EB0E: 3E06    	write:	ld	a,6
EB10: 18E4    		jr	callbd
              		
              	; "Printer" is always read for bytes
              	; Maybe in the future we will implement this, but for now
              	; this will do.
              	;
              	; Returns a=0xFF
EB12: 3EFF    	prstat:	ld	a,0xFF
EB14: C9      		ret
              		
              	; Provides sector translation
              	; Returns no translation for all devices
EB15: 60      	sectrn:	ld	h,b
EB16: 69      		ld	l,c
EB17: C9      		ret
              		
              	
              	; BDOS -> BIOS system hook
              	; stubs some stuff out, and then jumps to the config system hook
EB18: 32DEE9  	bshook:	ld	(auto),a
EB1B: C367EB  		jp	syshook
              		
              	; Character device switch indirection
              	; Obtains device by doing IOBYTE indirection
              	; Sets hl to cdevsw and jumps to swindir
EB1E: 04      	cdindir:inc	b
EB1F: 3A0300  		ld	a,(iobyte)
EB22: 05      	cdindi0:dec	b
EB23: 2803    		jr	z,cdindi1
EB25: 1F      		rra
EB26: 18FA    		jr	cdindi0
EB28: E603    	cdindi1:and	0x03
EB2A: 21B0EB  		ld	hl,cdevsw
              	
              	; Switch indirect helper function
              	; a = Device
              	; hl = Start of switch
              	;
              	; returns d=255 if device found, hl as argument
              	; uses: af, de, hl
EB2D: 110400  	swindir:ld	de,4
EB30: B7      		or	a
EB31: 2804    	swindi0:jr	z,swindi1
EB33: 19      		add	hl,de
EB34: 3D      		dec	a
EB35: 18FA    		jr	swindi0
EB37: 7E      	swindi1:ld	a,(hl)
EB38: 324BEB  		ld	(callmj+1),a
EB3B: 23      		inc	hl
EB3C: B6      		or	(hl)
EB3D: C8      		ret	z
EB3E: 7E      		ld	a,(hl)
EB3F: 324CEB  		ld	(callmj+2),a
EB42: 23      		inc	hl
EB43: 7E      		ld	a,(hl)
EB44: 23      		inc	hl
EB45: 66      		ld	h,(hl)
EB46: 6F      		ld	l,a
EB47: 16FF    		ld	d,255
EB49: C9      	nulldev:ret		; Just points to a return
              	
              	; Small stub to jump to the memory jump register
EB4A: C3      	callmj: defb	0xC3
EB4B: 0000    		defw	0
              	
              	
              	
              	; Variables
EB4D: 0000    	biodma:	defw	0	; Block device DMA address
              	
              	;
              	;**************************************************************
              	;*
              	;*        W A R M   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function is called at the end of a warm boot
              	;*    to set up hardware-specific stuff. 
              	;*
              	;**************************************************************
              	;
              	
EB4F: 3E01    	wbinit:	ld	a,0x01		; Bank out ROM
EB51: D300    		out	(0x00),a
              		
              		; Turn on batch mode
EB53: 3EFF    		ld	a,0xFF
EB55: 32E2D4  		ld	(batch),a
              		
              		; Also set interrupt mode 2 stuff
EB58: ED47    		ld	i,a
EB5A: ED5E    		im	2		; Start interrupts
EB5C: FB      		ei
              		
EB5D: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*        C O L D   B O O T   C O N F I G   H O O K
              	;*
              	;*    This function will run once during the intial cold
              	;*    boot. It is the last task to run before control is
              	;*    given to the CCP. This function is run after wbinit
              	;*
              	;**************************************************************
              	;
              	
EB5E: 3E06    	cbinit:	ld	a,6	; Enable INIT to run
EB60: 3204D4  		ld	(inbuff+1),a
EB63: C9      		ret
              	
              	;
              	;**************************************************************
              	;*
              	;*            I N T E R R U P T   H A N D L I N G
              	;*
              	;*     This function will be called in order to handle an
              	;*     interrupt if the need arises. Hooking drivers up to
              	;*     this code may be a little bit more involved.
              	;*
              	;**************************************************************
              	;
              	
EB64: FB      	cfirq:	ei
EB65: ED4D    		reti
              	
              	;
              	;**************************************************************
              	;*
              	;*              B D O S   C A L L   H O O K
              	;*
              	;*     This function is called everytime a BDOS call occurs.
              	;*     It can be used by specialized drivers to either inject
              	;*     new BDOS calls, or intercept existing ones.
              	;*
              	;*     Registers 'bc' and 'e' must be preserved if a call is
              	;*     going to be forwarded to the system. Register 'c' will
              	;*     contain BDOS call number.
              	;*       
              	;*
              	;**************************************************************
              	;
              	
EB67: C323F0  	syshook:jp	ns_sysh
              	
              	
              	;**************************************************************
              	;*
              	;*           B L O C K   D E V I C E   S W I T C H
              	;*
              	;*       IshkurCP/M can support up to 16 logical disks
              	;*       A single driver can be mapped to a number of
              	;*       these disks. Each logical disk is defined by a
              	;*       4-byte record. The first 2 bytes are a pointer
              	;*       to the device entry, and the last 2 are passed
              	;*       as an argument to the device. Usually this 
              	;*       takes the form of a minor number for indexing
              	;*       sub-disks on the same driver
              	;*
              	;*
              	;**************************************************************
              	;
              		
              	; One of the block devices needs to have the responsibiliy
              	; of loading the CCP into memory. Define the jump vector here
EB6A: C3FAEF  	resccp:	jp	ns_ccp
              	
              	; Additionally, if Ishkur is using a graphical device, that
              	; device may temporarily need to access the Graphical Resource
              	; Block (GRB) to load in fonts and such. This is up to 2k in
              	; size, and goes in the location that the CCP resides
EB6D: C3FFEF  	resgrb:	jp	ns_grb
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
EB70: 96EF0000	bdevsw:	defw	nfsdev,	0	; 'A'
EB74: 96EF0100		defw	nfsdev,	1	; 'B'
EB78: 21F70000		defw	nfddev,	0	; 'C'
EB7C: 21F70100		defw	nfddev,	1	; 'D'
EB80: 96EF0400		defw	nfsdev,	4	; 'E'
EB84: 96EF0500		defw	nfsdev,	5	; 'F'
EB88: 96EF0600		defw	nfsdev,	6	; 'G'
EB8C: 96EF0700		defw	nfsdev,	7	; 'H'
EB90: 96EF0800		defw	nfsdev,	8	; 'I'
EB94: 96EF0900		defw	nfsdev,	9	; 'J'
EB98: 96EF0A00		defw	nfsdev,	10	; 'K'
EB9C: 96EF0B00		defw	nfsdev,	11	; 'L'
EBA0: 96EF0C00		defw	nfsdev,	12	; 'M'
EBA4: 96EF0D00		defw	nfsdev,	13	; 'N'
EBA8: 96EF0E00		defw	nfsdev,	14	; 'O'
EBAC: 96EF0F00		defw	nfsdev,	15	; 'P'
              	
              	;
              	; Character device switch MUST come directly after in memory!
              	;
              	;**************************************************************
              	;*
              	;*        C H A R A C T E R   D E V I C E   S W I T C H
              	;*
              	;*      Currently, 4 character devices are supported. These
              	;*      devices are the console, the printer, and two "punches"
              	;*      (can be thought of as an auxillary serial device).
              	;*      All character devices use the same interface, which
              	;*      allows for easy indireciton. 
              	;*
              	;*	Device switch logic works about the same of the block
              	;*	devices.
              	;*
              	;**************************************************************
              	;
              	
              	; A device of "0" will be read as a non-existant device
              	; The 'init' signal can be sent to the same devices many 
              	; times if it has multipe entires in this table.
EBB0: 64F60000	cdevsw:	defw	siodev,	0	; TTY device
EBB4: C0EB0000		defw	vdpdev,	0	; Console device
EBB8: 3AF60000		defw	prtdev,	0	; Aux I/O device #1 (LPT)
EBBC: 00000000		defw	0,	0	; Aux I/O device #2 (GEN)
              	
              	;
              	;**************************************************************
              	;*
              	;*        D E V I C E   D R I V E R   I N C L U D E S
              	;*
              	;**************************************************************
              	;
              	
              	#include "../dev/nabu_vdp.asm"
              	;
              	;**************************************************************
              	;*
              	;*      T M S 9 9 1 8   C H A R A C T E R   D E V I C E
              	;*
              	;*      This device emulated a VT52 terminal using the
              	;*      TMS9918A graphics chip. The 2kb font record is
              	;*      not resident is memory, and must be provided by
              	;*      a compatable block I/O device.
              	;*
              	;*      F18A style 80 column mode is supported
              	;*
              	;*      This specific version uses the NABU keyboard as
              	;*      an input to the emulated termina 
              	;*
              	;*      Device requires 48 bytes of bss space (tm_bss)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
F95E: 00      	tm_outc:defs	1	; Output character
F95F: 00      	tm_scro:defs	1	; Scroll width
F960: 00      	tm_escs:defs	1	; Escape state
F961: 00      	tm_last:defs	1	; Last character read
F962: 00000000	tm_cbuf:defs	40	; 40 byte character buffer
F966: 00...   	
              	.area	_TEXT
              	
              	; TMS9918 Configuration
00A0:         	tm_data	equ	0xA0	; TMS9918 data register (mode=0)
00A1:         	tm_latc	equ	0xA1	; TMS9918 latch register (mode=1)
              	
0090:         	tm_keyd	equ	0x90	; Keyboard data register
0091:         	tm_keys	equ	0x91	; Keyboard status register
              	
0040:         	tm_ayda	equ	0x40	; AY-3-8910 data port
0041:         	tm_ayla	equ	0x41	; AY-3-8910 latch port
              	
              	; --- VRAM MAP ---
              	; 0x0000 - 0x07FF: Font
              	; 0x0800 - 0x0BFF: 40 column screen buffer
              	; 0x0C00 - 0x0FFF: Unused
              	; 0x1000 - 0x17FF: 80 column screen buffer
              	;
              	; Serial #
              	; 0x17FE: 0xE5
              	; 0x17FF: 0x81
              	
              	
              	; Driver jump table
EBC0: B7      	vdpdev:	or	a
EBC1: 2845    		jr	z,tm_init
EBC3: 3D      		dec	a
EBC4: 2819    		jr	z,tm_stat
EBC6: 3D      		dec	a
EBC7: CAAAEC  		jp	z,tm_read
EBCA: C308ED  		jp	tm_writ
              	
              	; A slower version of the OTIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
EBCD: F5      	tm_otir:push	af
EBCE: 7E      	tm_oti0:ld	a,(hl)
EBCF: ED79    		out	(c),a
EBD1: 23      		inc	hl
EBD2: 10FA    		djnz	tm_oti0
EBD4: F1      		pop	af
EBD5: C9      		ret
              		
              	; A slower version of the INIR instruction
              	; b = Number of cycles
              	; c = Output port
              	; hl = Memory pointer
              	;
              	; uses: bc, hl
EBD6: F5      	tm_inir:push	af
EBD7: ED78    	tm_inr0:in	a,(c)
EBD9: 77      		ld	(hl),a
EBDA: 23      		inc	hl
EBDB: 10FA    		djnz	tm_inr0
EBDD: F1      		pop	af
EBDE: C9      		ret
              	
              	
              	; Gets the status of the keyboard
              	;
              	; Returns a=0xFF if there is a key to read 
              	; uses: af, bc, de, hl
EBDF: CD53EF  	tm_stat:call	tm_dint
EBE2: CDEBEB  		call	tm_sta0
EBE5: F5      		push	af
EBE6: CD63EF  		call	tm_eint
EBE9: F1      		pop	af
EBEA: C9      		ret 
EBEB: 3A61F9  	tm_sta0:ld	a,(tm_last)
EBEE: FEE4    		cp	0xE4
EBF0: 2871    		jr	z,tm_scri
EBF2: FEE5    		cp	0xE5
EBF4: 287F    		jr	z,tm_sclf
EBF6: 3A5EF9  	tm_sta1:ld	a,(tm_outc)
EBF9: 3C      		inc	a
EBFA: 3EFF    		ld	a,0xFF
EBFC: C0      		ret	nz
EBFD: CD62EE  		call	tm_getc
EC00: 325EF9  		ld	(tm_outc),a
EC03: 3C      		inc	a
EC04: C8      		ret	z
EC05: 3EFF    		ld	a,0xFF
EC07: C9      		ret
              	
              	; TMS9918 init
              	; Load font record, set up terminal
EC08: CD6DEB  	tm_init:call	resgrb
              	
              		; Set up registers
EC0B: CD7FEC  		call	tm_setp
              		
              		; Set up interrupt vectors (if needed)
EC0E: 214DEF  		ld	hl,tm_virq
EC11: 2206FF  		ld	(intvec+6),hl
EC14: 2180EE  		ld	hl,tm_kirq
EC17: 2204FF  		ld	(intvec+4),hl
              		
              		; Set TMS pattern generator block to 0
EC1A: DBA1    		in	a,(tm_latc)
EC1C: AF      		xor	a
EC1D: D3A1    		out	(tm_latc),a
EC1F: 3E84    		ld	a,0x84
EC21: D3A1    		out	(tm_latc),a
              		
              		; Write the GRB
EC23: 010040  		ld	bc,0x4000
EC26: CD42EF  		call	tm_addr
EC29: 2100D4  		ld	hl,cbase
EC2C: 0EA0    		ld	c,tm_data
EC2E: 3E08    		ld	a,8	; Transfer 8*256 = 2048
EC30: 0600    	tm_ini0:ld	b,0
EC32: CDCDEB  		call	tm_otir
EC35: 3D      		dec	a
EC36: 20F8    		jr	nz,tm_ini0
              		
              		; Cold boot?
EC38: 3A75EF  		ld	a,(tm_cold)
EC3B: B7      		or	a
EC3C: 2012    		jr	nz,tm_ini1
              		
              		; Check serial #
EC3E: 01FE17  		ld	bc,0x17FE
EC41: CD42EF  		call	tm_addr
EC44: ED78    		in	a,(c)
EC46: FEE5    		cp	0xE5
EC48: 2006    		jr	nz,tm_ini1
EC4A: ED78    		in	a,(c)
EC4C: FE81    		cp	0x81
EC4E: 280D    		jr	z,tm_cloc
              		
              		; Reset the terminal
EC50: CD25EF  	tm_ini1:call	tm_cls
EC53: AF      		xor	a
EC54: 3273EF  		ld	(tm_curx),a
EC57: 3274EF  		ld	(tm_cury),a
EC5A: 3275EF  		ld	(tm_cold),a
              		
              		; Fall to tm_cloc
              		
              	; Clear the output character
              	;
              	; uses: af
EC5D: 3EFF    	tm_cloc:ld	a,0xFF
EC5F: 325EF9  		ld	(tm_outc),a
              	
EC62: C9      		ret
              		
              	; Scroll left / scroll right
              	;
              	; uses: af, bc, de, hl
EC63: 3A5FF9  	tm_scri:ld	a,(tm_scro)
EC66: B7      		or	a
EC67: FE28    		cp	40
EC69: 2808    		jr	z,tm_scr1
EC6B: C604    		add	a,4
EC6D: 325FF9  	tm_scr0:ld	(tm_scro),a
EC70: CD02EF  		call	tm_usco
EC73: 1881    	tm_scr1:jr	tm_sta1
EC75: 3A5FF9  	tm_sclf:ld	a,(tm_scro)
EC78: B7      		or	a
EC79: 28F8    		jr	z,tm_scr1
EC7B: D604    		sub	4
EC7D: 18EE    		jr	tm_scr0
              	
              	; Sets up registers depending on mode
              	; used to change between 40-col and 80-col
              	;
              	; uses: af, hl
EC7F: 2A6EEF  	tm_setp:ld	hl,(tm_mode)
              	
              		; Set TMS to text mode
EC82: DBA1    		in	a,(tm_latc)
EC84: 7C      		ld	a,h
EC85: D3A1    		out	(tm_latc),a
EC87: 3E80    		ld	a,0x80
EC89: D3A1    		out	(tm_latc),a
EC8B: DBA1    		in	a,(tm_latc)
EC8D: 3EF0    		ld	a,0xF0
EC8F: D3A1    		out	(tm_latc),a
EC91: 3E81    		ld	a,0x81
EC93: D3A1    		out	(tm_latc),a
              		
              		; Set TMS color
EC95: DBA1    		in	a,(tm_latc)
EC97: 3A70EF  		ld	a,(tm_colr)
EC9A: D3A1    		out	(tm_latc),a
EC9C: 3E87    		ld	a,0x87
EC9E: D3A1    		out	(tm_latc),a
              		
              		; Set TMS name table to 0x0800
ECA0: DBA1    		in	a,(tm_latc)
ECA2: 7D      		ld	a,l
ECA3: D3A1    		out	(tm_latc),a
ECA5: 3E82    		ld	a,0x82
ECA7: D3A1    		out	(tm_latc),a
ECA9: C9      		ret
              	
              	; Waits for the user to press a key, and returns it
              	;
              	; Returns ASCII key in A
              	; uses: af, bc, de, hl
ECAA: CD53EF  	tm_read:call	tm_dint
ECAD: CDB6EC  		call	tm_rea0
ECB0: F5      		push	af
ECB1: CD63EF  		call	tm_eint
ECB4: F1      		pop	af
ECB5: C9      		ret 
ECB6: 3A73EF  	tm_rea0:ld	a,(tm_curx)
ECB9: 4F      		ld	c,a
ECBA: 3A74EF  		ld	a,(tm_cury)
ECBD: 57      		ld	d,a
ECBE: 210010  		ld	hl,0x1000
ECC1: 3E50    		ld	a,80
ECC3: CDDEEE  		call	tm_chat
ECC6: DBA0    		in	a,(tm_data)	; char is in A
ECC8: 57      		ld	d,a		; char key
ECC9: 5F      		ld	e,a		; blinking char
ECCA: 0601    		ld	b,1
              		
ECCC: D5      	tm_rea1:push	de
ECCD: CDEBEB  		call	tm_sta0		; No interrupts!
ECD0: D1      		pop	de
ECD1: 3C      		inc	a
ECD2: 200D    		jr	nz,tm_rea2
ECD4: 5A      		ld	e,d
ECD5: CDF1EC  		call	tm_rea3
ECD8: 3A5EF9  		ld	a,(tm_outc)
ECDB: 47      		ld	b,a
ECDC: CD5DEC  		call	tm_cloc
ECDF: 78      		ld	a,b
ECE0: C9      		ret
              		
ECE1: CDFFEC  	tm_rea2:call	tm_stal
ECE4: 10E6    		djnz	tm_rea1
ECE6: 3E80    		ld	a,0x80
ECE8: AB      		xor	e
ECE9: 5F      		ld	e,a
ECEA: CDF1EC  		call	tm_rea3
ECED: 06BE    		ld	b,190
ECEF: 18DB    		jr	tm_rea1
              	
              	
ECF1: D5      	tm_rea3:push	de
ECF2: 3A73EF  		ld	a,(tm_curx)
ECF5: 4F      		ld	c,a
ECF6: 3A74EF  		ld	a,(tm_cury)
ECF9: 57      		ld	d,a
ECFA: CDBAEE  		call	tm_putc
ECFD: D1      		pop	de
ECFE: C9      		ret
              	
              	; Stalls out for a little bit
              	;
              	; uses: none
ECFF: C5      	tm_stal:push	bc
ED00: 06FF    		ld	b,255
ED02: C5      	tm_sta2:push	bc
ED03: C1      		pop	bc
ED04: 10FC    		djnz	tm_sta2
ED06: C1      		pop	bc
ED07: C9      		ret
              	
              	
              	; Writes a character to the screen
              	; c = Character to write
              	;
              	; Returns c,b as next position 
              	; uses: af, bc, de, hl
ED08: CD53EF  	tm_writ:call	tm_dint
ED0B: 59      		ld	e,c
ED0C: 3A73EF  		ld	a,(tm_curx)
ED0F: 4F      		ld	c,a
ED10: 3A74EF  		ld	a,(tm_cury)
ED13: 57      		ld	d,a
ED14: CD23ED  		call	tm_wri0
ED17: 78      		ld	a,b
ED18: 3274EF  		ld	(tm_cury),a
ED1B: 79      		ld	a,c
ED1C: 3273EF  		ld	(tm_curx),a
ED1F: CD63EF  		call	tm_eint
ED22: C9      		ret
              		
              	; Write helper routine
              	; c = X position
              	; d = Y position
              	; e = Character
              	;
              	; Returns c,b as next position
ED23: 42      	tm_wri0:ld	b,d		; c = X, b = Y
ED24: 3A60F9  		ld	a,(tm_escs)
ED27: B7      		or	a		; Process escape code
ED28: C295ED  		jp	nz,tm_esc
ED2B: 3E1F    		ld	a,0x1F
ED2D: BB      		cp	e
ED2E: D262ED  		jp	nc,tm_wri1	; Process control code
ED31: C5      		push	bc
ED32: CDBAEE  		call	tm_putc		; Write character
ED35: C1      		pop	bc
              		
              		; Increment character
ED36: 0C      	tm_ri	inc	c
ED37: 3E50    		ld	a,80
ED39: B9      		cp	c
ED3A: C0      		ret	nz
ED3B: AF      		xor	a
ED3C: 4F      		ld	c,a
ED3D: 04      	tm_lf:  inc	b	; Line feed
ED3E: 3E18    		ld	a,24
ED40: B8      		cp	b
ED41: C0      		ret	nz
ED42: C5      		push	bc
ED43: CD3CEE  		call	tm_dsco
ED46: C1      		pop	bc
ED47: 05      		dec	b
ED48: C9      		ret
ED49: AF      	tm_cr:	xor	a	; Carriage return
ED4A: 4F      		ld	c,a
ED4B: C9      		ret
ED4C: 0D      	tm_bs:	dec	c	; Backspace 
ED4D: F0      		ret	p
ED4E: 0E4F    		ld	c,79
ED50: 05      		dec	b
ED51: F0      		ret	p
ED52: AF      		xor	a
ED53: 47      		ld	b,a
ED54: 4F      		ld	c,a
ED55: C9      		ret
ED56: AF      	tm_up:	xor	a	; Move up
ED57: B8      		cp	b
ED58: C8      		ret	z
ED59: 05      		dec	b
ED5A: C9      		ret
ED5B: CD25EF  	tm_cshm:call	tm_cls
ED5E: AF      	tm_home:xor	a
ED5F: 47      		ld	b,a
ED60: 4F      		ld	c,a
ED61: C9      		ret
              	
ED62: 7B      	tm_wri1:ld	a,e
ED63: FE07    		cp	0x07	; Bell
ED65: CA1BEE  		jp	z,tm_bell
ED68: FE08    		cp	0x08	; '\b' (Cursor left)
ED6A: 28E0    		jr	z,tm_bs
ED6C: FE12    		cp	0x12	; Cursor right
ED6E: 28C6    		jr	z,tm_ri
ED70: FE0A    		cp	0x0A	; '\n' (Cursor down)
ED72: 28C9    		jr	z,tm_lf
ED74: FE0B    		cp	0x0B	; Cursor up
ED76: 28DE    		jr	z,tm_up
ED78: FE0D    		cp	0x0D	; '\r' 
ED7A: 28CD    		jr	z,tm_cr
ED7C: FE17    		cp	0x17	; Clear end of screen
ED7E: 2856    		jr	z,tm_cles
ED80: FE18    		cp	0x18	; Clear end of line
ED82: 2854    		jr	z,tm_clea
ED84: FE1A    		cp	0x1A	; Clear screen, home cursor
ED86: 28D3    		jr	z,tm_cshm
ED88: FE1E    		cp	0x1E	; Home cursor
ED8A: 28D2    		jr	z,tm_home
ED8C: FE1B    		cp	0x1B	; Escape
ED8E: C0      		ret	nz
ED8F: 3E01    		ld	a,1
ED91: 3260F9  		ld	(tm_escs),a
ED94: C9      		ret
              		
              		; Handle escape sequence
ED95: 3D      	tm_esc:	dec	a
ED96: 280E    		jr	z,tm_esc0
ED98: 3D      		dec	a
ED99: 2825    		jr	z,tm_esc1
ED9B: 3D      		dec	a
ED9C: 282D    		jr	z,tm_esc2
ED9E: 3D      		dec	a
ED9F: 2871    		jr	z,tm_updc
EDA1: AF      	tm_escd:xor	a	; Escape done
EDA2: 3260F9  	tm_escr:ld	(tm_escs),a
EDA5: C9      		ret
EDA6: 3EFF    	tm_esc0:ld	a,0xFF	; Do 40-col
EDA8: BB      		cp	e
EDA9: 2850    		jr	z,tm_40c
EDAB: 3EFE    		ld	a,0xFE	; Do 80-col
EDAD: BB      		cp	e
EDAE: 2858    		jr	z,tm_80c
EDB0: 3EFD    		ld	a,0xFD	; Set color
EDB2: BB      		cp	e
EDB3: 2859    		jr	z,tm_scol
EDB5: 3E3D    		ld	a,0x3D	; '='
EDB7: BB      		cp	e
EDB8: 20E7    		jr	nz,tm_escd
EDBA: 3A60F9  	tm_esci:ld	a,(tm_escs)
EDBD: 3C      		inc	a
EDBE: 18E2    		jr	tm_escr
EDC0: 7B      	tm_esc1:ld	a,e
EDC1: 1E20    		ld	e,0x20
EDC3: 93      		sub	e
EDC4: FE18    		cp	24
EDC6: 30D9    		jr	nc,tm_escd
EDC8: 47      		ld	b,a
EDC9: 18EF    		jr	tm_esci
EDCB: 7B      	tm_esc2:ld	a,e
EDCC: 1E20    		ld	e,0x20
EDCE: 93      		sub	e
EDCF: FE50    		cp	80
EDD1: 30CE    		jr	nc,tm_escd
EDD3: 4F      		ld	c,a
EDD4: 18CB    		jr	tm_escd
              		
              		; Clear segment
              		; B = ending line
EDD6: 0617    	tm_cles:ld	b,23
EDD8: 04      	tm_clea:inc	b
EDD9: 1E00    		ld	e,0
EDDB: C5      		push	bc
EDDC: D5      		push	de
EDDD: 3E50    		ld	a,80
EDDF: 210050  		ld	hl,0x5000
EDE2: CDDEEE  		call	tm_chat
EDE5: D1      		pop	de
EDE6: C1      		pop	bc
EDE7: AF      	tm_cle0:xor	a
EDE8: D3A0    		out	(tm_data),a
EDEA: 0C      		inc	c
EDEB: 3E50    		ld	a,80
EDED: B9      		cp	c
EDEE: 20F7    		jr	nz,tm_cle0
EDF0: 14      		inc	d
EDF1: AF      		xor	a
EDF2: 4F      		ld	c,a
EDF3: 7A      		ld	a,d
EDF4: B8      		cp	b
EDF5: 20F0    		jr	nz,tm_cle0
EDF7: D1      		pop	de	; Do not update character
EDF8: C302EF  		jp	tm_usco
              		
EDFB: E5      	tm_40c:	push	hl
EDFC: 210200  		ld	hl,0x0002
EDFF: 226EEF  	tm_cupd:ld	(tm_mode),hl
EE02: CD7FEC  		call	tm_setp
EE05: E1      		pop	hl
EE06: 1899    		jr	tm_escd
              		
EE08: E5      	tm_80c:	push	hl
EE09: 210704  		ld	hl,0x0407
EE0C: 18F1    		jr	tm_cupd
              		
              		; Set color command
EE0E: 3E04    	tm_scol:ld	a,4
EE10: 1890    		jr	tm_escr
              		
              		; Update color here
EE12: 7B      	tm_updc:ld	a,e
EE13: 3270EF  		ld	(tm_colr),a
EE16: CD7FEC  		call	tm_setp
EE19: 1886    		jr	tm_escd
              	
              		; Ring the bell
EE1B: AF      	tm_bell:xor	a
EE1C: D341    		out	(tm_ayla),a
EE1E: D340    		out	(tm_ayda),a
EE20: 3C      		inc	a
EE21: D341    		out	(tm_ayla),a
EE23: 3E80    		ld	a,0x80
EE25: D340    		out	(tm_ayda),a
EE27: 3E07    		ld	a,7
EE29: D341    		out	(tm_ayla),a
EE2B: DB40    		in	a,(tm_ayda)
EE2D: E6C0    		and	0xC0
EE2F: F63E    		or	0x3E
EE31: D340    		out	(tm_ayda),a
EE33: 3E08    		ld	a,8
EE35: D341    		out	(tm_ayla),a
EE37: 3E0F    		ld	a,0x0F
EE39: D340    		out	(tm_ayda),a
EE3B: C9      		ret
              		
              	
              		
              	; Scroll both frame buffers down one
              	;
              	; uses: af, bc, de, hl
EE3C: 212808  	tm_dsco:ld	hl,0x0800+40
EE3F: 110048  		ld	de,0x4800
EE42: 0618    		ld	b,24
EE44: CD4FEE  		call	tm_dsc0
EE47: 215010  		ld	hl,0x1000+80
EE4A: 110050  		ld	de,0x5000
EE4D: 0630    		ld	b,48
EE4F: C5      	tm_dsc0:push	bc
EE50: D5      		push	de
EE51: E5      		push	hl
EE52: CDEAEE  		call	tm_vcpy
EE55: E1      		pop	hl
EE56: D1      		pop	de
EE57: 012800  		ld	bc,40
EE5A: 09      		add	hl,bc
EE5B: EB      		ex	de,hl
EE5C: 09      		add	hl,bc
EE5D: EB      		ex	de,hl
EE5E: C1      		pop	bc
EE5F: 10EE    		djnz	tm_dsc0
EE61: C9      		ret
              		
              	
              	; Grabs the latest key pressed by the keyboard
              	; Discard keyboard errors
              	; Returns key in A, or 0xFF if none
              	;
              	; uses: af, bc, de, hl
EE62: 3A72EF  	tm_getc:ld	a,(tm_inf)
EE65: B7      		or	a
EE66: 3E00    		ld	a,0
EE68: 3272EF  		ld	(tm_inf),a
EE6B: 3A71EF  		ld	a,(tm_inb)
EE6E: 2008    		jr	nz,tm_get0
              	
EE70: DB91    		in	a,(tm_keys)
EE72: E602    		and	2
EE74: 3D      		dec	a
EE75: F8      		ret	m
              		
              		; Grab the key
EE76: DB90    		in	a,(tm_keyd)
EE78: 3261F9  	tm_get0:ld	(tm_last),a
EE7B: CD8EEE  		call	tm_map
EE7E: 79      		ld	a,c
EE7F: C9      		ret
              		
              	; Handles a keyboard interrupt for the VDP terminal driver
              	; Keypress stored in tm_inb and tm_inf flag is set
              	; 
              	; uses: none
EE80: F5      	tm_kirq:push	af
EE81: DB90    		in	a,(tm_keyd)
EE83: 3271EF  		ld	(tm_inb),a
EE86: 3E01    		ld	a,1
EE88: 3272EF  		ld	(tm_inf),a
EE8B: F1      		pop	af
EE8C: FB      		ei
EE8D: C9      		ret
              		
              		
              	; Maps keyboard input to ASCII
              	; a = Key to map
              	;
              	; Returns mapped key in c
              	; uses: af, c
EE8E: 4F      	tm_map:	ld	c,a
              		
              		; Mapping function
EE8F: 21A5EE  		ld	hl,tm_mapt
EE92: 7E      	tm_map0:ld	a,(hl)
EE93: B7      		or	a
EE94: 2808    		jr	z,tm_map2
EE96: B9      		cp	c
EE97: 23      		inc	hl
EE98: 7E      		ld	a,(hl)
EE99: 23      		inc	hl
EE9A: 20F6    		jr	nz,tm_map0
EE9C: 4F      		ld	c,a
EE9D: C9      		ret
              		
              		
              		; Filter non-ASCII
EE9E: 79      	tm_map2:ld	a,c
EE9F: E680    		and	0x80	
EEA1: C8      		ret	z
EEA2: 0EFF    		ld	c,0xFF
EEA4: C9      		ret
              		
              	; Map table
EEA5: 7F08    	tm_mapt:defb	0x7F,0x08	; DEL -> BS
EEA7: E108    		defb	0xE1,0x08	; '<-' -> BS
EEA9: EA7F    		defb	0xEA,0x7F	; TV -> DEL
EEAB: E00C    		defb	0xE0,0x0C	; '->' -> Right
EEAD: E20B    		defb	0xE2,0x0B	; '/\' -> Up
EEAF: E30A    		defb	0xE3,0x0A	; '\/' -> Linefeed 
EEB1: E95C    		defb	0xE9,0x5C	; PAUSE -> '\'
EEB3: E860    		defb	0xE8,0x60	; SYM -> '@'
EEB5: E67C    		defb	0xE6,0x7C	; NO -> '|'
EEB7: E77E    		defb	0xE7,0x7E	; YES -> '~'
EEB9: 00      		defb	0
              	
              	; Puts a character on the screen
              	; c = X position
              	; d = Y position
              	; e = Character to put
              	;
              	; uses: af, bc, de, hl
EEBA: 210050  	tm_putc:ld	hl,0x5000
EEBD: 3E50    		ld	a,80
EEBF: C5      		push	bc
EEC0: D5      		push	de
EEC1: CDDEEE  		call	tm_chat	; Place it in the 80 col buffer
EEC4: ED59    		out	(c),e
EEC6: D1      		pop	de
EEC7: C1      		pop	bc
EEC8: 3A5FF9  	tm_putf:ld	a,(tm_scro)	; Place into frame buffer
EECB: 47      		ld	b,a
EECC: 79      		ld	a,c
EECD: 90      		sub	b	; If character is less than scroll...
EECE: 4F      		ld	c,a
EECF: F8      		ret	m
EED0: FE28    		cp	40	; If desired position is 40 or more
EED2: D0      		ret	nc
EED3: 210048  		ld	hl,0x4800
EED6: 3E28    		ld	a,40
EED8: CDDEEE  		call	tm_chat	; Place it in the 40 col screen buffer
EEDB: ED59    		out	(c),e
EEDD: C9      		ret
              	
              	; Sets the TMS address to a character at x,y
              	; a = Line width
              	; c = X position
              	; d = Y position
              	; hl = Buffer address
              	;
              	; uses: af, bc, d, hl
EEDE: 0600    	tm_chat:ld	b,0
EEE0: 09      		add	hl,bc
EEE1: 4F      		ld	c,a
EEE2: AF      		xor	a
EEE3: BA      		cp	d
EEE4: 285A    	tm_cha0:jr	z,tm_addh
EEE6: 09      		add	hl,bc
EEE7: 15      		dec	d
EEE8: 18FA    		jr	tm_cha0
              	
              	; Copies VRAM from one location to another
              	; Transfers occur in blocks of 40 bytes
              	; de = destination address
              	; hl = source location
              	;
              	; b = 0 on return
              	; uses: af, bc, de, hl
EEEA: CD40EF  	tm_vcpy:call	tm_addh
EEED: 0628    		ld	b,40
EEEF: 2162F9  		ld	hl,tm_cbuf
EEF2: CDD6EB  		call	tm_inir
EEF5: EB      		ex	de,hl
EEF6: CD40EF  		call	tm_addh
EEF9: 0628    		ld	b,40
EEFB: 2162F9  		ld	hl,tm_cbuf
EEFE: CDCDEB  		call	tm_otir
EF01: C9      		ret
              		
              	; Updates the frame buffer based on the scroll position
              	;
              	; uses: af, bc, de, hl
EF02: 210010  	tm_usco:ld	hl,0x1000
EF05: 110048  		ld	de,0x4800
EF08: 3A5FF9  		ld	a,(tm_scro)
EF0B: 0600    		ld	b,0
EF0D: 4F      		ld	c,a
EF0E: 09      		add	hl,bc
EF0F: 0618    		ld	b,24
EF11: C5      	tm_usc0:push	bc
EF12: D5      		push	de
EF13: E5      		push	hl
EF14: CDEAEE  		call	tm_vcpy
EF17: E1      		pop	hl
EF18: D1      		pop	de
EF19: 0E50    		ld	c,80
EF1B: 09      		add	hl,bc
EF1C: EB      		ex	de,hl
EF1D: 0E28    		ld	c,40
EF1F: 09      		add	hl,bc
EF20: EB      		ex	de,hl
EF21: C1      		pop	bc
EF22: 10ED    		djnz	tm_usc0
EF24: C9      		ret
              		
              	
              	; Clears out screen buffer and offscreen buffer
              	; Also includes clear limited function
              	;
              	; uses: af, bc, de
EF25: 010048  	tm_cls:	ld	bc,0x4800
EF28: 11FE0F  		ld	de,0x1000-2
EF2B: CD42EF  		call	tm_addr
EF2E: ED71    	tm_cls0:out	(c),0
EF30: 1B      		dec	de
EF31: 7A      		ld	a,d
EF32: B3      		or	e
EF33: 20F9    		jr	nz,tm_cls0
              		
              		; Write super special serial #
EF35: 3EE5    		ld	a,0xE5
EF37: ED79    		out	(c),a
EF39: F5      		push	af
EF3A: F1      		pop	af
EF3B: 3E81    		ld	a,0x81
EF3D: ED79    		out	(c),a
EF3F: C9      		ret
              	
              	; Sets the TMS address for either reading or writing
              	; bc = Address 
              	;
              	; Returns tm_data in c
              	; uses: af, bc
EF40: 44      	tm_addh:ld	b,h		; Does HL instead of BC
EF41: 4D      		ld	c,l
EF42: DBA1    	tm_addr:in	a,(tm_latc)
EF44: 79      		ld	a,c
EF45: D3A1    		out	(tm_latc),a
EF47: 78      		ld	a,b
EF48: D3A1    		out	(tm_latc),a
EF4A: 0EA0    		ld	c,tm_data
EF4C: C9      		ret
              		
              	; Handles a TMS9918 irq
EF4D: F5      	tm_virq:push	af
EF4E: DBA1    		in	a,(tm_latc)
EF50: F1      		pop	af
EF51: FB      		ei
EF52: C9      		ret
              		
              		
              	; Disables all interrupts while VDP operations occur
              	;
              	; uses: a
EF53: 3EC9    	tm_dint:ld	a,0xC9
EF55: 323800  		ld	(0x38),a
EF58: ED56    		im	1
EF5A: 3E0E    		ld	a,0x0E
EF5C: D341    		out	(tm_ayla),a	; AY register = 14
EF5E: 3E00    		ld	a,0x00
EF60: D340    		out	(tm_ayda),a	
EF62: C9      		ret
              		
              	; Enables interrupts again
              	;
              	; uses: a
EF63: 3E0E    	tm_eint:ld	a,0x0E
EF65: D341    		out	(tm_ayla),a	; AY register = 14
EF67: 3EB0    		ld	a,0xB0
EF69: D340    		out	(tm_ayda),a
EF6B: ED5E    		im	2
EF6D: C9      		ret
              		
              	; Variables
EF6E: 0200    	tm_mode:defw	0x0002
EF70: E1      	tm_colr:defb	0xE1
EF71: 00      	tm_inb:	defb	0
EF72: 00      	tm_inf:	defb	0
EF73: 00      	tm_curx:defb	0
EF74: 00      	tm_cury:defb	0
EF75: 01      	tm_cold:defb	1
              	#include "../dev/nabu_nfs.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   N H A C P   F I L E   S Y S T E M
              	;*
              	;*    Unlike a standard block device, the NFS driver provides
              	;*    a CP/M filesystem by directly intercepting system calls.
              	;*    By doing this, it can access provide access to an external
              	;*    filesystem via NHACP.
              	;*
              	;*    Virtual filesystems are directories labelled "A", "B",
              	;*    "C", etc... on the host system. That are converted to
              	;*    minor numbers 0, 1, 2, etc... when the driver is being
              	;*    added to the block device switch  
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
F98A: 00000000	ns_buff:defs	48	; Buffer (48b)
F98E: 00...   	
F9BA: 00000000	ns_ptrn:defs	11	; Pattern buffer (11b)
F9BE: 00...   	
F9C5: 00000000	ns_name:defs	11	; Name bufffer (11b)
F9C9: 00...   	
F9D0: 0000    	ns_mask:defs	2	; Ownership mask (2b)
F9D2: 0000    	ns_cfcb:defs	2	; Current FCB (2b)
F9D4: 00      	ns_dore:defs	1	; Do reopen? (1b)
F9D5: 00      	ns_isls:defs	1	; Is listing dir? (1b)
F9D6: 00      	ns_tran:defs	1	; Number of bytes in transfer (1b)
              	.area	_TEXT
              	
0040:         	ns_ayda	equ	0x40		; AY-3-8910 data port
0041:         	ns_atla	equ	0x41		; AY-3-8910 latch port
0080:         	ns_hcca	equ	0x80		; Modem data port
0000:         	ns_nctl	equ	0x00		; NABU control port
              	
0081:         	ns_fild	equ	0x81		; Default file access desc
              	
              	
              	;
              	;**************************************************************
              	;*
              	;*         D U M M Y   D I S K   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Dummy DPH
EF76: 00000000	ns_dph:	defw	0,0,0,0
EF7A: 00000000	
EF7E: 10FF    		defw	dircbuf	; DIRBUF
EF80: 86EF    		defw	ns_dpb	; DPB
EF82: 0000    		defw	0	; CSV
EF84: 95EF    		defw	ns_alv	; ALV 
              		
              		
              	; Dummy format
EF86: 4000    	ns_dpb:	defw	64	; # sectors per track
EF88: 03      		defb	3	; BSH
EF89: 07      		defb	7	; BLM
EF8A: 00      		defb	0	; EXM
EF8B: 0100    		defw	1	; DSM
EF8D: 0000    		defw	0	; DRM
EF8F: 00      		defb	0	; AL0
EF90: 00      		defb	0	; AL1
EF91: 0000    		defw	0	; Size of directory check vector
EF93: 0000    		defw	0	; Number of reserved tracks at the beginning of disk
              		
              	; Dummy ALV
EF95: 00      	ns_alv: defb	0
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
EF96: B7      	nfsdev:	or	a
EF97: 2807    		jr	z,ns_init
EF99: 3D      		dec	a
EF9A: 3D      		dec	a
EF9B: 2814    		jr	z,ns_sel
EF9D: 3E01    		ld	a,1
EF9F: C9      		ret
              	
              	; Inits the device
              	; Figures out which devices that the NFS driver "owns"
              	; b = Logical CP/M device #
              	; hl = Call argument
              	;
              	; uses: does not matter
EFA0: 78      	ns_init:ld	a,b
EFA1: CD9DF3  		call	ns_domk
EFA4: 2AD0F9  		ld	hl,(ns_mask)
EFA7: 7C      		ld	a,h
EFA8: B0      		or	b
EFA9: 67      		ld	h,a
EFAA: 7D      		ld	a,l
EFAB: B1      		or	c
EFAC: 6F      		ld	l,a
EFAD: 22D0F9  		ld	(ns_mask),hl
EFB0: C9      		ret
              	
              	
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses: hl
EFB1: 11B9E9  	ns_sel:	ld	de,dirbuf
EFB4: 217EEF  		ld	hl,ns_dph+8
EFB7: 010800  		ld	bc,8
EFBA: EDB0    		ldir
EFBC: C374E9  		jp	goback
              		
              	
              	; Set up the HCCA modem connection
              	; Configures the AY-3-8910 to monitor correct interrupts
              	; and leaves it in a state where the interrupt port is
              	; exposed
              	;
              	; uses: a, b
EFBF: 3E07    	ns_hini:ld	a,0x07
EFC1: D341    		out	(ns_atla),a	; AY register = 7
EFC3: DB40    		in	a,(ns_ayda)
EFC5: E63F    		and	0x3F
EFC7: F640    		or	0x40
EFC9: D340    		out	(ns_ayda),a	; Configure AY port I/O
              		
              		; Claim interrupt vectors
EFCB: E5      		push	hl
EFCC: 21D2F4  		ld	hl,ns_rirq
EFCF: 2200FF  		ld	(intvec),hl
EFD2: 2119F5  		ld	hl,ns_wirq
EFD5: 2202FF  		ld	(intvec+2),hl
EFD8: E1      		pop	hl
              		
              	; Set interrupts to their default state
              	;
              	; uses: a
EFD9: 3E0E    	ns_dflt:ld	a,0x0E
EFDB: D341    		out	(ns_atla),a	; AY register = 14
EFDD: 3EB0    		ld	a,0xB0
EFDF: D340    		out	(ns_ayda),a	; Enable HCCA receive and but not send, plus key and VDP
              		
EFE1: 3E0F    	ns_dfl0:ld	a,0x0F		
EFE3: D341    		out	(ns_atla),a	; AY register = 15
              		
EFE5: C9      		ret
              	
              	; Set receive and send interrupts
              	;
              	; uses: a
EFE6: 3E0E    	ns_esnd:ld	a,0x0E
EFE8: D341    		out	(ns_atla),a	; AY register = 14
EFEA: 3EC0    		ld	a,0xC0
EFEC: D340    		out	(ns_ayda),a	; Enable HCCA receive and send
EFEE: 18F1    		jr	ns_dfl0
              		
              	; Set receive but not send interrupt
              	;
              	; uses: a
EFF0: 3E0E    	ns_dsnd:ld	a,0x0E
EFF2: D341    		out	(ns_atla),a	; AY register = 14
EFF4: 3E80    		ld	a,0x80
EFF6: D340    		out	(ns_ayda),a	; Enable HCCA receive and but not send
EFF8: 18E7    		jr	ns_dfl0
              	
              	; Loads the CCP into the CCP space
EFFA: 218FF5  	ns_ccp:	ld	hl,ns_p0
EFFD: 1803    		jr	ns_grb0
              		
              	; Loads the GRB into the CCP space
EFFF: 219CF5  	ns_grb:	ld	hl,ns_p1
F002: 11B2F5  	ns_grb0:ld	de,ns_m0na
F005: 010D00  		ld	bc,13
F008: EDB0    		ldir			; Copy name to file open
F00A: CDBFEF  		call	ns_hini		; Go to HCCA mode
F00D: 210000  		ld	hl,0x0000	; O_RDONLY
F010: CDDEF3  		call	ns_opef		; Open the file
F013: 110000  		ld	de,0
F016: 2100D4  		ld	hl,cbase
F019: CDFDF3  	ns_grb1:call	ns_getb
F01C: 1C      		inc	e
F01D: 3E10    		ld	a,16
F01F: BB      		cp	e
F020: 20F7    		jr	nz,ns_grb1
F022: C9      		ret
              		
              	; CP/M system hook
              	; Used to intercept certain syscalls
              	;
              	; uses: af if not hooked, all otherwise
F023: 79      	ns_sysh:ld	a,c
F024: D60F    		sub	15
F026: D8      		ret	c		; No syscalls lower than 15
F027: 2841    		jr	z,ns_fopn	; Open file
F029: 3D      		dec	a
F02A: CAAAF0  		jp	z,ns_fcls	; Close file
F02D: 3D      		dec	a
F02E: CA5BF1  		jp	z,ns_sfir	; Search for first 
F031: 3D      		dec	a
F032: CA80F1  		jp	z,ns_snxt	; Search for next 
F035: 3D      		dec	a
F036: CAD0F1  		jp	z,ns_dele	; Delete file
F039: 3D      		dec	a
F03A: CA89F2  		jp	z,ns_frea	; File read next record
F03D: 3D      		dec	a
F03E: CAB5F2  		jp	z,ns_fwri	; File write next record
F041: 3D      		dec	a
F042: CA08F3  		jp	z,ns_fmak	; Create file
F045: 3D      		dec	a
F046: CA2FF3  		jp	z,ns_frnm	; Rename file
F049: D607    		sub	7
F04B: 2817    		jr	z,ns_stmp	; Set file attributes (stump)
F04D: D603    		sub	3
F04F: CACFF2  		jp	z,ns_rrea	; File read random
F052: 3D      		dec	a
F053: CADEF2  		jp	z,ns_rwri	; File write random
F056: 3D      		dec	a
F057: CA73F3  		jp	z,ns_size	; Compute file size
F05A: 3D      		dec	a
F05B: CAEDF2  		jp	z,ns_rrec	; Update random access pointer
F05E: D604    		sub	4
F060: CADEF2  		jp	z,ns_rwri	; FIle write random (we will ignore the zero part)
F063: C9      		ret
              		
              	; Stump, do nothing if FCB is owned
              	; de = Address to FCB
              	;
              	; uses: does not matter
F064: CDA9F3  	ns_stmp:call	ns_ownr
              	
F067: C374E9  		jp	goback
              		
              	; Parses the current FCB, and searches for a file that matches
              	; the pattern.
              	; The point here is to insert the "true" name of the file into
              	; the FCB so it can be accessed later
              	; de = Address of FCB
              	;
              	; uses: af, bc, de, hl
F06A: CDA9F3  	ns_fopn:call	ns_ownr
              	
              		; Go find the file
F06D: D5      		push	de
F06E: CD00F1  		call	ns_find
              		
              		; Update status
F071: 210000  		ld	hl,0
F074: 2245DF  		ld	(status),hl
              		
              		; Copy over false CP/M filename to the FCB
F077: D1      		pop	de
F078: CD8BF3  		call	ns_nblk		; Get # of blocks
F07B: 79      		ld	a,c
F07C: D5      		push	de
F07D: 13      		inc	de
F07E: 21C5F9  		ld	hl,ns_name
F081: 010B00  		ld	bc,11
F084: EDB0    		ldir
              		
              		; Set open flag
F086: 4F      		ld	c,a
F087: 13      		inc	de
F088: 3EE7    		ld	a,0xE7
F08A: 12      		ld	(de),a
F08B: 13      		inc	de
F08C: AF      		xor	a
F08D: 12      		ld	(de),a
F08E: 13      		inc	de
F08F: 79      		ld	a,c
F090: 12      		ld	(de),a
F091: 13      		inc	de
              		
              		; Copy over the real filename to the FCB
F092: 011000  		ld	bc,16
F095: 21A0F9  		ld	hl,ns_buff+22
F098: EDB0    		ldir
              		
              	
              		; Check if current
F09A: D1      		pop	de
F09B: 2AD2F9  		ld	hl,(ns_cfcb)
F09E: ED52    		sbc	hl,de
F0A0: 2005    		jr	nz,ns_fop0
              	
              		; Set the reopen flag
F0A2: 3E01    		ld	a,1
F0A4: 32D4F9  		ld	(ns_dore),a
              		
F0A7: C374E9  	ns_fop0:jp	goback
              		
              	; Close the file
              	; Main purpose is to ensure that a close on this device is deferred
              	; Also resets the open flag
              	; de = Address of DPH
              	;
              	; uses: does not matter
F0AA: CDA9F3  	ns_fcls:call	ns_ownr
              	
              		; Reset open flag
F0AD: 210D00  		ld	hl,13
F0B0: 19      		add	hl,de
F0B1: 3600    		ld	(hl),0x00
              		
              		; Set flag
F0B3: 210000  		ld	hl,0
F0B6: 2245DF  		ld	(status),hl
              	
F0B9: C374E9  		jp	goback
              		
              	; Function call to start a list-dir operation
              	; Must be called before a file search
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, de, hl
F0BC: D5      	ns_slst:push	de		; Save de
F0BD: 21B2F5  		ld	hl,ns_m0na
F0C0: EB      		ex	de,hl
F0C1: CD62F5  		call	ns_sdir 
F0C4: AF      		xor	a
F0C5: 12      		ld	(de),a		; Zero terminate string
F0C6: 3E01    		ld	a,1
F0C8: 32D4F9  		ld	(ns_dore),a	; The existing file will be closed unconditionally
F0CB: 210800  		ld	hl,0x0008	; Set flag type to directory
F0CE: CDDEF3  		call	ns_opef		; Call ns_open, but don't set flag
F0D1: 21FF00  		ld	hl,0x00FF
F0D4: 2245DF  		ld	(status),hl	; Set status
F0D7: C274E9  		jp	nz,goback	; Error if cannot open file
              		
              		; Send LIST-DIR
F0DA: 21E4F5  		ld	hl,ns_m4
F0DD: 0607    		ld	b,7
F0DF: CD8AF4  		call	ns_send		; Start list-dir command
F0E2: 218AF9  		ld	hl,ns_buff
F0E5: CD6CF4  		call	ns_rece
F0E8: 3A8AF9  		ld	a,(ns_buff)	; Check for errors
F0EB: FE81    		cp	0x81
F0ED: C274E9  		jp	nz,goback
              		
              		; Copy the file pattern to the pattern buffer
F0F0: E1      		pop	hl		; Get the FCB back
F0F1: 23      		inc	hl
F0F2: 11BAF9  		ld	de,ns_ptrn
F0F5: 060B    		ld	b,11
F0F7: 7E      	ns_sls0:ld	a,(hl)
F0F8: E67F    		and	0x7F		; Fix for CP/M stupidness
F0FA: 12      		ld	(de),a
F0FB: 13      		inc	de
F0FC: 23      		inc	hl
F0FD: 10F8    		djnz	ns_sls0
F0FF: C9      		ret
              	
              	; Does a complete find operation
              	; Calls ns_slst, and then falls to ns_find
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, de ,hl
F100: CDBCF0  	ns_find:call	ns_slst		; Complete find operation
              		
              	; Put the next found file name into the name buffer
              	; If no more names are found, exit with status of 0x00FF
              	; ns_slst must have been run to set up state, no more disk operations
              	; should be been run in the meantime.
              	; enter into ns_lis0 to avoid setting status
              	;
              	; uses: af, bc, de, hl
              	
F103: 21FF00  	ns_list:ld	hl,0x00FF
F106: 2245DF  		ld	(status),hl	; Set status
              	
              		
F109: 218AF9  	ns_lis0:ld	hl,ns_buff	; Clear out the first 40 bytes of the buffer
F10C: AF      		xor	a		; This is to emulate zero termination, due
F10D: 77      		ld	(hl),a		; To the fact that NHACP does not zero-terminate
F10E: 118BF9  		ld	de,ns_buff+1	; strings coming back from the adapter...
F111: 012800  		ld	bc,40		
F114: EDB0    		ldir			
              	
              		; Lets read a directory now
F116: 21EBF5  		ld	hl,ns_m5	; Entry point from ns_sfir
F119: 0607    		ld	b,7
F11B: CD8AF4  		call	ns_send		; Get the next file
F11E: 218AF9  		ld	hl,ns_buff
F121: CD6CF4  		call	ns_rece	
F124: 3A8AF9  		ld	a,(ns_buff)	; Ensure we got FILE-INFO
F127: FE86    		cp	0x86
F129: C274E9  		jp	nz,goback
              		
              		; Ok, time to format a directory entry
F12C: 21A0F9  		ld	hl,ns_buff+22
F12F: 11C5F9  		ld	de,ns_name
F132: 0608    		ld	b,8
              		
              		; Format first part of file
F134: CD6CF1  		call	ns_ffmt
              		
              		; Now we must skip till we either find a '.' or a '\0'
F137: 7E      	ns_lis1:ld	a,(hl)
F138: B7      		or	a
F139: 2805    		jr	z,ns_lis2
F13B: 23      		inc	hl
F13C: FE2E    		cp	'.'
F13E: 20F7    		jr	nz,ns_lis1
              		
              		; Now the last part
F140: 0603    	ns_lis2:ld	b,3
F142: CD6CF1  		call	ns_ffmt
              		
              		; Back dir entry against pattern
F145: 11BAF9  		ld	de,ns_ptrn
F148: 21C5F9  		ld	hl,ns_name
F14B: 060B    		ld	b,11
              	
F14D: 1A      	ns_lis3:ld	a,(de)
F14E: 4E      		ld	c,(hl)
F14F: 23      		inc	hl
F150: 13      		inc	de
F151: FE3F    		cp	'?'
F153: 2803    		jr	z,ns_lis4
F155: B9      		cp	c
F156: 20B1    		jr	nz,ns_lis0
F158: 10F3    	ns_lis4:djnz	ns_lis3
F15A: C9      		ret
              		
              	; Search for first file
              	; Opens up a directory, then skips to routines that read the first dir entry
              	; de = Address of FCB
              	;
              	; uses: all
F15B: AF      	ns_sfir:xor	a
F15C: 32D5F9  		ld	(ns_isls),a	; Clear "isls" flag
F15F: CDA9F3  		call	ns_ownr
              		
              		; Start the list-dir function
F162: CDBCF0  		call	ns_slst
              		
              		; Set isls flag
F165: 3E01    		ld	a,1
F167: 32D5F9  		ld	(ns_isls),a
              		
              		; Move into ns_snxt
F16A: 181C    		jr	ns_snx0
              		
              	; Format incoming files into a dir entry
              	; Will copy over characters until a '.' or '\0' is reached
              	; Any remaining characters will be filled out with spaces
              	; b = Number of characters
              	; de = Destination of data
              	; hl = Source of data
              	;
              	; uses: af, b, de, hl
F16C: 7E      	ns_ffmt:ld	a,(hl)
F16D: CD75F5  		call	ns_ltou
F170: B7      		or	a
F171: 2804    		jr	z,ns_ffm0
F173: FE2E    		cp	'.'
F175: 2003    		jr	nz,ns_ffm1
F177: 2B      	ns_ffm0:dec	hl
F178: 3E20    		ld	a,' '		; Turn it into a space
F17A: 23      	ns_ffm1:inc	hl
F17B: 12      		ld	(de),a
F17C: 13      		inc	de
F17D: 10ED    		djnz	ns_ffmt
F17F: C9      		ret
              		
              	; Search for next file
              	; Takes the open directory and gets the next file
              	;
              	; uses: all
F180: 3AD5F9  	ns_snxt:ld	a,(ns_isls)
F183: B7      		or	a
F184: C8      		ret	z
              		
              		; Set up the HCCA
F185: CDBFEF  		call	ns_hini	
              		
              		; Find the next entry
F188: CD03F1  	ns_snx0:call	ns_list
              		
              		; Copy to directory entry
F18B: ED5B4DEB		ld	de,(biodma)
F18F: 3A41DF  		ld	a,(userno)
F192: 12      		ld	(de),a
F193: 13      		inc	de
F194: 21C5F9  		ld	hl,ns_name
F197: 010B00  		ld	bc,11
F19A: EDB0    		ldir
              		
              		; Get file size
F19C: CD8BF3  		call	ns_nblk
              		
F19F: AF      		xor	a
F1A0: B8      		cp	b
F1A1: 0610    		ld	b,16
F1A3: 200F    		jr	nz,ns_snx1
F1A5: AF      		xor	a
F1A6: CB39    		srl	c
F1A8: 17      		rla
F1A9: CB39    		srl	c
F1AB: 17      		rla
F1AC: CB39    		srl	c
F1AE: 17      		rla
F1AF: B7      		or	a
F1B0: 41      		ld	b,c
F1B1: 2801    		jr	z,ns_snx1
F1B3: 04      		inc	b
              		
              		
              		; Set the records to 0
F1B4: 48      	ns_snx1:ld	c,b
F1B5: 0604    		ld	b,4
F1B7: AF      		xor	a
F1B8: 12      	ns_snx2:ld	(de),a
F1B9: 13      		inc	de
F1BA: 10FC    		djnz	ns_snx2
              		
              		; Spoof file size 1-16KB
F1BC: 0610    		ld	b,16
F1BE: 79      		ld	a,c
F1BF: 12      	ns_snx3:ld	(de),a
F1C0: 13      		inc	de
F1C1: B7      		or	a
F1C2: 2801    		jr	z,ns_snx4
F1C4: 3D      		dec	a
F1C5: 10F8    	ns_snx4:djnz	ns_snx3
              		
              		; Set status to 0 and return
F1C7: 210000  		ld	hl,0
F1CA: 2245DF  		ld	(status),hl
F1CD: C374E9  		jp	goback
              		
              	; Delete files based on pattern
              	; Will return error if less than 1 file is found
              	; de = Address to FCB
              	;
              	; uses: all
F1D0: CDA9F3  	ns_dele:call	ns_ownr
              	
              		; Set first part of remove message prototype
F1D3: F5      		push	af
F1D4: EB      		ex	de,hl
F1D5: 11FAF5  		ld	de,ns_m6na
F1D8: CD62F5  		call	ns_sdir
F1DB: 3E2F    		ld	a,'/'
F1DD: 12      		ld	(de),a
F1DE: EB      		ex	de,hl
F1DF: F1      		pop	af
              	
              		; Start the list-dir function
F1E0: CDBCF0  		call	ns_slst
              		
              		; Search for the next entry, do not set flag
F1E3: CD09F1  	ns_del0:call	ns_lis0
              	
              		; Copy over file name into message
F1E6: 11FDF5  		ld	de,ns_m6na+3
F1E9: 21A0F9  		ld	hl,ns_buff+22
F1EC: 011000  		ld	bc,16
F1EF: EDB0    		ldir
              		
              		; Send delete message
F1F1: 21F2F5  		ld	hl,ns_m6
F1F4: 061B    		ld	b,27
F1F6: CD8AF4  		call	ns_send
F1F9: 218AF9  		ld	hl,ns_buff
F1FC: CD6CF4  		call	ns_rece
              		
              		; Set status to 0, and get next element
F1FF: 210000  		ld	hl,0
F202: 2245DF  		ld	(status),hl
F205: 18DC    		jr	ns_del0
              	
              		
              	; Prepare to access a file
              	; Checks the magic number to ensure that the file is in fact open
              	; Also checks ns_dore and ns_cfcb to see if a reopen is required
              	; If so, copy filename from FCB and do NHACP open
              	; a = Logical NHACP device
              	; de = Address of FCB
              	;
              	; uses: af, bc, hl
F207: 4F      	ns_aces:ld	c,a
F208: 210D00  		ld	hl,13
F20B: 19      		add	hl,de
F20C: 7E      		ld	a,(hl)
F20D: FEE7    		cp	0xE7
F20F: 2809    		jr	z,ns_ace0
              		
              		; Return invalid FCB
F211: 210900  		ld	hl,9
F214: 2245DF  		ld	(status),hl
F217: C374E9  		jp	goback
              		
              		; Check to see if it is currently being accessed
F21A: 2AD2F9  	ns_ace0:ld	hl,(ns_cfcb)
F21D: ED52    		sbc	hl,de
F21F: 2005    		jr	nz,ns_ace1
              		
              		; See if a reopen is needed
F221: 3AD4F9  		ld	a,(ns_dore)
F224: B7      		or	a
F225: C8      		ret	z
              		
              		; A reopen is needed, do it!
F226: 21FF00  	ns_ace1:ld	hl,0x00FF
F229: 2245DF  		ld	(status),hl
              		
              		; Set the current FCB to this one
F22C: ED53D2F9		ld	(ns_cfcb),de
              		
              		; Clear ns_dore flag
F230: AF      		xor	a
F231: 32D4F9  		ld	(ns_dore),a
              		
              		; Copy over the true filename
F234: 211000  		ld	hl,16
F237: 19      		add	hl,de
F238: D5      		push	de
F239: 11B2F5  		ld	de,ns_m0na
F23C: 79      		ld	a,c
F23D: CD62F5  		call	ns_sdir
F240: 3E2F    		ld	a,'/'
F242: 12      		ld	(de),a
F243: 13      		inc	de
F244: 011000  		ld	bc,16
F247: EDB0    		ldir
              		
              		; Now open the file
F249: CDDBF3  		call	ns_open
F24C: D1      		pop	de
F24D: C9      		ret
              		
              	; Takes in a FCB, and returns the current record to access
              	; de = Address to FCB
              	;
              	; Returns record # in bc
              	; uses: af, bc, hl
F24E: 210C00  	ns_gcre:ld	hl,0x0C
F251: 19      		add	hl,de
F252: 46      		ld	b,(hl)
F253: 0E00    		ld	c,0
F255: CB38    		srl	b
F257: CB19    		rr	c
F259: 23      		inc	hl
F25A: 23      		inc	hl
F25B: 7E      		ld	a,(hl)
F25C: 07      		rlca
F25D: 07      		rlca
F25E: 07      		rlca
F25F: 07      		rlca
F260: B0      		or	b
F261: 47      		ld	b,a
F262: 212000  		ld	hl,0x20
F265: 19      		add	hl,de
F266: 7E      		ld	a,(hl)
F267: B1      		or	c
F268: 4F      		ld	c,a
F269: C9      		ret
              		
              	; Takes in a random record, and writes it to the FCB
              	; bc = Record #
              	; de = Address to FCB
              	;
              	; uses: af, bc, hl
F26A: 212000  	ns_scre:ld	hl,0x20
F26D: 19      		add	hl,de
F26E: 79      		ld	a,c
F26F: E67F    		and	0x7F
F271: 77      		ld	(hl),a
F272: 210E00  		ld	hl,0x0E
F275: 19      		add	hl,de
F276: 78      		ld	a,b
F277: 0F      		rrca
F278: 0F      		rrca
F279: 0F      		rrca
F27A: 0F      		rrca
F27B: E60F    		and	0x0F
F27D: 77      		ld	(hl),a
F27E: 2B      		dec	hl
F27F: 2B      		dec	hl
F280: CB21    		sla	c
F282: CB10    		rl	b
F284: 78      		ld	a,b
F285: E60F    		and	0x0F
F287: 77      		ld	(hl),a
F288: C9      		ret
              			
              	; Read next record
              	; Reads the next 128 bytes in a file into the DMA address
              	; The FCB record count will be incremented by 1
              	; de = Address of FCB
              	;
              	; uses: all
F289: CDA9F3  	ns_frea:call	ns_ownr
              	
              		; Set file up to access
F28C: CD07F2  		call	ns_aces
              		
              		; Get the record to read
F28F: CD4EF2  		call	ns_gcre
              		
              		; Set up and do read
F292: C5      		push	bc
F293: D5      		push	de
F294: 50      	ns_fre0:ld	d,b
F295: 59      		ld	e,c
F296: 2A4DEB  		ld	hl,(biodma)
F299: CDFDF3  		call	ns_getb
              		
              		; Make sure there were no issues
F29C: DA74E9  	ns_fre1:jp	c,goback
              		
              		; Increment and writeback
F29F: D1      		pop	de
F2A0: C1      		pop	bc
F2A1: 03      		inc	bc
F2A2: CD6AF2  		call	ns_scre
              		
              		; Set return status
F2A5: 210000  		ld	hl,0
F2A8: 3AD6F9  		ld	a,(ns_tran)
F2AB: B7      		or	a
F2AC: 2001    		jr	nz,ns_fre2
F2AE: 23      		inc	hl
              		
F2AF: 2245DF  	ns_fre2:ld	(status),hl
F2B2: C374E9  		jp	goback
              		
              	; Write next record
              	; Writes the next 128 bytes into a file from the DMA address
              	; The FCB record count will be incremented by 1
              	; de = Address of FCB
              	;
              	; uses: all
F2B5: CDA9F3  	ns_fwri:call	ns_ownr
              	
              		; Set file up to access
F2B8: CD07F2  		call	ns_aces
              		
              		; Get the record to write
F2BB: CD4EF2  		call	ns_gcre
              		
              		; Set up and do write
F2BE: C5      		push	bc
F2BF: D5      		push	de
F2C0: 50      	ns_fwr0:ld	d,b
F2C1: 59      		ld	e,c
F2C2: 2A4DEB  		ld	hl,(biodma)
F2C5: CD3EF4  		call	ns_putb
              		
              		; Set amount transfered to 128
F2C8: 3E80    		ld	a,128
F2CA: 32D6F9  		ld	(ns_tran),a
              		
              		; Continue in read
F2CD: 18CD    		jr	ns_fre1
              		
              	; Read record random
              	; Takes the random address and read a sector from it
F2CF: CDA9F3  	ns_rrea:call	ns_ownr
              	
              		; Set file up to access
F2D2: CD07F2  		call	ns_aces
              		
              		; Decode random address
F2D5: CD00F3  		call	ns_deco
F2D8: 0B      		dec	bc
F2D9: C5      		push	bc
F2DA: D5      		push	de
F2DB: 03      		inc	bc
F2DC: 18B6    		jr	ns_fre0
              		
              	; Write record random
              	; Takes the random address and write a sector to it
              	; de = Address to FCB
              	;
              	; uses: all
F2DE: CDA9F3  	ns_rwri:call	ns_ownr
              	
              		; Set file up to access
F2E1: CD07F2  		call	ns_aces
              		
              		; Decode random address
F2E4: CD00F3  		call	ns_deco
F2E7: 0B      		dec	bc
F2E8: C5      		push	bc
F2E9: D5      		push	de
F2EA: 03      		inc	bc
F2EB: 18D3    		jr	ns_fwr0
              		
              	; Set random record
              	; de = Address to FCB
              	;
              	; uses: all
F2ED: CDA9F3  	ns_rrec:call	ns_ownr
              		
              		; Get current address from FCB
F2F0: CD4EF2  		call	ns_gcre
              		
              		; Set FCB random record
F2F3: 212100  		ld	hl,0x21
F2F6: 19      		add	hl,de
F2F7: 71      		ld	(hl),c
F2F8: 23      		inc	hl
F2F9: 70      		ld	(hl),b
F2FA: 23      		inc	hl
F2FB: 3600    		ld	(hl),0
              		
              		; Done
F2FD: C374E9  		jp	goback
              		
              	; Decodes random address
              	; de = Address to FCB
              	;
              	; Returns block number in bc
              	; uses: af, bc, hl
F300: 212100  	ns_deco:ld	hl,0x21
F303: 19      		add	hl,de
F304: 4E      		ld	c,(hl)
F305: 23      		inc	hl
F306: 46      		ld	b,(hl)
F307: C9      		ret
              		
              	; Make new file
              	; Reboot the system if the file already exists
              	; de = Address to FCB
              	;
              	; uses: all
F308: CDA9F3  	ns_fmak:call	ns_ownr
              	
              		; We either succeed or die trying
F30B: 210000  		ld	hl,0
F30E: 2245DF  		ld	(status),hl
              	
              		; Decode filename into open buffer
F311: 21B2F5  		ld	hl,ns_m0na
F314: D5      		push	de
F315: EB      		ex	de,hl
F316: 23      		inc	hl
F317: CD2AF5  		call	ns_form
              		
              		; Set the flag and open
F31A: 213000  		ld	hl,0x0030
F31D: 22AFF5  		ld	(ns_m0fl),hl
F320: CDDEF3  		call	ns_opef
              		
              		; Error? time to reboot!
F323: C20000  		jp	nz,0
              		
              		; Nope? Activate FCB
F326: D1      		pop	de
              		
              		; Force reopen
F327: 3E01    		ld	a,1
F329: 32D4F9  		ld	(ns_dore),a
              		
              		; Do an open
F32C: C36AF0  		jp	ns_fopn
              		
              	; Rename file
              	; Similar to delete, wildcards are allowed
              	; de = Address to FCB
              	;
              	; uses: all
F32F: CDA9F3  	ns_frnm:call	ns_ownr
              	
              		; Set first part of rename message prototype
F332: F5      		push	af
F333: EB      		ex	de,hl
F334: 1113F6  		ld	de,ns_m7n0
F337: CD62F5  		call	ns_sdir
F33A: 3E2F    		ld	a,'/'
F33C: 12      		ld	(de),a
F33D: F1      		pop	af
F33E: F5      		push	af
F33F: E5      		push	hl
F340: 111100  		ld	de,17
F343: 19      		add	hl,de
F344: 1127F6  		ld	de,ns_m7n1
F347: CD2AF5  		call	ns_form
F34A: D1      		pop	de
F34B: F1      		pop	af
              		
              	
              		; Start the list-dir function
F34C: CDBCF0  		call	ns_slst
              		
              		; Search for the next entry, do not set flag
F34F: CD09F1  	ns_frn0:call	ns_lis0
              	
              		; Copy over file name into message
F352: 1116F6  		ld	de,ns_m7n0+3
F355: 21A0F9  		ld	hl,ns_buff+22
F358: 011000  		ld	bc,16
F35B: EDB0    		ldir
              		
              		; Send rename message
F35D: 210DF6  		ld	hl,ns_m7
F360: 062D    		ld	b,45
F362: CD8AF4  		call	ns_send
F365: 218AF9  		ld	hl,ns_buff
F368: CD6CF4  		call	ns_rece
              		
              		; Set status to 0, and get next element
F36B: 210000  		ld	hl,0
F36E: 2245DF  		ld	(status),hl
F371: 18DC    		jr	ns_frn0
              		
              	; Place size of file into FCB
              	; de = Address to FCB
              	;
              	; uses: all
F373: CDA9F3  	ns_size:call	ns_ownr
              	
              		; Find file
F376: D5      		push	de
F377: CD00F1  		call	ns_find
F37A: D1      		pop	de
              		
              		; Get number of blocks
F37B: CD8BF3  		call	ns_nblk
              		
              		; Set in FCB
F37E: 212100  		ld	hl,0x21
F381: 19      		add	hl,de
F382: 71      		ld	(hl),c
F383: 23      		inc	hl
F384: 70      		ld	(hl),b
F385: 23      		inc	hl
F386: 3600    		ld	(hl),0
              	
F388: C374E9  		jp	goback	
              		
              	; Use a FILE-INFO block in ns_buff to calculate
              	; the number of blocks in a file
              	;
              	; Returns number of blocks in bc
              	; uses: af, bc, hl
F38B: 219DF9  	ns_nblk:ld	hl,ns_buff+19
F38E: 46      		ld	b,(hl)
F38F: 2B      		dec	hl
F390: 4E      		ld	c,(hl)
F391: 2B      		dec	hl
F392: 7E      		ld	a,(hl)
F393: CB27    		sla	a
F395: CB11    		rl	c
F397: CB10    		rl	b
F399: B7      		or	a
F39A: C8      		ret	z
F39B: 03      		inc	bc
F39C: C9      		ret
              		
              	; Set a 16 bit mask based on a number from 0-15
              	; a = Bit to set
              	;
              	; Returns bit mask in bc
              	; uses: af, bc
F39D: 010100  	ns_domk:ld	bc,1
F3A0: B7      		or	a
F3A1: C8      	ns_dom0:ret	z
F3A2: CB21    		sla	c
F3A4: CB10    		rl	b
F3A6: 3D      		dec	a
F3A7: 18F8    		jr	ns_dom0
              		
              	; Check if driver owns device
              	; Bail if it does not
              	; If it does, get the logical NHACP device
              	; de = Address of FCB
              	;
              	; Returns logical device in a
              	; uses: af, hl
F3A9: C5      	ns_ownr:push	bc
F3AA: CDD4F3  		call	ns_getd		; Get FCB device
F3AD: CD9DF3  		call	ns_domk		; Create bitmask
F3B0: 2AD0F9  		ld	hl,(ns_mask)
F3B3: 7C      		ld	a,h
F3B4: A0      		and	b
F3B5: 2002    		jr	nz,ns_own0
F3B7: 7D      		ld	a,l
F3B8: A1      		and	c
F3B9: 2816    	ns_own0:jr	z,ns_exit	; Exit if does not own	
F3BB: 2172EB  		ld	hl,bdevsw+2
F3BE: CDD4F3  		call	ns_getd		; Get FCB device
F3C1: 010400  		ld	bc,4
F3C4: B7      		or	a
F3C5: 2804    	ns_own1:jr	z,ns_own2
F3C7: 09      		add	hl,bc
F3C8: 3D      		dec	a
F3C9: 18FA    		jr	ns_own1
F3CB: CDBFEF  	ns_own2:call	ns_hini		; We are commited at this point, init HCCA
F3CE: 7E      		ld	a,(hl)		; a = Logical NHACP device
F3CF: C1      		pop	bc
F3D0: C9      		ret
              	
              	; Exit, do not return to caller
F3D1: C1      	ns_exit:pop	bc
F3D2: F1      		pop	af		; Throw away caller address
F3D3: C9      		ret
              	
              	; Gets the logical device number from a FCB
              	; de = Address of FCB
              	; 
              	; Logical device returns in a
              	; uses: af
F3D4: 1A      	ns_getd:ld	a,(de)
F3D5: 3D      		dec	a
F3D6: F0      		ret	p
F3D7: 3A42DF  		ld	a,(active)
F3DA: C9      		ret
              	
              	; Open the prepared file
              	; Closes the existing file too
              	; ns_opef can be called to set custom flag
              	;
              	; Flag z cleared on error
              	; uses: af, b, hl
F3DB: 210200  	ns_open:ld	hl,0x0002	; Read/Write Protect flag
F3DE: 22AFF5  	ns_opef:ld	(ns_m0fl),hl
F3E1: 21C6F5  		ld	hl,ns_m1
F3E4: 0606    		ld	b,6
F3E6: CD8AF4  		call	ns_send
F3E9: 21A9F5  		ld	hl,ns_m0
F3EC: 061C    		ld	b,28
F3EE: CD8AF4  		call	ns_send
F3F1: 218AF9  		ld	hl,ns_buff
F3F4: CD6CF4  		call	ns_rece
F3F7: 3A8AF9  		ld	a,(ns_buff)
F3FA: FE83    		cp	0x83
F3FC: C9      		ret
              		
              	; Gets a block from the currently open file
              	; and places it in (hl)
              	; de = Block to read
              	; hl = Destination for information
              	;
              	; Returns location directly after in hl
              	; Carry flag set on error
              	; uses: af, b, hl
F3FD: CD03F4  	ns_getb:call	ns_get0
F400: C3D9EF  		jp	ns_dflt
F403: EB      	ns_get0:ex	de,hl
F404: 22D2F5  		ld	(ns_m2bn),hl
F407: EB      		ex	de,hl
F408: E5      		push	hl
F409: 21CCF5  		ld	hl,ns_m2
F40C: 060C    		ld	b,12
F40E: CD8AF4  		call	ns_send
F411: E1      		pop	hl
F412: D8      		ret	c
F413: CD93F4  		call	ns_hcrd
F416: CD96F4  		call	ns_hcre
F419: D8      		ret	c
F41A: FE84    		cp	0x84
F41C: 37      		scf
F41D: 2017    		jr	nz,ns_get2
F41F: CD96F4  		call	ns_hcre
F422: 32D6F9  		ld	(ns_tran),a
F425: 47      		ld	b,a
F426: CD96F4  		call	ns_hcre
F429: 78      		ld	a,b
F42A: B7      		or	a
F42B: C8      		ret	z
F42C: CD96F4  	ns_get1:call	ns_hcre
F42F: D8      		ret	c
F430: 77      		ld	(hl),a
F431: 23      		inc	hl
F432: 10F8    		djnz	ns_get1
F434: B7      		or	a
F435: C9      		ret
F436: CD93F4  	ns_get2:call	ns_hcrd	; Read the error message and exit
F439: CD96F4  		call	ns_hcre
F43C: 37      		scf
F43D: C9      		ret
              		
              	; Puts a block into the currently open file
              	; from that location (hl)
              	; de = Block to write
              	; hl = Source of information
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F43E: CD44F4  	ns_putb:call	ns_put0
F441: C3D9EF  		jp	ns_dflt
F444: EB      	ns_put0:ex	de,hl
F445: 22DEF5  		ld	(ns_m3bn),hl
F448: EB      		ex	de,hl
F449: E5      		push	hl
F44A: 21D8F5  		ld	hl,ns_m3
F44D: 060C    		ld	b,12
F44F: CD8AF4  		call	ns_send		; Send message precursor
F452: E1      		pop	hl
F453: D8      		ret	c
F454: 0680    		ld	b,128
F456: 7E      	ns_put1:ld	a,(hl)		; Send the block
F457: CDE0F4  		call	ns_hcwr
F45A: D8      		ret	c
F45B: 23      		inc	hl
F45C: 10F8    		djnz	ns_put1
F45E: 218AF9  		ld	hl,ns_buff
F461: CD6CF4  		call	ns_rece
F464: 3A8AF9  		ld	a,(ns_buff)
F467: FE81    		cp	0x81
F469: C8      		ret	z
F46A: 37      		scf
F46B: C9      		ret
              		
              	; Receives a general response from the NHACP server
              	; hl = Destination of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F46C: CDF0EF  	ns_rece:call	ns_dsnd
F46F: CD75F4  		call	ns_rec0
F472: C3D9EF  		jp	ns_dflt
F475: CD96F4  	ns_rec0:call	ns_hcre
F478: D8      		ret	c		; Existing error
F479: 47      		ld	b,a
F47A: CD96F4  		call	ns_hcre
F47D: D8      		ret	c		; Existing error
F47E: 37      		scf
F47F: C0      		ret	nz		; Message too big!
F480: CD96F4  	ns_rec1:call	ns_hcre
F483: D8      		ret	c		; Error!
F484: 77      		ld	(hl),a
F485: 23      		inc	hl
F486: 10F8    		djnz	ns_rec1
F488: B7      		or	a
F489: C9      		ret
              		
              	; Write a number of bytes to the HCCA port
              	; b = Bytes to write
              	; hl = Start of message
              	;
              	; Carry flag set on error
              	; uses: af, b, hl
F48A: 7E      	ns_send:ld	a,(hl)
F48B: 23      		inc	hl
F48C: CDE0F4  		call	ns_hcwr
F48F: D8      		ret	c		; Error!
F490: 10F8    		djnz	ns_send
F492: C9      		ret
              		
              	; Read from the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	;
              	; Returns result in a
              	; Carry flag set on error
              	; Uses: af
F493: CD96F4  	ns_hcrd:call	ns_hcre
F496: AF      	ns_hcre:xor	a
F497: 328EF5  		ld	(ns_inf),a
F49A: D5      		push	de
F49B: 3E09    		ld	a,0x09
F49D: D300    		out	(ns_nctl),a	; Turn on recv light
F49F: 11FFFF  		ld	de,0xFFFF
F4A2: 3A8EF5  	ns_hcr0:ld	a,(ns_inf)
F4A5: B7      		or	a
F4A6: 201D    		jr	nz,ns_hcr2
F4A8: DB40    		in	a,(ns_ayda)
              		;bit	0,a
              		;jr	z,ns_hcr0	; Await an interrupt
              		;bit	1,a
              		;jr	z,ns_hcr1
F4AA: E60F    		and	0x0F
F4AC: EE01    		xor	0b00000001
F4AE: 280C    		jr	z,ns_hcr1
F4B0: 1B      		dec	de
F4B1: 7B      		ld	a,e
F4B2: B2      		or	d
F4B3: 20ED    		jr	nz,ns_hcr0
F4B5: 3E01    	ns_hcer:ld	a,0x01
F4B7: D300    		out	(ns_nctl),a	; Turn off recv light
F4B9: 37      		scf
F4BA: D1      		pop	de
F4BB: C9      		ret			; Timed out waiting
F4BC: 3E01    	ns_hcr1:ld	a,0x01
F4BE: D300    		out	(ns_nctl),a	; Turn off recv light
F4C0: DB80    		in	a,(ns_hcca)
F4C2: D1      		pop	de
F4C3: B7      		or	a
F4C4: C9      		ret
F4C5: 3E01    	ns_hcr2:ld	a,0x01
F4C7: D300    		out	(ns_nctl),a	; Turn off recv light
F4C9: AF      		xor	a
F4CA: 328EF5  		ld	(ns_inf),a
F4CD: 3A8DF5  		ld	a,(ns_inb)
F4D0: D1      		pop	de
F4D1: C9      		ret
              		
              	; HCCA read interrupt
              	; Reads from the HCCA, buffers it, and then sets the flag
              	;
              	; uses: none
F4D2: F5      	ns_rirq:push	af
F4D3: DB80    		in	a,(ns_hcca)
F4D5: 328DF5  		ld	(ns_inb),a
F4D8: 3E01    		ld	a,1
F4DA: 328EF5  		ld	(ns_inf),a
F4DD: F1      		pop	af
F4DE: FB      		ei
F4DF: C9      		ret
              		
              		
              	; Write to the HCCA port
              	; Assumes AY is set to reg 15
              	; Will panic on timeout
              	; a = Character to write
              	;
              	; Carry flag set on error
              	; Uses: f
F4E0: D5      	ns_hcwr:push	de
F4E1: 328BF5  		ld	(ns_outb),a
F4E4: AF      		xor	a
F4E5: 328CF5  		ld	(ns_outf),a
F4E8: CDE6EF  		call	ns_esnd
F4EB: 11FFFF  		ld	de,0xFFFF
F4EE: 3E21    		ld	a,0x21
F4F0: D300    		out	(ns_nctl),a	; Turn on send light
F4F2: 3A8CF5  	ns_hcw0:ld	a,(ns_outf)
F4F5: B7      		or	a
F4F6: 2017    		jr	nz,ns_hcw2
F4F8: DB40    		in	a,(ns_ayda)
              		;bit	0,a
              		;jr	z,ns_hcw0	; Await an interrupt
              		;bit	1,a
              		;jr	nz,ns_hcw1
F4FA: E60F    		and	0x0F
F4FC: EE03    		xor	0b00000011
F4FE: 280A    		jr	z,ns_hcw1
F500: 1B      		dec	de
F501: 7B      		ld	a,e
F502: B2      		or	d
F503: 20ED    		jr	nz,ns_hcw0
F505: CDF0EF  		call	ns_dsnd
F508: 18AB    		jr	ns_hcer		; Timed out waiting
F50A: 3A8BF5  	ns_hcw1:ld	a,(ns_outb)
F50D: D380    		out	(ns_hcca),a
F50F: D1      	ns_hcw2:pop	de
F510: 3E01    		ld	a,0x01
F512: D300    		out	(ns_nctl),a	; Turn off send light
F514: CDF0EF  		call	ns_dsnd
F517: B7      		or	a
F518: C9      		ret
              		
              	; HCCA write interrupt
              	; Writes to the HCCA from the buffer, and 
F519: F5      	ns_wirq:push	af
F51A: 3A8BF5  		ld	a,(ns_outb)
F51D: D380    		out	(ns_hcca),a
F51F: 3E01    		ld	a,1
F521: 328CF5  		ld	(ns_outf),a
F524: CDF0EF  		call	ns_dsnd		; Y'all can't behave, turning off
F527: F1      		pop	af
F528: FB      		ei
F529: C9      		ret
              		
              		
              	; Takes a FCB-style name and formats it to standard notation
              	; a = Logical NHACP device
              	; de = Desintation for formatted name
              	; hl = Source FCB file name
              	;
              	; uses: all
F52A: CD62F5  	ns_form:call	ns_sdir
F52D: 3E2F    		ld	a,'/'
F52F: CD72F5  		call	ns_wchd
F532: 0608    		ld	b,8		; Look at all 8 possible name chars
F534: 7E      	ns_for1:ld	a,(hl)
F535: E67F    		and	0x7F
F537: CD80F5  		call	ns_utol
F53A: FE21    		cp	0x21
F53C: 3806    		jr	c,ns_for2
F53E: CD72F5  		call	ns_wchd
F541: 23      		inc	hl
F542: 10F0    		djnz	ns_for1
F544: 3E2E    	ns_for2:ld	a,0x2E		; '.'
F546: CD72F5  		call	ns_wchd
F549: 48      		ld	c,b
F54A: 0600    		ld	b,0
F54C: 09      		add	hl,bc		; Fast forward to extenstion
F54D: 0603    		ld	b,3		; Copy over extension
F54F: 7E      	ns_for3:ld	a,(hl)
F550: E67F    		and	0x7F
F552: CD80F5  		call	ns_utol
F555: FE21    		cp	0x21
F557: 3806    		jr	c,ns_for4
F559: CD72F5  		call	ns_wchd
F55C: 23      		inc	hl
F55D: 10F0    		djnz	ns_for3
F55F: AF      	ns_for4:xor	a		; Zero terminate
F560: 12      		ld	(de),a
F561: C9      		ret
              		
              	; Part of ns_form, but sometimes is called independently
              	; Sets the directory to access files from
              	; a = Logical NHACP device
              	; de = Desintation for formatted name
              	;
              	; uses: af, de
F562: C641    	ns_sdir:add	a,'A'
F564: CD72F5  		call	ns_wchd
F567: 3A41DF  		ld	a,(userno)
F56A: C630    		add	a,'0'
F56C: FE3A    		cp	':'
F56E: 3802    		jr	c,ns_wchd
F570: C607    		add	a,7
              		
              		; Fall to ns_wchd
              		
              	; Writes a byte to (de), then increments de
              	; a = Character to write
              	; de = Destination for character
              	;
              	; Returns de=de+1
              	; uses: af, de
F572: 12      	ns_wchd:ld	(de),a
F573: 13      		inc	de
F574: C9      		ret
              	
              	; Converts lowercase to uppercase
              	; a = Character to convert
              	;
              	; Returns uppercase in A
              	; uses: af
F575: E67F    	ns_ltou:and	0x7F
F577: FE61    		cp	0x61		; 'a'
F579: D8      		ret	c
F57A: FE7B    		cp	0x7B		; '{'
F57C: D0      		ret	nc
F57D: D620    		sub	0x20
F57F: C9      		ret
              		
              	; Converts uppercase to lowercase
              	; a = Character to convert
              	;
              	; Returns lowercase in A
              	; uses: af
F580: E67F    	ns_utol:and	0x7F
F582: FE41    		cp	0x41		; 'A'
F584: D8      		ret	c
F585: FE5B    		cp	0x5B		; '['
F587: D0      		ret	nc
F588: C620    		add	0x20
F58A: C9      		ret
              		
              	; Byte to send out of HCCA
F58B: 00      	ns_outb:defb	0
              	
              	; HCCA output flag
F58C: 00      	ns_outf:defb	0
              	
              	; Byte received from HCCA
F58D: 00      	ns_inb:	defb	0
              	
              	; HCCA input flag
F58E: 00      	ns_inf: defb	0
              		
              	; Path to CP/M image
              	; Total length: 13 bytes
F58F: 41302F43	ns_p0:	defb	'A0/CPM22.SYS',0
F593: 504D3232	
F597: 2E535953	
F59B: 00      	
              	
              	; Path to GRB image
              	; Total length: 13 bytes
F59C: 41302F46	ns_p1:	defb	'A0/FONT.GRB',0,0
F5A0: 4F4E542E	
F5A4: 47524200	
F5A8: 00      	
              	
              	; Message prototype to open a file
              	; Total length: 28 bytes
F5A9: 8F00    	ns_m0:	defb	0x8F,0x00
F5AB: 1800    		defw	24		; Message length
F5AD: 01      		defb	0x01		; Cmd: STORAGE-OPEN
F5AE: 81      		defb	ns_fild		; Default file descriptor
F5AF: 0000    	ns_m0fl:defw	0x0000		; Read/Write flags
F5B1: 13      		defb	19		; File name length
F5B2: 58585858	ns_m0na:defs	19,'X'		; File name field
F5B6: 58...   	
F5C5: 00      		defb	0x00		; Padding
              		
              	; Message prototype to close a file
              	; Total length: 6 bytes
F5C6: 8F00    	ns_m1:	defb	0x8F,0x00
F5C8: 0200    		defw	2		; Message length
F5CA: 05      		defb	0x05		; Cmd: FILE-CLOSE
F5CB: 81      		defb	ns_fild		; Default file descriptor
              		
              	; Message prototype to read a block
              	; Total length: 12 bytes
F5CC: 8F00    	ns_m2:	defb	0x8F,0x00
F5CE: 0800    		defw	8		; Message length
F5D0: 07      		defb	0x07		; Cmd: STORAGE-GET-BLOCK
F5D1: 81      		defb	ns_fild		; Default file descritor
F5D2: 00000000	ns_m2bn:defw	0x00,0x00	; Block number
F5D6: 8000    		defw	128		; Block length
              		
              	; Message prototype to write a block
              	; Total length: 12 bytes
F5D8: 8F00    	ns_m3:	defb	0x8F,0x00
F5DA: 8800    		defw	136		; Message length
F5DC: 08      		defb	0x08		; Cmd: STORAGE-PUT-BLOCK
F5DD: 81      		defb	ns_fild		; Default file descritor
F5DE: 00000000	ns_m3bn:defw	0x00,0x00	; Block number
F5E2: 8000    		defw	128		; Block length
              		
              	; Message prototype to start a list-dir
              	; Total length: 7 bytes
F5E4: 8F00    	ns_m4:	defb	0x8F,0x00
F5E6: 0300    		defw	3		; Message length
F5E8: 0E      		defb	0x0E		; Cmd: LIST-DIR
F5E9: 81      		defb	ns_fild		; Default file descriptor
F5EA: 00      		defb	0x00		; Null string
              		
              	; Message prototype to get the next dir entry
              	; Total length: 7 bytes
F5EB: 8F00    	ns_m5:	defb	0x8F,0x00
F5ED: 0300    		defw	3		; Message length
F5EF: 0F      		defb	0x0F		; Cmd: GET-DIR-ENTRY
F5F0: 81      		defb	ns_fild		; Default file descriptor
F5F1: 10      		defb	16		; Max length of file
              		
              	; Message prototype to remove a file
              	; Total length: 27 bytes
F5F2: 8F00    	ns_m6:	defb	0x8F,0x00
F5F4: 1700    		defw	23		; Message length
F5F6: 10      		defb	0x10		; Cmd: REMOVE
F5F7: 0000    		defw	0x0000		; Remove regular file
F5F9: 13      		defb	19		; File name length
F5FA: 58585858	ns_m6na:defs	19,'X'		; File name field
F5FE: 58...   	
              	
              	; Message prototype to rename a file
              	; Total length: 45 bytes
F60D: 8F00    	ns_m7:	defb	0x8F,0x00
F60F: 2900    		defw	41		; Message length
F611: 11      		defb	0x11		; Cmd: RENAME
F612: 13      		defb	19		; File name #1 length
F613: 58585858	ns_m7n0:defs	19,'X'		; File name #1 field
F617: 58...   	
F626: 13      		defb	19		; File name #2 length
F627: 58585858	ns_m7n1:defs	19,'X'		; File name #2 field
F62B: 58...   	
              	#include "../dev/nabu_prt.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   P A R A L L E L   O U T P U T
              	;*
              	;*      A simple output-only device driver for the NABU
              	;*      parellel printer port. 
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
0040:         	pr_ayda	equ	0x40		; AY-3-8910 data port
0041:         	pr_atla	equ	0x41		; AY-3-8910 latch port
00B0:         	pr_prnt	equ	0xB0		; Parallel output
0000:         	pr_ctrl	equ	0x00		; Device control register
              	
              	; Driver jump table 
F63A: B7      	prtdev:	or	a
F63B: 2808    		jr	z,pr_init
F63D: 3D      		dec	a
F63E: 2806    		jr	z,pr_stat
F640: 3D      		dec	a
F641: 2805    		jr	z,pr_read
F643: 1805    		jr	pr_writ
              		
              	; Device init
              	; Does nothing
              	;
              	; uses: none
F645: C9      	pr_init:ret
              	
              	; Device status 
              	; There are never any characters to read
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F646: AF      	pr_stat:xor	a
F647: C9      		ret
              		
              	; Waits for a character to come in and returns it
              	; No characters to read, returns 0
              	;
              	; Returns ASCII key in A
              	; uses: af
F648: AF      	pr_read:xor	a
F649: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	;
              	; uses: af, bc
F64A: 3E0F    	pr_writ:ld	a,0x0F
F64C: D341    		out	(pr_atla),a	; AY register = 15
              		
F64E: DB40    	pr_wri0:in	a,(pr_ayda)	; Wait for not busy
F650: E610    		and	0x10
F652: 20FA    		jr	nz,pr_wri0
              		
F654: 79      		ld	a,c
F655: D3B0    		out	(pr_prnt),a	; Write data
              		
F657: 3E05    		ld	a,0x05		; Strobe
F659: D300    		out	(pr_ctrl),a
              		
F65B: 0620    		ld	b,32		
F65D: 10FE    	pr_wri1:djnz	pr_wri1		; Wait a few cycles
              		
F65F: 3E01    		ld	a,0x01		; Strobe off
F661: D300    		out	(pr_ctrl),a
              		
F663: C9      		ret
              		
              	#include "../dev/nabu_sio.asm"
              	;
              	;**************************************************************
              	;*
              	;*        N A B U   S E R I A L   O P T I O N   C A R D
              	;*
              	;*      This driver allows the NABU serial option card to be
              	;*      used as a bidirectional Ishkur serial device. It will
              	;*      automatically search for a serial card on init. Serial
              	;*      cards are numbered by order. The first serial card gets
              	;*      a minor # of 0, the second card gets a minor number of
              	;*      1, etc... Up to 4 serial cards are supported.
              	;* 
              	;**************************************************************
              	;
              	.area	_TEXT
              	
              	
              	
              	; Driver jump table 
F664: B7      	siodev:	or	a
F665: 2808    		jr	z,so_init
F667: 3D      		dec	a
F668: 2833    		jr	z,so_stat
F66A: 3D      		dec	a
F66B: 2841    		jr	z,so_read
F66D: 1851    		jr	so_writ
              		
              	; Device init
              	; Tries to find the option card if it is installed
              	; hl = Device options
              	;
              	; uses: none
F66F: 11D4F6  	so_init:ld	de,so_atab
F672: 45      		ld	b,l
F673: 04      		inc	b		; Slot 1,2,3,...
F674: 19      		add	hl,de 		; Get address table entry
F675: 0ECF    		ld	c,0xCF		; First slot
              		
F677: ED78    	so_ini0:in	a,(c)
F679: FE08    		cp	0x08
F67B: 2807    		jr	z,so_ini2
              		
F67D: 3E10    	so_ini1:ld	a,0x10
F67F: 81      		add	c
F680: F0      		ret	p		; Can't find, failure
F681: 4F      		ld	c,a
F682: 18F3    		jr	so_ini0
              		
F684: 10F7    	so_ini2:djnz	so_ini1		; Repeat if looking for next card
F686: 79      		ld	a,c
F687: D60F    		sub	0x0F
F689: 4F      		ld	c,a
F68A: 71      		ld	(hl),c
F68B: 11D8F6  		ld	de,so_conf
F68E: 060D    		ld	b,13
              		
              		; Lets set up the serial card for 9600 8N1
              		; First we set up the 8253, then the 8251
F690: 1A      	so_ini3:ld	a,(de)
F691: 13      		inc	de
F692: 86      		add	a,(hl)
F693: 4F      		ld	c,a
F694: 1A      		ld	a,(de)
F695: 13      		inc	de
F696: ED79    		out	(c),a
F698: E5      		push	hl
F699: E1      		pop	hl	; Small delay
F69A: 10F4    		djnz	so_ini3
F69C: C9      		ret
              	
              	; Device status 
              	; hl = Device options
              	;
              	; Returns a=0xFF if there is a character to read
              	; uses: af
F69D: 11D4F6  	so_stat:ld	de,so_atab
F6A0: 19      		add	hl,de
F6A1: AF      		xor	a
F6A2: BE      		cp	(hl)
F6A3: C8      		ret	z	; No device, return 0
F6A4: 4E      		ld	c,(hl)
F6A5: 0C      		inc	c
F6A6: ED78    	so_sta0:in	a,(c)	; Check status register
F6A8: E602    		and	0x02
F6AA: C8      		ret	z
F6AB: 3EFF    		ld	a,0xFF
F6AD: C9      		ret
              		
              		
              	; Waits for a character to come in and returns it
              	; hl = Device options
              	;
              	; Returns ASCII key in A
              	; uses: af
F6AE: 11D4F6  	so_read:ld	de,so_atab
F6B1: 19      		add	hl,de
F6B2: AF      		xor	a
F6B3: BE      		cp	(hl)
F6B4: C8      		ret	z	; No device, return 0
F6B5: 4E      		ld	c,(hl)
F6B6: 0C      		inc	c
F6B7: CDA6F6  	so_rea0:call	so_sta0	; Wait for a character
F6BA: 28FB    		jr	z,so_rea0
F6BC: 0D      		dec	c
F6BD: ED78    		in	a,(c)
F6BF: C9      		ret
              		
              	; Writes a character to the device
              	; c = Character to write
              	; hl = Device options
              	;
              	; uses: af, bc
F6C0: 41      	so_writ:ld	b,c
F6C1: 11D4F6  		ld	de,so_atab
F6C4: 19      		add	hl,de
F6C5: AF      		xor	a
F6C6: BE      		cp	(hl)
F6C7: C8      		ret	z	; No device, return 0
F6C8: 4E      		ld	c,(hl)
F6C9: 0C      		inc	c
F6CA: ED78    	so_wri0:in	a,(c)
F6CC: E601    		and	0x01
F6CE: 28FA    		jr	z,so_wri0
F6D0: 0D      		dec	c
F6D1: ED41    		out	(c),b
F6D3: C9      		ret
              		
              		
              	; Variables
              	; 4 possible slots
F6D4: 00000000	so_atab:defb	0x00,0x00,0x00,0x00
              	
              	; Configuration string
              	; Sets up counters 1 and 2 on the 8523 timer
F6D8: 0737    	so_conf:defb	0x07,0x37	; Counter 1 setup
F6DA: 0412    		defb	0x04,0x12
F6DC: 0400    		defb	0x04,0x00
F6DE: 0777    		defb	0x07,0x77	; Counter 2 setup
F6E0: 0512    		defb	0x05,0x12
F6E2: 0500    		defb	0x05,0x00
              		
F6E4: 0100    		defb	0x01,0x00	; 8251 setup
F6E6: 0100    		defb	0x01,0x00
F6E8: 0100    		defb	0x01,0x00
F6EA: 0100    		defb	0x01,0x00
F6EC: 0140    		defb	0x01,0x40
F6EE: 014E    		defb	0x01,0x4E
F6F0: 0137    		defb	0x01,0x37
              	#include "../dev/nabu_fdc.asm"
              	;
              	;**************************************************************
              	;*
              	;*      N A B U   F D 1 7 9 7   F L O P P Y   D R I V E R
              	;*
              	;*      This driver interfaces the NABU FDC for use as a
              	;*      CP/M file system, graphical source, and boot device.
              	;*      The driver only supports double-density disks of 
              	;*      Osborne 1 format at the time, but this could be
              	;*      updated if it is needed. The directory table starts
              	;*      on track 2, the system sectors are as follows:
              	;*
              	;*      Track 0 Sector 1:	Boot Sector
              	;*      Track 0 Sector 2-3:	Graphical Resource Block
              	;*	Track 0 Sector 4-5:	CCP
              	;*	Track 1 Sector 1-5:	BDOS + BIOS Image
              	;*
              	;*	Device requires 90 bytes of bss space (nf_bss)
              	;*	Device requires 1024 byte buffer space (nf_cach)
              	;* 
              	;**************************************************************
              	;
              	; BSS Segment Variables
              	.area	_BSS
F9D7: 00      	nf_io:	defs	1	; FDC address
F9D8: 00      	nf_r2ks:defs	1	; Temp storaged used in nf_r2k
              	
F9D9: 00      	nf_curd:defs	1	; Currently selected disk
F9DA: 00      	nf_subs:defs	1	; Current subsector
F9DB: 00      	nf_sync:defs	1	; Set if disk needs to be rehomed
F9DC: 00      	nf_inco:defs	1	; Set if sector is in core already
F9DD: 00      	nf_dirt:defs	1	; Set if cache is dirty
              	
F9DE: 00000000	nf_cach:defs	1024	; Sector cache
F9E2: 00...   	
              	
              	.area	_NOINIT
              	
FDDE: 00000000	nf_asva:defs	26	; Misc CP/M buffer
FDE2: 00...   	
FDF8: 00000000	nf_asvb:defs	26
FDFC: 00...   	
FE12: 00000000	nf_csva:defs	15
FE16: 00...   	
FE21: 00000000	nf_csvb:defs	15
FE25: 00...   	
              	
              	.area	_TEXT
              	
0002:         	nf_rdsk	equ	2	; Defines which drives contains system
              				; resources (2 = A, 4 = B)
              				
0040:         	nf_ayda	equ	0x40	; AY-3-8910 data port
0041:         	nf_atla	equ	0x41	; AY-3-8910 latch port
              	
              	;
              	;**************************************************************
              	;*
              	;*         D I S K   D R I V E   G E O M E T R Y
              	;* 
              	;**************************************************************
              	;
              	
              	; Disk A DPH
F6F2:         	nf_dpha:
F6F2: 00000000		defw	0,0,0,0
F6F6: 00000000	
F6FA: 10FF    		defw	dircbuf	; DIRBUF
F6FC: 12F7    		defw	nf_dpb	; DPB
F6FE: 12FE    		defw	nf_csva	; CSV
F700: DEFD    		defw	nf_asva	; ALV
              	
              	; Disk B DPH
F702:         	nf_dphb:
F702: 00000000		defw	0,0,0,0
F706: 00000000	
F70A: 10FF    		defw	dircbuf	; DIRBUF
F70C: 12F7    		defw	nf_dpb	; DPB
F70E: 21FE    		defw	nf_csvb	; CSV
F710: F8FD    		defw	nf_asvb	; ALV
              	
              	; Osborne 1 format
F712:         	nf_dpb:
F712: 2800    		defw	40	; # sectors per track
F714: 03      		defb	3	; BSH
F715: 07      		defb	7	; BLM
F716: 00      		defb	0	; EXM
F717: B800    		defw	184	; DSM
F719: 3F00    		defw	63	; DRM
F71B: C0      		defb	0xC0	; AL0
F71C: 00      		defb	0	; AL1
F71D: 1000    		defw	16	; Size of directory check vector
F71F: 0300    		defw	3	; Number of reserved tracks at the beginning of disk
              	
              	
              	; Driver entry point
              	; a = Command #
              	;
              	; uses: all
F721: B7      	nfddev:	or	a
F722: 2815    		jr	z,nf_init
F724: 3D      		dec	a
F725: 283D    		jr	z,nf_home
F727: 3D      		dec	a
F728: 2852    		jr	z,nf_sel
F72A: 3D      		dec	a
F72B: CAD0F7  		jp	z,nf_strk
F72E: 3D      		dec	a
F72F: CA06F8  		jp	z,nf_ssec
F732: 3D      		dec	a
F733: CA57F8  		jp	z,nf_read
F736: C35FF8  		jp	nf_writ
              		
              	; Initialize device
              	; Sets the current track to 0
F739: AF      	nf_init:xor	a
F73A: 32D7F9  		ld	(nf_io),a
              	
              		; Look for the FDC
F73D: 0ECF    		ld	c,0xCF
F73F: ED78    	nf_ini1:in	a,(c)
F741: FE10    		cp	0x10
F743: 2808    		jr	z,nf_ini2
F745: 0C      		inc	c
F746: C8      		ret	z	; Should not be possible!
F747: 3E0F    		ld	a,0x0F
F749: 81      		add	a,c
F74A: 4F      		ld	c,a
F74B: 18F2    		jr	nf_ini1
              		
              		; Get command register
F74D: 79      	nf_ini2:ld	a,c
F74E: D60F    		sub	15
F750: 4F      		ld	c,a
F751: 32D7F9  		ld	(nf_io),a
              		
              		; Select drive defined by hl
F754: CB25    		sla	l
F756: 3E02    		ld	a,2
F758: 85      		add	l
F759: 32D9F9  		ld	(nf_curd),a
              		
              		; Force FDC interrupt
F75C: 3ED0    		ld	a,0xD0
F75E: ED79    		out	(c),a
              		
              		; Re-home drive
F760: CD64F7  		call	nf_home
              		
              		; De-select drive
              		
F763: C9      		ret
              	
              	; Sends the drive to track 0, and syncs the drive
              	;
              	; uses : af, c
F764: CD77F8  	nf_home:call	nf_wdef
F767: CD2AF9  		call	nf_dvsc
              	
F76A: 3AD7F9  		ld	a,(nf_io)
F76D: 4F      		ld	c,a
              		
              		; Restore to track 0
F76E: 3E09    		ld	a,0x09
F770: ED79    		out	(c),a 
F772: CD41F9  		call	nf_busy
              		
              		; Reset sync flag
F775: AF      		xor	a
F776: 32DBF9  		ld	(nf_sync),a
              		
              		; De-select drive
F779: C32FF9  		jp	nf_udsl
              		
              	; Selects the drive
              	; c = Logging status
              	; hl = Call argument
              	;
              	; uses; all
F77C: 3AD7F9  	nf_sel:	ld	a,(nf_io)
F77F: B7      		or	a
F780: FA87F7  		jp	m,nf_seld
              		
              		; no FDC card
F783: 210000  		ld	hl,0
F786: C9      		ret
              	
F787: 7D      	nf_seld:ld	a,l		; Select a disk
F788: 0602    		ld	b,2
F78A: B7      		or	a
F78B: 2809    		jr	z,nf_sel0
F78D: 3D      		dec	a
F78E: 0604    		ld	b,4
F790: 2804    		jr	z,nf_sel0
F792: 210000  		ld	hl,0
F795: C9      		ret
              	
              		; Move control of drive buffers
F796: CD77F8  	nf_sel0:call	nf_wdef		; Write back if needed
F799: 3EFF    		ld	a,0xFF
F79B: 32DBF9  		ld	(nf_sync),a	; Set sync flag
F79E: 78      		ld	a,b
F79F: 32D9F9  		ld	(nf_curd),a	; Set current drive
F7A2: 5F      		ld	e,a
              		
              		; Check to make sure there is a disk
F7A3: 16FF    	nf_selc	ld	d,255
F7A5: CD2AF9  		call	nf_dvsc
F7A8: 3AD7F9  		ld	a,(nf_io)
F7AB: 4F      		ld	c,a
F7AC: 3ED0    		ld	a,0xD0
F7AE: ED79    		out	(c),a		; Force FDC interrupt
F7B0: CD47F9  	nf_sel1:call	nf_stal
F7B3: ED78    		in	a,(c)
F7B5: E602    		and	0x02
F7B7: 2009    		jr	nz,nf_sel2
F7B9: 15      		dec	d
F7BA: 20F4    		jr	nz,nf_sel1
              		
              		; No disk!
F7BC: 210000  		ld	hl,0
F7BF: C32FF9  		jp	nf_udsl
              		
              		
              		; Output DPH
F7C2: CD2FF9  	nf_sel2:call	nf_udsl
F7C5: 21F2F6  		ld	hl,nf_dpha
F7C8: 3E02    		ld	a,2
F7CA: BB      		cp	e
F7CB: C8      		ret	z
F7CC: 2102F7  		ld	hl,nf_dphb
F7CF: C9      		ret
              	
              	; Sets the track of the selected block device
              	; bc = Track, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F7D0: 51      	nf_strk:ld	d,c		; Track = d
F7D1: 3AD7F9  		ld	a,(nf_io)
F7D4: 4F      		ld	c,a
F7D5: 3ADBF9  		ld	a,(nf_sync)
F7D8: B7      		or	a
F7D9: 280E    		jr	z,nf_str0	; Check if disk direct
              		
F7DB: CD2AF9  		call	nf_dvsc
              		
              		; Restore to track 0
F7DE: 3E09    		ld	a,0x09
F7E0: ED79    		out	(c),a 
F7E2: CD41F9  		call	nf_busy
              		
              		; Reset sync flag
F7E5: AF      		xor	a
F7E6: 32DBF9  		ld	(nf_sync),a
              		
              		; Check to see if tracks match
F7E9: 59      	nf_str0:ld	e,c
F7EA: 0C      		inc	c
F7EB: ED78    		in	a,(c)
F7ED: BA      		cp	d
F7EE: CA2FF9  		jp	z,nf_udsl	; They match, do nothing
              	
              		; Write a deferred block
F7F1: CD77F8  		call	nf_wdef
              	
              		; Seek to track
F7F4: CD2AF9  		call	nf_dvsc
F7F7: 0C      		inc	c
F7F8: 0C      		inc	c
F7F9: ED51    		out	(c),d
F7FB: 3E19    		ld	a,0x19
F7FD: 4B      		ld	c,e
F7FE: ED79    		out	(c),a 
F800: CD41F9  		call	nf_busy	
              		
F803: C32FF9  		jp	nf_udsl
              	
              	; Sets the sector of the selected block device
              	; bc = Sector, starts at 0
              	; hl = Call argument
              	;
              	; uses: all
F806: 79      	nf_ssec:ld	a,c
F807: E607    		and	0x07
F809: 32DAF9  		ld	(nf_subs),a
F80C: 79      		ld	a,c
              		
              		; Compute physical sector
F80D: CB3F    		srl	a
F80F: CB3F    		srl	a
F811: CB3F    		srl	a
F813: 3C      		inc	a
F814: 47      		ld	b,a	; b = Physical sector
F815: 3AD7F9  		ld	a,(nf_io)
F818: 3C      		inc	a
F819: 3C      		inc	a
F81A: 4F      		ld	c,a
F81B: ED78    		in	a,(c)
F81D: B8      		cp	b
F81E: C8      		ret	z	; Return if the same
              		
              		; Set FDC sector, after writing back if needed
F81F: CD77F8  		call	nf_wdef
F822: ED41    		out	(c),b
F824: C9      		ret
              		
              	; Ensure sector is in core, and set up for DMA transfer
              	;
              	; uses: all
F825: 3ADCF9  	nf_rdwr:ld	a,(nf_inco)
F828: B7      		or	a
F829: 2019    		jr	nz,nf_rdw0
              		
              		; Read in to cache
F82B: CD2AF9  		call	nf_dvsc
F82E: 3AD7F9  		ld	a,(nf_io)
F831: 4F      		ld	c,a
F832: 21DEF9  		ld	hl,nf_cach
F835: CD08F9  		call	nf_rphy
F838: 47      		ld	b,a
F839: CD2FF9  		call	nf_udsl
F83C: 78      		ld	a,b
              		
              		; Error checking
F83D: B7      		or	a
F83E: 3E01    		ld	a,1
F840: C0      		ret	nz
F841: 32DCF9  		ld	(nf_inco),a
              		
              		; DMA subsector
F844: 2A4DEB  	nf_rdw0:ld	hl,(biodma)
F847: EB      		ex	de,hl
              	
F848: 3ADAF9  		ld	a,(nf_subs)
F84B: 215EF9  		ld	hl,nf_cach-128
F84E: 018000  		ld	bc,128
F851: 3C      		inc	a
F852: 09      	nf_rdw1:add	hl,bc
F853: 3D      		dec	a
F854: 20FC    		jr	nz,nf_rdw1
F856: C9      		ret
              	
              	; Reads a sector and DMA transfers it to memory
F857: CD25F8  	nf_read:call	nf_rdwr
F85A: B7      		or	a
F85B: C0      		ret	nz
F85C: EDB0    		ldir
F85E: C9      		ret
              	
              	
              	; Write a sector from DMA, and defer it if possible
F85F: C5      	nf_writ:push	bc
F860: CD25F8  		call	nf_rdwr
F863: B7      		or	a
F864: C1      		pop	bc
F865: C0      		ret	nz
F866: 3E01    		ld	a,1
F868: 32DDF9  		ld	(nf_dirt),a
F86B: 79      		ld	a,c
F86C: 018000  		ld	bc,128
F86F: EB      		ex	de,hl
F870: EDB0    		ldir
F872: FE01    		cp	1
F874: 3E00    		ld	a,0
F876: C0      		ret	nz
              		
              		; Drop down to defer read
              	
              	
              	; Checks to see if the cache needs to be written back
              	; after a deferred write.
              	;
              	; uses, af
F877: 3ADDF9  	nf_wdef:ld	a,(nf_dirt)
F87A: B7      		or	a
F87B: 283D    		jr	z,nf_wde4
              	
F87D: C5      		push	bc
F87E: D5      		push	de
F87F: E5      		push	hl
              		
              		
              		; Write physical sector
F880: CD4CF9  		call	nf_dint
F883: CD2AF9  		call	nf_dvsc
F886: 3AD7F9  		ld	a,(nf_io)
F889: 4F      		ld	c,a
F88A: C603    		add	a,3
F88C: 57      		ld	d,a
F88D: 59      		ld	e,c
F88E: 3EA8    		ld	a,0xA8		; Write command
F890: ED79    		out	(c),a
F892: 21DEF9  		ld	hl,nf_cach
F895: ED78    	nf_wde1:in	a,(c)
F897: 1F      		rra	
F898: 3009    		jr	nc,nf_wde2
F89A: 1F      		rra
F89B: 30F8    		jr	nc,nf_wde1
F89D: 4A      		ld	c,d
F89E: EDA3    		outi 
F8A0: 4B      		ld	c,e
F8A1: 18F2    		jr	nf_wde1
F8A3: CD55F9  	nf_wde2:call	nf_eint
F8A6: ED78    		in	a,(c)
              		
              		; Deselect drive
F8A8: 47      		ld	b,a
F8A9: CD2FF9  		call	nf_udsl
F8AC: 78      		ld	a,b
              		
F8AD: E1      		pop	hl
F8AE: D1      		pop	de
F8AF: C1      		pop	bc
              		
              		; Error checking
F8B0: E6FC    		and	0xFC
F8B2: 2803    		jr	z,nf_wde3
              		
F8B4: 3E01    		ld	a,1
F8B6: C9      		ret
              		
              		; Cache is no longer dirty
F8B7: 32DDF9  	nf_wde3:ld	(nf_dirt),a
              		
              		; Data no longer in core
F8BA: AF      	nf_wde4:xor	a
F8BB: 32DCF9  		ld	(nf_inco),a
              		
F8BE: C9      		ret
              		
              	; Loads the GRB into memory from sector 2-3
F8BF: 3E02    	nf_grb:	ld	a,2
F8C1: 32D8F9  		ld	(nf_r2ks),a
F8C4: 1805    		jr	nf_r2k
              		
              	; Loads the CCP into memory from sectors 4-5
F8C6: 3E04    	nf_ccp:	ld	a,4
F8C8: 32D8F9  		ld	(nf_r2ks),a
              	
              	; Reads in a 2K bytes, starting at track 0, sector (nf_r2ks)
              	; This is placed into the cbase
F8CB: 3E02    	nf_r2k: ld	a,nf_rdsk
F8CD: CD30F9  		call	nf_dvsl
              		
              		; Restore to track 0
F8D0: 3AD7F9  		ld	a,(nf_io)
F8D3: 4F      		ld	c,a
F8D4: 3E09    		ld	a,0x09
F8D6: ED79    		out	(c),a 
F8D8: CD41F9  		call	nf_busy
              		
              		; Set sector # to 4
F8DB: 3AD8F9  		ld	a,(nf_r2ks)
F8DE: 0C      		inc	c
F8DF: 0C      		inc	c
F8E0: ED79    		out	(c),a
F8E2: C5      		push	bc
F8E3: 0D      		dec	c
F8E4: 0D      		dec	c
              		
              		; Read into memory
F8E5: 2100D4  		ld	hl,cbase
F8E8: CD08F9  		call	nf_rphy
F8EB: C1      		pop	bc
F8EC: B7      		or	a
F8ED: 2805    		jr	z,nf_r2k0
F8EF: CD39F7  		call	nf_init		; Error!
F8F2: 18D7    		jr	nf_r2k
              		
              		; Increment sector
F8F4: ED78    	nf_r2k0:in	a,(c)
F8F6: 3C      		inc	a
F8F7: ED79    		out	(c),a
F8F9: 0D      		dec	c
F8FA: 0D      		dec	c
              		
              		; Read into memory again
F8FB: CD08F9  		call	nf_rphy
F8FE: B7      		or	a
F8FF: C8      		ret	z
F900: CD39F7  		call	nf_init		; Error!
F903: 18C6    		jr	nf_r2k
              		
              		; De-select drive
F905: C32FF9  		jp	nf_udsl
              	
              	; Reads a physical sector
              	; Track and sector should be set up
              	; c = FDC command address
              	; hl = memory location of result
              	;
              	; Returns a=0 if successful
              	; uses: af, bc, de, hl
F908: CD4CF9  	nf_rphy:call	nf_dint
F90B: 51      		ld	d,c
F90C: 59      		ld	e,c
F90D: 14      		inc	d
F90E: 14      		inc	d
F90F: 14      		inc	d
              		
              		; Read command
F910: 3E88    		ld	a,0x88
F912: ED79    		out	(c),a
F914: ED78    	nf_rph1:in	a,(c)
F916: 1F      		rra	
F917: 3009    		jr	nc,nf_rph2
F919: 1F      		rra
F91A: 30F8    		jr	nc,nf_rph1
F91C: 4A      		ld	c,d
F91D: EDA2    		ini
F91F: 4B      		ld	c,e
F920: 18F2    		jr	nf_rph1
F922: CD55F9  	nf_rph2:call	nf_eint
F925: ED78    		in	a,(c)
F927: E6FC    		and	0xFC
F929: C9      		ret
              	
              	; Selects or deselects a drive
              	; a = Drive density / selection
              	;
              	; uses: af
F92A: 3AD9F9  	nf_dvsc:ld	a,(nf_curd)	; Select current drive
F92D: 1801    		jr	nf_dvsl
F92F: AF      	nf_udsl:xor	a		; Unselects a drive
F930: C5      	nf_dvsl:push	bc
F931: 47      		ld	b,a
F932: 3AD7F9  		ld	a,(nf_io)
F935: C60F    		add	a,0x0F
F937: 4F      		ld	c,a
F938: ED41    		out	(c),b
F93A: 06FF    		ld	b,0xFF
F93C: CD47F9  		call	nf_stal
F93F: C1      		pop	bc
F940: C9      		ret
              		
              	
              	; Waits until FDC is not busy
              	; c = FDC command address
              	;
              	; uses: af
F941: ED78    	nf_busy:in	a,(c)
F943: 1F      		rra
F944: 38FB    		jr	c,nf_busy
F946: C9      		ret
              		
              	; Waits a little bit
              	;
              	; uses: b
F947: C5      	nf_stal:push	bc
F948: C1      		pop	bc
F949: 10FC    		djnz	nf_stal
F94B: C9      		ret
              		
              	; Disables all interrupts while FDC operations occur
              	;
              	; uses: a
F94C: 3E0E    	nf_dint:ld	a,0x0E
F94E: D341    		out	(nf_atla),a	; AY register = 14
F950: 3E00    		ld	a,0x00
F952: D340    		out	(nf_ayda),a	
F954: C9      		ret
              		
              	; Enables interrupts again
              	;
              	; uses: a
F955: 3E0E    	nf_eint:ld	a,0x0E
F957: D341    		out	(nf_atla),a	; AY register = 14
F959: 3EB0    		ld	a,0xB0
F95B: D340    		out	(nf_ayda),a
F95D: C9      		ret


; +++ segments +++

#CODE _TEXT        = $D400 = 54272,  size = $255E =  9566
#DATA _BSS         = $F95E = 63838,  size = $0480 =  1152
#DATA _NOINIT      = $FDDE = 64990,  size = $0052 =    82
#DATA _JUMP_TABLE  = $FF00 = 65280,  size = $0090 =   144

; +++ global symbols +++

ADDAH            = $D75E = 55134  _TEXT       zcpr1_ccp_nfs.asm:1321
ADVAN            = $D751 = 55121  _TEXT       zcpr1_ccp_nfs.asm:1304
BDOS             = $0005 =     5  _TEXT       zcpr1_ccp_nfs.asm:13
BDOSB            = $D603 = 54787  _TEXT       zcpr1_ccp_nfs.asm:985
BDOSJP           = $D62F = 54831  _TEXT       zcpr1_ccp_nfs.asm:1040
BEL              = $0007 =     7  _TEXT       zcpr1_ccp_nfs.asm:475
BREAK            = $D706 = 55046  _TEXT       zcpr1_ccp_nfs.asm:1234
BRKBK            = $D70F = 55055  _TEXT       zcpr1_ccp_nfs.asm:1239 (unused)
BUFLEN           = $0050 =    80  _TEXT       zcpr1_ccp_nfs.asm:555
CALLPROG         = $DB36 = 56118  _TEXT       zcpr1_ccp_nfs.asm:2229
CB1              = $D6F5 = 55029  _TEXT       zcpr1_ccp_nfs.asm:1220
CB2              = $D6FD = 55037  _TEXT       zcpr1_ccp_nfs.asm:1226 (unused)
CBUFF            = $D404 = 54276  _TEXT       zcpr1_ccp_nfs.asm:558
CHRCNT           = $D4BA = 54458  _TEXT       zcpr1_ccp_nfs.asm:635
CIBPTR           = $D456 = 54358  _TEXT       zcpr1_ccp_nfs.asm:577
CIBUF            = $D43B = 54331  _TEXT       zcpr1_ccp_nfs.asm:571
CIBUFF           = $D405 = 54277  _TEXT       zcpr1_ccp_nfs.asm:561
CIPTR            = $D458 = 54360  _TEXT       zcpr1_ccp_nfs.asm:579
CLEVEL3          = $00FF =   255  _TEXT       zcpr1_ccp_nfs.asm:442
CLOSE            = $D645 = 54853  _TEXT       zcpr1_ccp_nfs.asm:1068
CMDSER           = $D887 = 55431  _TEXT       zcpr1_ccp_nfs.asm:1605
CMDTBL           = $D55F = 54623  _TEXT       zcpr1_ccp_nfs.asm:817
CMS1             = $D88C = 55436  _TEXT       zcpr1_ccp_nfs.asm:1616
CMS2             = $D891 = 55441  _TEXT       zcpr1_ccp_nfs.asm:1619
CMS3             = $D89F = 55455  _TEXT       zcpr1_ccp_nfs.asm:1630
CMS4             = $D8A2 = 55458  _TEXT       zcpr1_ccp_nfs.asm:1633
CNVBUF           = $D6F0 = 55024  _TEXT       zcpr1_ccp_nfs.asm:1216
COM              = $DAF7 = 56055  _TEXT       zcpr1_ccp_nfs.asm:2190
COM1             = $DB1B = 56091  _TEXT       zcpr1_ccp_nfs.asm:2211
COM4             = $DB64 = 56164  _TEXT       zcpr1_ccp_nfs.asm:2249
COM5             = $DB6D = 56173  _TEXT       zcpr1_ccp_nfs.asm:2259
COM6             = $DB73 = 56179  _TEXT       zcpr1_ccp_nfs.asm:2263
COM7             = $DB7B = 56187  _TEXT       zcpr1_ccp_nfs.asm:2274 (unused)
COMLOG           = $D7FE = 55294  _TEXT       zcpr1_ccp_nfs.asm:1472
COMMSG           = $D474 = 54388  _TEXT       zcpr1_ccp_nfs.asm:588
CONIN            = $D5B5 = 54709  _TEXT       zcpr1_ccp_nfs.asm:899
CONOUT           = $D5A8 = 54696  _TEXT       zcpr1_ccp_nfs.asm:886
CPR              = $D4C0 = 54464  _TEXT       zcpr1_ccp_nfs.asm:684
CPR1             = $D4BC = 54460  _TEXT       zcpr1_ccp_nfs.asm:669 (unused)
CPRDIR           = $00FF =   255  _TEXT       zcpr1_ccp_nfs.asm:356
CPRLST           = $00FF =   255  _TEXT       zcpr1_ccp_nfs.asm:355
CPRMPT           = $003E =    62  _TEXT       zcpr1_ccp_nfs.asm:462
CPRTYP           = $00FF =   255  _TEXT       zcpr1_ccp_nfs.asm:352
CR               = $000D =    13  _TEXT       zcpr1_ccp_nfs.asm:471
CRLF             = $D5A1 = 54689  _TEXT       zcpr1_ccp_nfs.asm:881
DEFDMA           = $D626 = 54822  _TEXT       zcpr1_ccp_nfs.asm:1032
DEFUSR           = $0000 =     0  _TEXT       zcpr1_ccp_nfs.asm:337
DELETE           = $D65F = 54879  _TEXT       zcpr1_ccp_nfs.asm:1092
DFU              = $DAE5 = 56037  _TEXT       zcpr1_ccp_nfs.asm:2143
DFUSR            = $DBB7 = 56247  _TEXT       zcpr1_ccp_nfs.asm:2369
DIR              = $D8A9 = 55465  _TEXT       zcpr1_ccp_nfs.asm:1655
DIR10            = $D946 = 55622  _TEXT       zcpr1_ccp_nfs.asm:1783
DIR11            = $D950 = 55632  _TEXT       zcpr1_ccp_nfs.asm:1788
DIR2             = $D8D8 = 55512  _TEXT       zcpr1_ccp_nfs.asm:1680
DIR2A            = $D8D9 = 55513  _TEXT       zcpr1_ccp_nfs.asm:1682 (unused)
DIR3             = $D8E7 = 55527  _TEXT       zcpr1_ccp_nfs.asm:1701
DIR4             = $D90A = 55562  _TEXT       zcpr1_ccp_nfs.asm:1736
DIR5             = $D912 = 55570  _TEXT       zcpr1_ccp_nfs.asm:1751
DIR6             = $D914 = 55572  _TEXT       zcpr1_ccp_nfs.asm:1753
DIR7             = $D92F = 55599  _TEXT       zcpr1_ccp_nfs.asm:1768
DIR8             = $D931 = 55601  _TEXT       zcpr1_ccp_nfs.asm:1770
DIR9             = $D945 = 55621  _TEXT       zcpr1_ccp_nfs.asm:1781
DIRPR            = $D8D9 = 55513  _TEXT       zcpr1_ccp_nfs.asm:1690
DIRPTR           = $D7E1 = 55265  _TEXT       zcpr1_ccp_nfs.asm:1445
DLOG5            = $D7FB = 55291  _TEXT       zcpr1_ccp_nfs.asm:1468
DLOGIN           = $D7F4 = 55284  _TEXT       zcpr1_ccp_nfs.asm:1463
DMASET           = $D629 = 54825  _TEXT       zcpr1_ccp_nfs.asm:1034
DRUSER           = $00FF =   255  _TEXT       zcpr1_ccp_nfs.asm:348
ENTRY            = $D400 = 54272  _TEXT       zcpr1_ccp_nfs.asm:516
EPRMPT           = $0000 =     0  _TEXT       zcpr1_ccp_nfs.asm:350
ERA              = $D95A = 55642  _TEXT       zcpr1_ccp_nfs.asm:1811
ERA1             = $D973 = 55667  _TEXT       zcpr1_ccp_nfs.asm:1823
ERARJ            = $D96D = 55661  _TEXT       zcpr1_ccp_nfs.asm:1820 (unused)
ERR1             = $D72A = 55082  _TEXT       zcpr1_ccp_nfs.asm:1272
ERR2             = $D71D = 55069  _TEXT       zcpr1_ccp_nfs.asm:1263
ERRLOG           = $DBFA = 56314  _TEXT       zcpr1_ccp_nfs.asm:2435
ERROR            = $D717 = 55063  _TEXT       zcpr1_ccp_nfs.asm:1260
EXECADR          = $DB89 = 56201  _TEXT       zcpr1_ccp_nfs.asm:2283
EXTEST           = $DA68 = 55912  _TEXT       zcpr1_ccp_nfs.asm:2042
FALSE            = $0000 =     0  _TEXT       zcpr1_ccp_nfs.asm:146
FCBCR            = $D4B8 = 54456  _TEXT       zcpr1_ccp_nfs.asm:628
FCBDM            = $D4A8 = 54440  _TEXT       zcpr1_ccp_nfs.asm:626
FCBDN            = $D498 = 54424  _TEXT       zcpr1_ccp_nfs.asm:617
FCBFN            = $D499 = 54425  _TEXT       zcpr1_ccp_nfs.asm:619
FCBFT            = $D4A1 = 54433  _TEXT       zcpr1_ccp_nfs.asm:621
FENCE            = $007C =   124  _TEXT       zcpr1_ccp_nfs.asm:449
FFEED            = $000C =    12  _TEXT       zcpr1_ccp_nfs.asm:474
FILLQ            = $D952 = 55634  _TEXT       zcpr1_ccp_nfs.asm:1794
FQLP             = $D954 = 55636  _TEXT       zcpr1_ccp_nfs.asm:1796
GET              = $DB97 = 56215  _TEXT       zcpr1_ccp_nfs.asm:2301
GETDRV           = $D622 = 54818  _TEXT       zcpr1_ccp_nfs.asm:1026
GETUSR           = $D668 = 54888  _TEXT       zcpr1_ccp_nfs.asm:1103
GO               = $DAF2 = 56050  _TEXT       zcpr1_ccp_nfs.asm:2179
GOTSYS           = $D8CC = 55500  _TEXT       zcpr1_ccp_nfs.asm:1672
GRBDOS           = $D640 = 54848  _TEXT       zcpr1_ccp_nfs.asm:1063
HEXNUM           = $D7A1 = 55201  _TEXT       zcpr1_ccp_nfs.asm:1391
HNUM0            = $D7A4 = 55204  _TEXT       zcpr1_ccp_nfs.asm:1393
HNUM1            = $D7AC = 55212  _TEXT       zcpr1_ccp_nfs.asm:1397
HNUM2            = $D7C3 = 55235  _TEXT       zcpr1_ccp_nfs.asm:1410
HNUM3            = $D7DE = 55262  _TEXT       zcpr1_ccp_nfs.asm:1438
INPASS           = $0000 =     0  _TEXT       zcpr1_ccp_nfs.asm:346
JUMP             = $DAED = 56045  _TEXT       zcpr1_ccp_nfs.asm:2159
LC1              = $D5DC = 54748  _TEXT       zcpr1_ccp_nfs.asm:941
LCOUT            = $D5D0 = 54736  _TEXT       zcpr1_ccp_nfs.asm:924
LF               = $000A =    10  _TEXT       zcpr1_ccp_nfs.asm:472
LIST             = $D981 = 55681  _TEXT       zcpr1_ccp_nfs.asm:1856
LOADADR          = $DBD5 = 56277  _TEXT       zcpr1_ccp_nfs.asm:2401
LOGIN            = $D632 = 54834  _TEXT       zcpr1_ccp_nfs.asm:1043
LSTOUT           = $D5D7 = 54743  _TEXT       zcpr1_ccp_nfs.asm:937 (unused)
LTAB             = $D9F0 = 55792  _TEXT       zcpr1_ccp_nfs.asm:1941
MAXDR            = $0001 =     1  _TEXT       zcpr1_ccp_nfs.asm:333 (unused)
MAXDRIV          = $0000 =     0  _TEXT       zcpr1_ccp_nfs.asm:330
MAXUSR           = $0013 =    19  _TEXT       zcpr1_ccp_nfs.asm:326
MBUFF            = $D403 = 54275  _TEXT       zcpr1_ccp_nfs.asm:556
MEMLOAD          = $DBA2 = 56226  _TEXT       zcpr1_ccp_nfs.asm:2318
ML2              = $DBD7 = 56279  _TEXT       zcpr1_ccp_nfs.asm:2403
ML3              = $DBF0 = 56304  _TEXT       zcpr1_ccp_nfs.asm:2418
ML4              = $DBF4 = 56308  _TEXT       zcpr1_ccp_nfs.asm:2425
MLA              = $DBAE = 56238  _TEXT       zcpr1_ccp_nfs.asm:2328
MLA0             = $DBC5 = 56261  _TEXT       zcpr1_ccp_nfs.asm:2384
MLA1             = $DBD4 = 56276  _TEXT       zcpr1_ccp_nfs.asm:2400
MLERR            = $DBF7 = 56311  _TEXT       zcpr1_ccp_nfs.asm:2429
NCHARS           = $0004 =     4  _TEXT       zcpr1_ccp_nfs.asm:812
NCMNDS           = $000B =    11  _TEXT       zcpr1_ccp_nfs.asm:871
NLINES           = $0018 =    24  _TEXT       zcpr1_ccp_nfs.asm:447
NOBOP            = $DA00 = 55808  _TEXT       zcpr1_ccp_nfs.asm:1953
NOECHO           = $D5C3 = 54723  _TEXT       zcpr1_ccp_nfs.asm:913
NOHYPH           = $D9D8 = 55768  _TEXT       zcpr1_ccp_nfs.asm:1926
NOLOG            = $D4DE = 54494  _TEXT       zcpr1_ccp_nfs.asm:711
NOSLAS           = $D99C = 55708  _TEXT       zcpr1_ccp_nfs.asm:1890
NRCMDS           = $0003 =     3  _TEXT       zcpr1_ccp_nfs.asm:839 (unused)
NUM0             = $D779 = 55161  _TEXT       zcpr1_ccp_nfs.asm:1351
NUM1             = $D77F = 55167  _TEXT       zcpr1_ccp_nfs.asm:1355
NUM2             = $D79C = 55196  _TEXT       zcpr1_ccp_nfs.asm:1379
NUMBASE          = $0048 =    72  _TEXT       zcpr1_ccp_nfs.asm:464
NUMBER           = $D763 = 55139  _TEXT       zcpr1_ccp_nfs.asm:1331
NUMERR           = $D79E = 55198  _TEXT       zcpr1_ccp_nfs.asm:1385
NUMS             = $D76B = 55147  _TEXT       zcpr1_ccp_nfs.asm:1338
NUMS1            = $D775 = 55157  _TEXT       zcpr1_ccp_nfs.asm:1345
OPEN             = $D63E = 54846  _TEXT       zcpr1_ccp_nfs.asm:1060
OPENF            = $D637 = 54839  _TEXT       zcpr1_ccp_nfs.asm:1055
OUTPUT           = $D5AB = 54699  _TEXT       zcpr1_ccp_nfs.asm:889
PAGCNT           = $D4B9 = 54457  _TEXT       zcpr1_ccp_nfs.asm:633
PGBAK            = $D5FC = 54780  _TEXT       zcpr1_ccp_nfs.asm:973
PGDFLG           = $0050 =    80  _TEXT       zcpr1_ccp_nfs.asm:452
PGDFLT           = $0000 =     0  _TEXT       zcpr1_ccp_nfs.asm:451
PGFLG            = $D5EF = 54767  _TEXT       zcpr1_ccp_nfs.asm:960
PRFLG            = $D5D2 = 54738  _TEXT       zcpr1_ccp_nfs.asm:929
PRIN1            = $D617 = 54807  _TEXT       zcpr1_ccp_nfs.asm:1011
PRINT            = $D60F = 54799  _TEXT       zcpr1_ccp_nfs.asm:1000
PRINTC           = $D60A = 54794  _TEXT       zcpr1_ccp_nfs.asm:995
PRNLE            = $DA5E = 55902  _TEXT       zcpr1_ccp_nfs.asm:2032
PRNNF            = $D554 = 54612  _TEXT       zcpr1_ccp_nfs.asm:804
PRT              = $D9FF = 55807  _TEXT       zcpr1_ccp_nfs.asm:1952
QMCNT            = $D4BB = 54459  _TEXT       zcpr1_ccp_nfs.asm:637
RAS              = $0000 =     0  _TEXT       zcpr1_ccp_nfs.asm:315
RB1              = $D6DA = 55002  _TEXT       zcpr1_ccp_nfs.asm:1195
RCPRNL           = $D543 = 54595  _TEXT       zcpr1_ccp_nfs.asm:793
READ             = $D601 = 54785  _TEXT       zcpr1_ccp_nfs.asm:980
READF            = $D5FE = 54782  _TEXT       zcpr1_ccp_nfs.asm:978
REDBUF           = $D683 = 54915  _TEXT       zcpr1_ccp_nfs.asm:1140
REDBUF0          = $D694 = 54932  _TEXT       zcpr1_ccp_nfs.asm:1148
REN              = $DA97 = 55959  _TEXT       zcpr1_ccp_nfs.asm:2073
REN0             = $DA9E = 55966  _TEXT       zcpr1_ccp_nfs.asm:2078 (unused)
REN1             = $DAB0 = 55984  _TEXT       zcpr1_ccp_nfs.asm:2086 (unused)
REN2             = $DAC7 = 56007  _TEXT       zcpr1_ccp_nfs.asm:2101
REN3             = $DAD5 = 56021  _TEXT       zcpr1_ccp_nfs.asm:2109 (unused)
REN4             = $DAD8 = 56024  _TEXT       zcpr1_ccp_nfs.asm:2111
RESET            = $D62D = 54829  _TEXT       zcpr1_ccp_nfs.asm:1038
RESETUSR         = $D663 = 54883  _TEXT       zcpr1_ccp_nfs.asm:1098
RESTRT           = $D4F2 = 54514  _TEXT       zcpr1_ccp_nfs.asm:727
RESTTMP          = $D731 = 55089  _TEXT       zcpr1_ccp_nfs.asm:1276
RNGSUB           = $D4E2 = 54498  _TEXT       zcpr1_ccp_nfs.asm:714
RS00             = $D510 = 54544  _TEXT       zcpr1_ccp_nfs.asm:750
RS000            = $D515 = 54549  _TEXT       zcpr1_ccp_nfs.asm:756 (unused)
RS1              = $D518 = 54552  _TEXT       zcpr1_ccp_nfs.asm:761
RSTCPR           = $D540 = 54592  _TEXT       zcpr1_ccp_nfs.asm:788
RSTJP            = $DAE2 = 56034  _TEXT       zcpr1_ccp_nfs.asm:2128
SAVE             = $DA12 = 55826  _TEXT       zcpr1_ccp_nfs.asm:1986
SAVE0            = $DA32 = 55858  _TEXT       zcpr1_ccp_nfs.asm:2004
SAVE1            = $DA39 = 55865  _TEXT       zcpr1_ccp_nfs.asm:2007
SAVE2            = $DA55 = 55893  _TEXT       zcpr1_ccp_nfs.asm:2024
SAVE3            = $DA65 = 55909  _TEXT       zcpr1_ccp_nfs.asm:2036
SBLANK           = $D755 = 55125  _TEXT       zcpr1_ccp_nfs.asm:1310
SCAN15           = $D845 = 55365  _TEXT       zcpr1_ccp_nfs.asm:1535
SCAN16           = $D848 = 55368  _TEXT       zcpr1_ccp_nfs.asm:1540
SCAN17           = $D84A = 55370  _TEXT       zcpr1_ccp_nfs.asm:1542
SCAN2            = $D824 = 55332  _TEXT       zcpr1_ccp_nfs.asm:1509
SCAN3            = $D82A = 55338  _TEXT       zcpr1_ccp_nfs.asm:1513
SCAN4            = $D830 = 55344  _TEXT       zcpr1_ccp_nfs.asm:1521
SCANER           = $D808 = 55304  _TEXT       zcpr1_ccp_nfs.asm:1492
SCANF            = $D858 = 55384  _TEXT       zcpr1_ccp_nfs.asm:1561
SCANF1           = $D869 = 55401  _TEXT       zcpr1_ccp_nfs.asm:1570
SCANF2           = $D870 = 55408  _TEXT       zcpr1_ccp_nfs.asm:1575
SCANF3           = $D872 = 55410  _TEXT       zcpr1_ccp_nfs.asm:1577
SCANF4           = $D879 = 55417  _TEXT       zcpr1_ccp_nfs.asm:1585
SCANX            = $D80B = 55307  _TEXT       zcpr1_ccp_nfs.asm:1494
SCQ              = $D87F = 55423  _TEXT       zcpr1_ccp_nfs.asm:1595
SDELM            = $D734 = 55092  _TEXT       zcpr1_ccp_nfs.asm:1280
SEAR1            = $D64C = 54860  _TEXT       zcpr1_ccp_nfs.asm:1074
SEARF            = $D649 = 54857  _TEXT       zcpr1_ccp_nfs.asm:1072
SEARN            = $D650 = 54864  _TEXT       zcpr1_ccp_nfs.asm:1078
SECTFLG          = $0053 =    83  _TEXT       zcpr1_ccp_nfs.asm:467
SECURE           = $0000 =     0  _TEXT       zcpr1_ccp_nfs.asm:335
SETTSE           = $DBBC = 56252  _TEXT       zcpr1_ccp_nfs.asm:2376
SETU0D           = $D67D = 54909  _TEXT       zcpr1_ccp_nfs.asm:1130
SETUD            = $D66E = 54894  _TEXT       zcpr1_ccp_nfs.asm:1117
SETUSR           = $D66A = 54890  _TEXT       zcpr1_ccp_nfs.asm:1105
SLOGIN           = $D7EA = 55274  _TEXT       zcpr1_ccp_nfs.asm:1454
SOFLG            = $0053 =    83  _TEXT       zcpr1_ccp_nfs.asm:457
SPRMPT           = $0024 =    36  _TEXT       zcpr1_ccp_nfs.asm:461
STACK            = $D474 = 54388  _TEXT       zcpr1_ccp_nfs.asm:584
SUBA             = $00FF =   255  _TEXT       zcpr1_ccp_nfs.asm:421
SUBFCB           = $D477 = 54391  _TEXT       zcpr1_ccp_nfs.asm:593
SUBFCR           = $D497 = 54423  _TEXT       zcpr1_ccp_nfs.asm:613
SUBFRC           = $D486 = 54406  _TEXT       zcpr1_ccp_nfs.asm:610
SUBFS2           = $D485 = 54405  _TEXT       zcpr1_ccp_nfs.asm:608 (unused)
SUBKIL           = $D654 = 54868  _TEXT       zcpr1_ccp_nfs.asm:1084
SUPRES           = $0000 =     0  _TEXT       zcpr1_ccp_nfs.asm:459
SUSER            = $DADF = 56031  _TEXT       zcpr1_ccp_nfs.asm:2126
SYSFLG           = $0041 =    65  _TEXT       zcpr1_ccp_nfs.asm:455
SYSTST           = $D8F9 = 55545  _TEXT       zcpr1_ccp_nfs.asm:1714
TAB              = $0009 =     9  _TEXT       zcpr1_ccp_nfs.asm:473
TBUFF            = $0080 =   128  _TEXT       zcpr1_ccp_nfs.asm:16
TDRIVE           = $D67E = 54910  _TEXT       zcpr1_ccp_nfs.asm:1131
TEMPDR           = $D7FF = 55295  _TEXT       zcpr1_ccp_nfs.asm:1473
TFCB             = $005C =    92  _TEXT       zcpr1_ccp_nfs.asm:15
TMPUSR           = $D664 = 54884  _TEXT       zcpr1_ccp_nfs.asm:1099
TPA              = $0100 =   256  _TEXT       zcpr1_ccp_nfs.asm:484
TRUE             = $00FF =   255  _TEXT       zcpr1_ccp_nfs.asm:147
TSELUSR          = $DBB9 = 56249  _TEXT       zcpr1_ccp_nfs.asm:2371
TWOCOL           = $0000 =     0  _TEXT       zcpr1_ccp_nfs.asm:377
TWOPOK           = $D901 = 55553  _TEXT       zcpr1_ccp_nfs.asm:1728 (unused)
TYPE             = $D985 = 55685  _TEXT       zcpr1_ccp_nfs.asm:1869
TYPE0            = $D986 = 55686  _TEXT       zcpr1_ccp_nfs.asm:1877
TYPE1            = $D9B4 = 55732  _TEXT       zcpr1_ccp_nfs.asm:1900
TYPE2            = $D9C5 = 55749  _TEXT       zcpr1_ccp_nfs.asm:1911
TYPE2L           = $DA03 = 55811  _TEXT       zcpr1_ccp_nfs.asm:1958
TYPE3            = $DA0D = 55821  _TEXT       zcpr1_ccp_nfs.asm:1964
TYPE4            = $DA0F = 55823  _TEXT       zcpr1_ccp_nfs.asm:1967
UCASE            = $D5BA = 54714  _TEXT       zcpr1_ccp_nfs.asm:905
UDFLAG           = $0004 =     4  _TEXT       zcpr1_ccp_nfs.asm:11
USER             = $DADB = 56027  _TEXT       zcpr1_ccp_nfs.asm:2123
USRMAX           = $0000 =     0  _TEXT       zcpr1_ccp_nfs.asm:319
USRNUM           = $D711 = 55057  _TEXT       zcpr1_ccp_nfs.asm:1245
WIDE             = $00FF =   255  _TEXT       zcpr1_ccp_nfs.asm:448
WSTYPE           = $00FF =   255  _TEXT       zcpr1_ccp_nfs.asm:353
YESCR            = $D9FD = 55805  _TEXT       zcpr1_ccp_nfs.asm:1950
_BSS             = $F95E = 63838  _BSS        config_nfs_hybrid.asm:44 (unused)
_BSS_end         = $FDDE = 64990  _BSS        config_nfs_hybrid.asm:44
_BSS_size        = $0480 =  1152  _BSS        config_nfs_hybrid.asm:44
_JUMP_TABLE      = $FF00 = 65280  _JUMP_TABLE config_nfs_hybrid.asm:46 (unused)
_JUMP_TABLE_end  = $FF90 = 65424  _JUMP_TABLE config_nfs_hybrid.asm:46 (unused)
_JUMP_TABLE_size = $0090 =   144  _JUMP_TABLE config_nfs_hybrid.asm:46 (unused)
_NOINIT          = $FDDE = 64990  _NOINIT     config_nfs_hybrid.asm:45 (unused)
_NOINIT_end      = $FE30 = 65072  _NOINIT     config_nfs_hybrid.asm:45 (unused)
_NOINIT_size     = $0052 =    82  _NOINIT     config_nfs_hybrid.asm:45 (unused)
_TEXT            = $D400 = 54272  _TEXT       config_nfs_hybrid.asm:43 (unused)
_TEXT_end        = $F95E = 63838  _TEXT       config_nfs_hybrid.asm:43
_TEXT_size       = $255E =  9566  _TEXT       config_nfs_hybrid.asm:43 (unused)
active           = $DF42 = 57154  _TEXT       bdos.asm:489
adda2hl          = $E164 = 57700  _TEXT       bdos.asm:918
alloc0           = $E9CA = 59850  _TEXT       bdos.asm:2466
alloc1           = $E9CC = 59852  _TEXT       bdos.asm:2467
alocvect         = $E9BF = 59839  _TEXT       bdos.asm:2456
auto             = $E9DE = 59870  _TEXT       bdos.asm:2481
autoflag         = $E9E0 = 59872  _TEXT       bdos.asm:2483
autosel          = $E851 = 59473  _TEXT       bdos.asm:2196
autosl1          = $E875 = 59509  _TEXT       bdos.asm:2212
backup           = $DDA4 = 56740  _TEXT       bdos.asm:249
backup1          = $DDAC = 56748  _TEXT       bdos.asm:252
badsctr          = $DC09 = 56329  _TEXT       bdos.asm:33
badsec           = $DCCA = 56522  _TEXT       bdos.asm:104
badsel           = $DCD5 = 56533  _TEXT       bdos.asm:105
badslct          = $DC0B = 56331  _TEXT       bdos.asm:34
batch            = $D4E2 = 54498  _TEXT       zcpr1_ccp_nfs.asm:713
bdevsw           = $EB70 = 60272  _TEXT       config_nfs_hybrid.asm:162
bdosdrv          = $DCC6 = 56518  _TEXT       bdos.asm:103
bdoserr          = $DCBA = 56506  _TEXT       bdos.asm:102
bigdisk          = $E9DD = 59869  _TEXT       bdos.asm:2480
biodma           = $EB4D = 60237  _TEXT       bios.asm:337
bitmap           = $E2A3 = 58019  _TEXT       bdos.asm:1211
bitmap1          = $E2B1 = 58033  _TEXT       bdos.asm:1226
bitmap2          = $E2D2 = 58066  _TEXT       bdos.asm:1247
bitmap3          = $E2F6 = 58102  _TEXT       bdos.asm:1264
blkmask          = $E9C4 = 59844  _TEXT       bdos.asm:2462
blknmbr          = $E9E5 = 59877  _TEXT       bdos.asm:2487
blkshft          = $E9C3 = 59843  _TEXT       bdos.asm:2461
boot             = $EA33 = 59955  _TEXT       bios.asm:42
bs               = $0008 =     8  _TEXT       zcpr1_ccp_nfs.asm:24
bshook           = $EB18 = 60184  _TEXT       bios.asm:288
callbd           = $EAF6 = 60150  _TEXT       bios.asm:230
callmj           = $EB4A = 60234  _TEXT       bios.asm:331
cbase            = $D400 = 54272  _TEXT       zcpr1_ccp_nfs.asm:515
cbinit           = $EB5E = 60254  _TEXT       config_nfs_hybrid.asm:93
cdevsw           = $EBB0 = 60336  _TEXT       config_nfs_hybrid.asm:201
cdindi0          = $EB22 = 60194  _TEXT       bios.asm:296
cdindi1          = $EB28 = 60200  _TEXT       bios.asm:300
cdindir          = $EB1E = 60190  _TEXT       bios.asm:294
cfirq            = $EB64 = 60260  _TEXT       config_nfs_hybrid.asm:109 (unused)
charbuf          = $DF0E = 57102  _TEXT       bdos.asm:478
checkdir         = $E19E = 57758  _TEXT       bdos.asm:991
checksum         = $E0F7 = 57591  _TEXT       bdos.asm:830
chgnam1          = $E427 = 58407  _TEXT       bdos.asm:1503
chgnames         = $E416 = 58390  _TEXT       bdos.asm:1495
chkblk           = $E084 = 57476  _TEXT       bdos.asm:737
chkchar          = $DD14 = 56596  _TEXT       bdos.asm:146
chkdir1          = $E1C4 = 57796  _TEXT       bdos.asm:1011
chknmbr          = $E18C = 57740  _TEXT       bdos.asm:964
chkrofl          = $E144 = 57668  _TEXT       bdos.asm:894
chksum1          = $E0FD = 57597  _TEXT       bdos.asm:833
chkvect          = $E9BD = 59837  _TEXT       bdos.asm:2455
chkwprt          = $E154 = 57684  _TEXT       bdos.asm:905
chrout           = $EAB9 = 60089  _TEXT       bios.asm:171
ckbitmap         = $E235 = 57909  _TEXT       bdos.asm:1105
ckbmap1          = $E256 = 57942  _TEXT       bdos.asm:1140
ckcon1           = $DD42 = 56642  _TEXT       bdos.asm:176
ckcon2           = $DD45 = 56645  _TEXT       bdos.asm:177
ckconsol         = $DD23 = 56611  _TEXT       bdos.asm:162
ckfilpos         = $E1F5 = 57845  _TEXT       bdos.asm:1054
ckrof1           = $E147 = 57671  _TEXT       bdos.asm:895
cksumtbl         = $E9EC = 59884  _TEXT       bdos.asm:2495
clears2          = $E172 = 57714  _TEXT       bdos.asm:935
closefil         = $E8A5 = 59557  _TEXT       bdos.asm:2243
closeflg         = $E9D2 = 59858  _TEXT       bdos.asm:2472
closeit          = $E4A2 = 58530  _TEXT       bdos.asm:1589
closeit1         = $E4CD = 58573  _TEXT       bdos.asm:1609
closeit2         = $E4DB = 58587  _TEXT       bdos.asm:1617
closeit3         = $E4E1 = 58593  _TEXT       bdos.asm:1621
closeit4         = $E4E8 = 58600  _TEXT       bdos.asm:1624
closeit5         = $E4FD = 58621  _TEXT       bdos.asm:1637
closeit6         = $E517 = 58647  _TEXT       bdos.asm:1655
closeit7         = $E51F = 58655  _TEXT       bdos.asm:1658
cntrlc           = $0003 =     3  _TEXT       zcpr1_ccp_nfs.asm:22
cntrle           = $0005 =     5  _TEXT       zcpr1_ccp_nfs.asm:23
cntrlp           = $0010 =    16  _TEXT       zcpr1_ccp_nfs.asm:29
cntrlr           = $0012 =    18  _TEXT       zcpr1_ccp_nfs.asm:30
cntrls           = $0013 =    19  _TEXT       zcpr1_ccp_nfs.asm:31
cntrlu           = $0015 =    21  _TEXT       zcpr1_ccp_nfs.asm:32
cntrlx           = $0018 =    24  _TEXT       zcpr1_ccp_nfs.asm:33
cntrlz           = $001A =    26  _TEXT       zcpr1_ccp_nfs.asm:34 (unused)
comblk           = $E077 = 57463  _TEXT       bdos.asm:728
comprand         = $E7A5 = 59301  _TEXT       bdos.asm:2062
conin            = $EAAB = 60075  _TEXT       bios.asm:158
conout           = $EAB7 = 60087  _TEXT       bios.asm:170
const            = $EAA0 = 60064  _TEXT       bios.asm:146
counter          = $E9D8 = 59864  _TEXT       bdos.asm:2478
cpmlow           = $EA98 = 60056  _TEXT       bios.asm:135
cr               = $000D =    13  _TEXT       zcpr1_ccp_nfs.asm:28
curpos           = $DF0C = 57100  _TEXT       bdos.asm:476
de2hl            = $DF4F = 57167  _TEXT       bdos.asm:507
de2hl1           = $DF50 = 57168  _TEXT       bdos.asm:508
default          = $0000 =     0              config_nfs_hybrid.asm:19
defdma           = $E1DA = 57818  _TEXT       bdos.asm:1029
del              = $007F =   127  _TEXT       zcpr1_ccp_nfs.asm:35
delfile          = $E8D7 = 59607  _TEXT       bdos.asm:2274
dirbuf           = $E9B9 = 59833  _TEXT       bdos.asm:2453
dirc1            = $DEE0 = 57056  _TEXT       bdos.asm:434
dircbuf          = $FF10 = 65296  _JUMP_TABLE config_nfs_hybrid.asm:48
dircio           = $DED4 = 57044  _TEXT       bdos.asm:428
dirdma           = $E1E0 = 57824  _TEXT       bdos.asm:1034
dirdma1          = $E1E3 = 57827  _TEXT       bdos.asm:1039
dirread          = $E1D4 = 57812  _TEXT       bdos.asm:1024
dirsize          = $E9C8 = 59848  _TEXT       bdos.asm:2465
dirwrite         = $E1C6 = 57798  _TEXT       bdos.asm:1016
diskpb           = $E9BB = 59835  _TEXT       bdos.asm:2454
diskro           = $DCE1 = 56545  _TEXT       bdos.asm:107
doread           = $DFB2 = 57266  _TEXT       bdos.asm:578
dowrite          = $DFB8 = 57272  _TEXT       bdos.asm:583
dsksize          = $E9C6 = 59846  _TEXT       bdos.asm:2464
eboot            = $EA41 = 59969  _TEXT       bios.asm:57
emptyfcb         = $E9AC = 59820  _TEXT       bdos.asm:2440
entry            = $0005 =     5  _TEXT       zcpr1_ccp_nfs.asm:12 (unused)
eparam           = $E9D6 = 59862  _TEXT       bdos.asm:2476
erafil1          = $E3A4 = 58276  _TEXT       bdos.asm:1381
erafile          = $E39C = 58268  _TEXT       bdos.asm:1378
error1           = $DC99 = 56473  _TEXT       bdos.asm:85
error2           = $DCA5 = 56485  _TEXT       bdos.asm:91
error3           = $DCAB = 56491  _TEXT       bdos.asm:94
error4           = $DCB1 = 56497  _TEXT       bdos.asm:97
error5           = $DCB4 = 56500  _TEXT       bdos.asm:99
extblk           = $E05E = 57438  _TEXT       bdos.asm:709
extblk1          = $E071 = 57457  _TEXT       bdos.asm:719
extmask          = $E9C5 = 59845  _TEXT       bdos.asm:2463
fbase            = $DC06 = 56326  _TEXT       bdos.asm:29
fbase1           = $DC11 = 56337  _TEXT       bdos.asm:41
fcb2hl           = $E15E = 57694  _TEXT       bdos.asm:913
fcbpos           = $E9E9 = 59881  _TEXT       bdos.asm:2489
fcbset           = $E3FD = 58365  _TEXT       bdos.asm:1473
fcreate          = $E8EC = 59628  _TEXT       bdos.asm:2291
ff               = $000C =    12  _TEXT       zcpr1_ccp_nfs.asm:27 (unused)
filepos          = $E9EA = 59882  _TEXT       bdos.asm:2490
filero           = $DCDC = 56540  _TEXT       bdos.asm:106
filesize         = $E94D = 59725  _TEXT       bdos.asm:2365
findfst          = $E318 = 58136  _TEXT       bdos.asm:1298
findnxt          = $E32D = 58157  _TEXT       bdos.asm:1311
fndnxt1          = $E34A = 58186  _TEXT       bdos.asm:1324
fndnxt2          = $E353 = 58195  _TEXT       bdos.asm:1328
fndnxt3          = $E373 = 58227  _TEXT       bdos.asm:1344
fndnxt4          = $E37C = 58236  _TEXT       bdos.asm:1353
fndnxt5          = $E383 = 58243  _TEXT       bdos.asm:1358
fndnxt6          = $E394 = 58260  _TEXT       bdos.asm:1371
fndspa1          = $E3C0 = 58304  _TEXT       bdos.asm:1411
fndspa2          = $E3D1 = 58321  _TEXT       bdos.asm:1434
fndspa3          = $E3EC = 58348  _TEXT       bdos.asm:1455
fndspa4          = $E3F4 = 58356  _TEXT       bdos.asm:1465
fndspace         = $E3BE = 58302  _TEXT       bdos.asm:1405
fndstat          = $E9D4 = 59860  _TEXT       bdos.asm:2474
functns          = $DC47 = 56391  _TEXT       bdos.asm:76
getaloc          = $E911 = 59665  _TEXT       bdos.asm:2319
getblk1          = $E045 = 57413  _TEXT       bdos.asm:687
getblk2          = $E053 = 57427  _TEXT       bdos.asm:696
getblk3          = $E05C = 57436  _TEXT       bdos.asm:701
getblock         = $E03E = 57406  _TEXT       bdos.asm:684
getchar          = $DCFB = 56571  _TEXT       bdos.asm:124
getcon           = $DEC8 = 57032  _TEXT       bdos.asm:416
getcrnt          = $E904 = 59652  _TEXT       bdos.asm:2308
getcsts          = $DEFE = 57086  _TEXT       bdos.asm:461
getecho          = $DD06 = 56582  _TEXT       bdos.asm:133
getempty         = $E524 = 58660  _TEXT       bdos.asm:1665
getfst           = $E8AB = 59563  _TEXT       bdos.asm:2250
getfst1          = $E8C2 = 59586  _TEXT       bdos.asm:2261
getiob           = $DEED = 57069  _TEXT       bdos.asm:442
getlog           = $E8FE = 59646  _TEXT       bdos.asm:2303
getmt1           = $E546 = 58694  _TEXT       bdos.asm:1681
getnext          = $E55A = 58714  _TEXT       bdos.asm:1695
getnxt           = $E8C8 = 59592  _TEXT       bdos.asm:2266
getparm          = $E926 = 59686  _TEXT       bdos.asm:2336
getprm1          = $E929 = 59689  _TEXT       bdos.asm:2337
getrdr           = $DECE = 57038  _TEXT       bdos.asm:421
getrov           = $E917 = 59671  _TEXT       bdos.asm:2324
gets2            = $E169 = 57705  _TEXT       bdos.asm:927
getuser          = $E92D = 59693  _TEXT       bdos.asm:2344
getver           = $E87E = 59518  _TEXT       bdos.asm:2220
getwprt          = $E11E = 57630  _TEXT       bdos.asm:867
goback           = $E974 = 59764  _TEXT       bdos.asm:2400
goback1          = $E991 = 59793  _TEXT       bdos.asm:2412
gtnext1          = $E583 = 58755  _TEXT       bdos.asm:1715
gtnext2          = $E58E = 58766  _TEXT       bdos.asm:1724
gtnext3          = $E5AC = 58796  _TEXT       bdos.asm:1735
gtnext4          = $E5AF = 58799  _TEXT       bdos.asm:1736
gtnext5          = $E5B6 = 58806  _TEXT       bdos.asm:1743
home             = $EAD9 = 60121  _TEXT       bios.asm:204
homedrv          = $DFA1 = 57249  _TEXT       bdos.asm:564
inbuff           = $D403 = 54275  _TEXT       zcpr1_ccp_nfs.asm:554
intvec           = $FF00 = 65280  _JUMP_TABLE config_nfs_hybrid.asm:47
iobyte           = $0003 =     3  _TEXT       zcpr1_ccp_nfs.asm:9
ioerr1           = $DF05 = 57093  _TEXT       bdos.asm:471
ioret            = $DFBB = 57275  _TEXT       bdos.asm:584
jumphl           = $DF4A = 57162  _TEXT       bdos.asm:499
lf               = $000A =    10  _TEXT       zcpr1_ccp_nfs.asm:26
list             = $EAC3 = 60099  _TEXT       bios.asm:181
logical          = $E08A = 57482  _TEXT       bdos.asm:748
logicl1          = $E090 = 57488  _TEXT       bdos.asm:750
login            = $E9AF = 59823  _TEXT       bdos.asm:2442
logindrv         = $E821 = 59425  _TEXT       bdos.asm:2164
logoff           = $E953 = 59731  _TEXT       bdos.asm:2374
logsect          = $E9E7 = 59879  _TEXT       bdos.asm:2488
mem              = $0035 =    53              config_nfs_hybrid.asm:38
mode             = $E9D5 = 59861  _TEXT       bdos.asm:2475
morefls          = $E17F = 57727  _TEXT       bdos.asm:951
movedir          = $E1E9 = 57833  _TEXT       bdos.asm:1046
moveword         = $E494 = 58516  _TEXT       bdos.asm:1572
newline          = $DDB1 = 56753  _TEXT       bdos.asm:258
newln1           = $DDB9 = 56761  _TEXT       bdos.asm:261
nf_asva          = $FDDE = 64990  _NOINIT     nabu_fdc.asm:38
nf_asvb          = $FDF8 = 65016  _NOINIT     nabu_fdc.asm:39
nf_atla          = $0041 =    65  _TEXT       nabu_fdc.asm:49
nf_ayda          = $0040 =    64  _TEXT       nabu_fdc.asm:48
nf_busy          = $F941 = 63809  _TEXT       nabu_fdc.asm:535
nf_cach          = $F9DE = 63966  _BSS        nabu_fdc.asm:34
nf_ccp           = $F8C6 = 63686  _TEXT       nabu_fdc.asm:431 (unused)
nf_csva          = $FE12 = 65042  _NOINIT     nabu_fdc.asm:40
nf_csvb          = $FE21 = 65057  _NOINIT     nabu_fdc.asm:41
nf_curd          = $F9D9 = 63961  _BSS        nabu_fdc.asm:28
nf_dint          = $F94C = 63820  _TEXT       nabu_fdc.asm:551
nf_dirt          = $F9DD = 63965  _BSS        nabu_fdc.asm:32
nf_dpb           = $F712 = 63250  _TEXT       nabu_fdc.asm:76
nf_dpha          = $F6F2 = 63218  _TEXT       nabu_fdc.asm:60
nf_dphb          = $F702 = 63234  _TEXT       nabu_fdc.asm:68
nf_dvsc          = $F92A = 63786  _TEXT       nabu_fdc.asm:516
nf_dvsl          = $F930 = 63792  _TEXT       nabu_fdc.asm:519
nf_eint          = $F955 = 63829  _TEXT       nabu_fdc.asm:560
nf_grb           = $F8BF = 63679  _TEXT       nabu_fdc.asm:426 (unused)
nf_home          = $F764 = 63332  _TEXT       nabu_fdc.asm:150
nf_inco          = $F9DC = 63964  _BSS        nabu_fdc.asm:31
nf_ini1          = $F73F = 63295  _TEXT       nabu_fdc.asm:114
nf_ini2          = $F74D = 63309  _TEXT       nabu_fdc.asm:125
nf_init          = $F739 = 63289  _TEXT       nabu_fdc.asm:109
nf_io            = $F9D7 = 63959  _BSS        nabu_fdc.asm:25
nf_r2k           = $F8CB = 63691  _TEXT       nabu_fdc.asm:436
nf_r2k0          = $F8F4 = 63732  _TEXT       nabu_fdc.asm:465
nf_r2ks          = $F9D8 = 63960  _BSS        nabu_fdc.asm:26
nf_rdsk          = $0002 =     2  _TEXT       nabu_fdc.asm:45
nf_rdw0          = $F844 = 63556  _TEXT       nabu_fdc.asm:325
nf_rdw1          = $F852 = 63570  _TEXT       nabu_fdc.asm:332
nf_rdwr          = $F825 = 63525  _TEXT       nabu_fdc.asm:304
nf_read          = $F857 = 63575  _TEXT       nabu_fdc.asm:338
nf_rph1          = $F914 = 63764  _TEXT       nabu_fdc.asm:498
nf_rph2          = $F922 = 63778  _TEXT       nabu_fdc.asm:507
nf_rphy          = $F908 = 63752  _TEXT       nabu_fdc.asm:488
nf_sel           = $F77C = 63356  _TEXT       nabu_fdc.asm:173
nf_sel0          = $F796 = 63382  _TEXT       nabu_fdc.asm:192
nf_sel1          = $F7B0 = 63408  _TEXT       nabu_fdc.asm:206
nf_sel2          = $F7C2 = 63426  _TEXT       nabu_fdc.asm:219
nf_selc          = $F7A3 = 63395  _TEXT       nabu_fdc.asm:200 (unused)
nf_seld          = $F787 = 63367  _TEXT       nabu_fdc.asm:181
nf_ssec          = $F806 = 63494  _TEXT       nabu_fdc.asm:277
nf_stal          = $F947 = 63815  _TEXT       nabu_fdc.asm:543
nf_str0          = $F7E9 = 63465  _TEXT       nabu_fdc.asm:251
nf_strk          = $F7D0 = 63440  _TEXT       nabu_fdc.asm:232
nf_subs          = $F9DA = 63962  _BSS        nabu_fdc.asm:29
nf_sync          = $F9DB = 63963  _BSS        nabu_fdc.asm:30
nf_udsl          = $F92F = 63791  _TEXT       nabu_fdc.asm:518
nf_wde1          = $F895 = 63637  _TEXT       nabu_fdc.asm:388
nf_wde2          = $F8A3 = 63651  _TEXT       nabu_fdc.asm:397
nf_wde3          = $F8B7 = 63671  _TEXT       nabu_fdc.asm:417
nf_wde4          = $F8BA = 63674  _TEXT       nabu_fdc.asm:420
nf_wdef          = $F877 = 63607  _TEXT       nabu_fdc.asm:368
nf_writ          = $F85F = 63583  _TEXT       nabu_fdc.asm:346
nfddev           = $F721 = 63265  _TEXT       nabu_fdc.asm:93
nfsdev           = $EF96 = 61334  _TEXT       nabu_nfs.asm:73
nfuncts          = $0029 =    41  _TEXT       bdos.asm:74
ns_ace0          = $F21A = 61978  _TEXT       nabu_nfs.asm:594
ns_ace1          = $F226 = 61990  _TEXT       nabu_nfs.asm:604
ns_aces          = $F207 = 61959  _TEXT       nabu_nfs.asm:581
ns_alv           = $EF95 = 61333  _TEXT       nabu_nfs.asm:67
ns_atla          = $0041 =    65  _TEXT       nabu_nfs.asm:31
ns_ayda          = $0040 =    64  _TEXT       nabu_nfs.asm:30
ns_buff          = $F98A = 63882  _BSS        nabu_nfs.asm:20
ns_ccp           = $EFFA = 61434  _TEXT       nabu_nfs.asm:165
ns_cfcb          = $F9D2 = 63954  _BSS        nabu_nfs.asm:24
ns_deco          = $F300 = 62208  _TEXT       nabu_nfs.asm:816
ns_del0          = $F1E3 = 61923  _TEXT       nabu_nfs.asm:552
ns_dele          = $F1D0 = 61904  _TEXT       nabu_nfs.asm:536
ns_dfl0          = $EFE1 = 61409  _TEXT       nabu_nfs.asm:141
ns_dflt          = $EFD9 = 61401  _TEXT       nabu_nfs.asm:136
ns_dom0          = $F3A1 = 62369  _TEXT       nabu_nfs.asm:959
ns_domk          = $F39D = 62365  _TEXT       nabu_nfs.asm:957
ns_dore          = $F9D4 = 63956  _BSS        nabu_nfs.asm:25
ns_dpb           = $EF86 = 61318  _TEXT       nabu_nfs.asm:55
ns_dph           = $EF76 = 61302  _TEXT       nabu_nfs.asm:47
ns_dsnd          = $EFF0 = 61424  _TEXT       nabu_nfs.asm:158
ns_esnd          = $EFE6 = 61414  _TEXT       nabu_nfs.asm:149
ns_exit          = $F3D1 = 62417  _TEXT       nabu_nfs.asm:996
ns_fcls          = $F0AA = 61610  _TEXT       nabu_nfs.asm:295
ns_ffm0          = $F177 = 61815  _TEXT       nabu_nfs.asm:457
ns_ffm1          = $F17A = 61818  _TEXT       nabu_nfs.asm:459
ns_ffmt          = $F16C = 61804  _TEXT       nabu_nfs.asm:451
ns_fild          = $0081 =   129  _TEXT       nabu_nfs.asm:35
ns_find          = $F100 = 61696  _TEXT       nabu_nfs.asm:357
ns_fmak          = $F308 = 62216  _TEXT       nabu_nfs.asm:828
ns_fop0          = $F0A7 = 61607  _TEXT       nabu_nfs.asm:287
ns_fopn          = $F06A = 61546  _TEXT       nabu_nfs.asm:238
ns_for1          = $F534 = 62772  _TEXT       nabu_nfs.asm:1269
ns_for2          = $F544 = 62788  _TEXT       nabu_nfs.asm:1277
ns_for3          = $F54F = 62799  _TEXT       nabu_nfs.asm:1283
ns_for4          = $F55F = 62815  _TEXT       nabu_nfs.asm:1291
ns_form          = $F52A = 62762  _TEXT       nabu_nfs.asm:1265
ns_fre0          = $F294 = 62100  _TEXT       nabu_nfs.asm:704
ns_fre1          = $F29C = 62108  _TEXT       nabu_nfs.asm:710
ns_fre2          = $F2AF = 62127  _TEXT       nabu_nfs.asm:725
ns_frea          = $F289 = 62089  _TEXT       nabu_nfs.asm:693
ns_frn0          = $F34F = 62287  _TEXT       nabu_nfs.asm:888
ns_frnm          = $F32F = 62255  _TEXT       nabu_nfs.asm:864
ns_fwr0          = $F2C0 = 62144  _TEXT       nabu_nfs.asm:745
ns_fwri          = $F2B5 = 62133  _TEXT       nabu_nfs.asm:734
ns_gcre          = $F24E = 62030  _TEXT       nabu_nfs.asm:637
ns_get0          = $F403 = 62467  _TEXT       nabu_nfs.asm:1041
ns_get1          = $F42C = 62508  _TEXT       nabu_nfs.asm:1063
ns_get2          = $F436 = 62518  _TEXT       nabu_nfs.asm:1070
ns_getb          = $F3FD = 62461  _TEXT       nabu_nfs.asm:1039
ns_getd          = $F3D4 = 62420  _TEXT       nabu_nfs.asm:1005
ns_grb           = $EFFF = 61439  _TEXT       nabu_nfs.asm:169
ns_grb0          = $F002 = 61442  _TEXT       nabu_nfs.asm:170
ns_grb1          = $F019 = 61465  _TEXT       nabu_nfs.asm:178
ns_hcca          = $0080 =   128  _TEXT       nabu_nfs.asm:32
ns_hcer          = $F4B5 = 62645  _TEXT       nabu_nfs.asm:1172
ns_hcr0          = $F4A2 = 62626  _TEXT       nabu_nfs.asm:1157
ns_hcr1          = $F4BC = 62652  _TEXT       nabu_nfs.asm:1177
ns_hcr2          = $F4C5 = 62661  _TEXT       nabu_nfs.asm:1183
ns_hcrd          = $F493 = 62611  _TEXT       nabu_nfs.asm:1150
ns_hcre          = $F496 = 62614  _TEXT       nabu_nfs.asm:1151
ns_hcw0          = $F4F2 = 62706  _TEXT       nabu_nfs.asm:1220
ns_hcw1          = $F50A = 62730  _TEXT       nabu_nfs.asm:1237
ns_hcw2          = $F50F = 62735  _TEXT       nabu_nfs.asm:1239
ns_hcwr          = $F4E0 = 62688  _TEXT       nabu_nfs.asm:1212
ns_hini          = $EFBF = 61375  _TEXT       nabu_nfs.asm:118
ns_inb           = $F58D = 62861  _TEXT       nabu_nfs.asm:1354
ns_inf           = $F58E = 62862  _TEXT       nabu_nfs.asm:1357
ns_init          = $EFA0 = 61344  _TEXT       nabu_nfs.asm:87
ns_isls          = $F9D5 = 63957  _BSS        nabu_nfs.asm:26
ns_lis0          = $F109 = 61705  _TEXT       nabu_nfs.asm:371
ns_lis1          = $F137 = 61751  _TEXT       nabu_nfs.asm:397
ns_lis2          = $F140 = 61760  _TEXT       nabu_nfs.asm:405
ns_lis3          = $F14D = 61773  _TEXT       nabu_nfs.asm:413
ns_lis4          = $F158 = 61784  _TEXT       nabu_nfs.asm:421
ns_list          = $F103 = 61699  _TEXT       nabu_nfs.asm:367
ns_ltou          = $F575 = 62837  _TEXT       nabu_nfs.asm:1326
ns_m0            = $F5A9 = 62889  _TEXT       nabu_nfs.asm:1369
ns_m0fl          = $F5AF = 62895  _TEXT       nabu_nfs.asm:1373
ns_m0na          = $F5B2 = 62898  _TEXT       nabu_nfs.asm:1375
ns_m1            = $F5C6 = 62918  _TEXT       nabu_nfs.asm:1380
ns_m2            = $F5CC = 62924  _TEXT       nabu_nfs.asm:1387
ns_m2bn          = $F5D2 = 62930  _TEXT       nabu_nfs.asm:1391
ns_m3            = $F5D8 = 62936  _TEXT       nabu_nfs.asm:1396
ns_m3bn          = $F5DE = 62942  _TEXT       nabu_nfs.asm:1400
ns_m4            = $F5E4 = 62948  _TEXT       nabu_nfs.asm:1405
ns_m5            = $F5EB = 62955  _TEXT       nabu_nfs.asm:1413
ns_m6            = $F5F2 = 62962  _TEXT       nabu_nfs.asm:1421
ns_m6na          = $F5FA = 62970  _TEXT       nabu_nfs.asm:1426
ns_m7            = $F60D = 62989  _TEXT       nabu_nfs.asm:1430
ns_m7n0          = $F613 = 62995  _TEXT       nabu_nfs.asm:1434
ns_m7n1          = $F627 = 63015  _TEXT       nabu_nfs.asm:1436
ns_mask          = $F9D0 = 63952  _BSS        nabu_nfs.asm:23
ns_name          = $F9C5 = 63941  _BSS        nabu_nfs.asm:22
ns_nblk          = $F38B = 62347  _TEXT       nabu_nfs.asm:938
ns_nctl          = $0000 =     0  _TEXT       nabu_nfs.asm:33
ns_opef          = $F3DE = 62430  _TEXT       nabu_nfs.asm:1018
ns_open          = $F3DB = 62427  _TEXT       nabu_nfs.asm:1017
ns_outb          = $F58B = 62859  _TEXT       nabu_nfs.asm:1348
ns_outf          = $F58C = 62860  _TEXT       nabu_nfs.asm:1351
ns_own0          = $F3B9 = 62393  _TEXT       nabu_nfs.asm:981
ns_own1          = $F3C5 = 62405  _TEXT       nabu_nfs.asm:986
ns_own2          = $F3CB = 62411  _TEXT       nabu_nfs.asm:990
ns_ownr          = $F3A9 = 62377  _TEXT       nabu_nfs.asm:972
ns_p0            = $F58F = 62863  _TEXT       nabu_nfs.asm:1361
ns_p1            = $F59C = 62876  _TEXT       nabu_nfs.asm:1365
ns_ptrn          = $F9BA = 63930  _BSS        nabu_nfs.asm:21
ns_put0          = $F444 = 62532  _TEXT       nabu_nfs.asm:1084
ns_put1          = $F456 = 62550  _TEXT       nabu_nfs.asm:1094
ns_putb          = $F43E = 62526  _TEXT       nabu_nfs.asm:1082
ns_rec0          = $F475 = 62581  _TEXT       nabu_nfs.asm:1115
ns_rec1          = $F480 = 62592  _TEXT       nabu_nfs.asm:1122
ns_rece          = $F46C = 62572  _TEXT       nabu_nfs.asm:1112
ns_rirq          = $F4D2 = 62674  _TEXT       nabu_nfs.asm:1195
ns_rrea          = $F2CF = 62159  _TEXT       nabu_nfs.asm:759
ns_rrec          = $F2ED = 62189  _TEXT       nabu_nfs.asm:794
ns_rwri          = $F2DE = 62174  _TEXT       nabu_nfs.asm:777
ns_scre          = $F26A = 62058  _TEXT       nabu_nfs.asm:664
ns_sdir          = $F562 = 62818  _TEXT       nabu_nfs.asm:1301
ns_sel           = $EFB1 = 61361  _TEXT       nabu_nfs.asm:105
ns_send          = $F48A = 62602  _TEXT       nabu_nfs.asm:1136
ns_sfir          = $F15B = 61787  _TEXT       nabu_nfs.asm:429
ns_size          = $F373 = 62323  _TEXT       nabu_nfs.asm:912
ns_sls0          = $F0F7 = 61687  _TEXT       nabu_nfs.asm:343
ns_slst          = $F0BC = 61628  _TEXT       nabu_nfs.asm:314
ns_snx0          = $F188 = 61832  _TEXT       nabu_nfs.asm:477
ns_snx1          = $F1B4 = 61876  _TEXT       nabu_nfs.asm:509
ns_snx2          = $F1B8 = 61880  _TEXT       nabu_nfs.asm:512
ns_snx3          = $F1BF = 61887  _TEXT       nabu_nfs.asm:519
ns_snx4          = $F1C5 = 61893  _TEXT       nabu_nfs.asm:524
ns_snxt          = $F180 = 61824  _TEXT       nabu_nfs.asm:469
ns_stmp          = $F064 = 61540  _TEXT       nabu_nfs.asm:227
ns_sysh          = $F023 = 61475  _TEXT       nabu_nfs.asm:189
ns_tran          = $F9D6 = 63958  _BSS        nabu_nfs.asm:27
ns_utol          = $F580 = 62848  _TEXT       nabu_nfs.asm:1339
ns_wchd          = $F572 = 62834  _TEXT       nabu_nfs.asm:1317
ns_wirq          = $F519 = 62745  _TEXT       nabu_nfs.asm:1248
nulldev          = $EB49 = 60233  _TEXT       bios.asm:328 (unused)
nxent1           = $E219 = 57881  _TEXT       bdos.asm:1084
nxent2           = $E220 = 57888  _TEXT       bdos.asm:1087
nxentry          = $E205 = 57861  _TEXT       bdos.asm:1076
offset           = $E9CE = 59854  _TEXT       bdos.asm:2468
olddrv           = $E9DF = 59871  _TEXT       bdos.asm:2482
openfil          = $E89C = 59548  _TEXT       bdos.asm:2237
openit           = $E451 = 58449  _TEXT       bdos.asm:1529
openit1          = $E45A = 58458  _TEXT       bdos.asm:1533
openit2          = $E48B = 58507  _TEXT       bdos.asm:1561
outchar          = $DD48 = 56648  _TEXT       bdos.asm:184
outchr1          = $DD62 = 56674  _TEXT       bdos.asm:198
outchr2          = $DD79 = 56697  _TEXT       bdos.asm:214
outcon           = $DD90 = 56720  _TEXT       bdos.asm:235
outcon1          = $DD96 = 56726  _TEXT       bdos.asm:238
outcrlf          = $DDC9 = 56777  _TEXT       bdos.asm:271
outflag          = $DF0A = 57098  _TEXT       bdos.asm:474
params           = $DF43 = 57155  _TEXT       bdos.asm:490
pattrn2          = $DC00 = 56320  _TEXT       bdos.asm:21 (unused)
position         = $E703 = 59139  _TEXT       bdos.asm:1939
positn1          = $E707 = 59143  _TEXT       bdos.asm:1944
positn2          = $E747 = 59207  _TEXT       bdos.asm:1990
positn3          = $E77F = 59263  _TEXT       bdos.asm:2022
positn4          = $E784 = 59268  _TEXT       bdos.asm:2028
positn5          = $E78B = 59275  _TEXT       bdos.asm:2035
pr_atla          = $0041 =    65  _TEXT       nabu_prt.asm:14
pr_ayda          = $0040 =    64  _TEXT       nabu_prt.asm:13
pr_ctrl          = $0000 =     0  _TEXT       nabu_prt.asm:16
pr_init          = $F645 = 63045  _TEXT       nabu_prt.asm:31
pr_prnt          = $00B0 =   176  _TEXT       nabu_prt.asm:15
pr_read          = $F648 = 63048  _TEXT       nabu_prt.asm:46
pr_stat          = $F646 = 63046  _TEXT       nabu_prt.asm:38
pr_wri0          = $F64E = 63054  _TEXT       nabu_prt.asm:56
pr_wri1          = $F65D = 63069  _TEXT       nabu_prt.asm:67
pr_writ          = $F64A = 63050  _TEXT       nabu_prt.asm:53
prstat           = $EB12 = 60178  _TEXT       bios.asm:276
prtdev           = $F63A = 63034  _TEXT       nabu_prt.asm:19
prterr           = $DCE5 = 56549  _TEXT       bdos.asm:111
prtflag          = $DF0D = 57101  _TEXT       bdos.asm:477
prtmesg          = $DDD3 = 56787  _TEXT       bdos.asm:278
prtstr           = $DEF8 = 57080  _TEXT       bdos.asm:454
punch            = $EAC7 = 60103  _TEXT       bios.asm:187
putdma           = $E90A = 59658  _TEXT       bdos.asm:2313
ransiz1          = $E7E4 = 59364  _TEXT       bdos.asm:2118
ransiz2          = $E806 = 59398  _TEXT       bdos.asm:2140
ransiz3          = $E80C = 59404  _TEXT       bdos.asm:2142
ransize          = $E7D2 = 59346  _TEXT       bdos.asm:2107
rdbuf1           = $DDEF = 56815  _TEXT       bdos.asm:297
rdbuf10          = $DE70 = 56944  _TEXT       bdos.asm:359
rdbuf11          = $DE78 = 56952  _TEXT       bdos.asm:365
rdbuf12          = $DE8A = 56970  _TEXT       bdos.asm:377
rdbuf13          = $DE99 = 56985  _TEXT       bdos.asm:384
rdbuf14          = $DEA6 = 56998  _TEXT       bdos.asm:392
rdbuf15          = $DEA9 = 57001  _TEXT       bdos.asm:395
rdbuf16          = $DEBD = 57021  _TEXT       bdos.asm:407
rdbuf17          = $DEC1 = 57025  _TEXT       bdos.asm:409
rdbuf2           = $DDF1 = 56817  _TEXT       bdos.asm:299
rdbuf3           = $DE16 = 56854  _TEXT       bdos.asm:316
rdbuf4           = $DE26 = 56870  _TEXT       bdos.asm:325
rdbuf5           = $DE37 = 56887  _TEXT       bdos.asm:333
rdbuf6           = $DE48 = 56904  _TEXT       bdos.asm:342
rdbuf7           = $DE4E = 56910  _TEXT       bdos.asm:345
rdbuf8           = $DE5F = 56927  _TEXT       bdos.asm:352
rdbuf9           = $DE6B = 56939  _TEXT       bdos.asm:357
rdbuff           = $DDE1 = 56801  _TEXT       bdos.asm:290
rdrandom         = $E941 = 59713  _TEXT       bdos.asm:2355
rdseq            = $E5BC = 58812  _TEXT       bdos.asm:1748
rdseq1           = $E5C1 = 58817  _TEXT       bdos.asm:1750
rdseq2           = $E5E6 = 58854  _TEXT       bdos.asm:1765
rdseq3           = $E5FB = 58875  _TEXT       bdos.asm:1775
rdwrtflg         = $E9D3 = 59859  _TEXT       bdos.asm:2473
read             = $EB0A = 60170  _TEXT       bios.asm:261
reader           = $EACB = 60107  _TEXT       bios.asm:193
readran          = $E793 = 59283  _TEXT       bdos.asm:2042
readseq          = $E8E0 = 59616  _TEXT       bdos.asm:2281
relblock         = $E9D7 = 59863  _TEXT       bdos.asm:2477
renfile          = $E8F5 = 59637  _TEXT       bdos.asm:2297
resccp           = $EB6A = 60266  _TEXT       config_nfs_hybrid.asm:151
resgrb           = $EB6D = 60269  _TEXT       config_nfs_hybrid.asm:157
rodisk           = $DC0D = 56333  _TEXT       bdos.asm:35
rofile           = $DC0F = 56335  _TEXT       bdos.asm:36
rstdsk           = $E883 = 59523  _TEXT       bdos.asm:2225
rtn              = $DF04 = 57092  _TEXT       bdos.asm:467
samext           = $E307 = 58119  _TEXT       bdos.asm:1279
savatr1          = $E440 = 58432  _TEXT       bdos.asm:1519
saveattr         = $E43B = 58427  _TEXT       bdos.asm:1517
savefcb          = $E9D9 = 59865  _TEXT       bdos.asm:2479
savext           = $E9E2 = 59874  _TEXT       bdos.asm:2485
savnrec          = $E9E3 = 59875  _TEXT       bdos.asm:2486
savnxt           = $E9E1 = 59873  _TEXT       bdos.asm:2484
scratch1         = $E9B3 = 59827  _TEXT       bdos.asm:2447
scratch2         = $E9B5 = 59829  _TEXT       bdos.asm:2448
scratch3         = $E9B7 = 59831  _TEXT       bdos.asm:2449
sectors          = $E9C1 = 59841  _TEXT       bdos.asm:2460
sectrn           = $EB15 = 60181  _TEXT       bios.asm:281
seldsk           = $EADE = 60126  _TEXT       bios.asm:213
select           = $DF59 = 57177  _TEXT       bdos.asm:518
select1          = $DF9D = 57245  _TEXT       bdos.asm:558
setattr          = $E91D = 59677  _TEXT       bdos.asm:2329
setbit           = $E10B = 57611  _TEXT       bdos.asm:850
setdir           = $E19C = 57756  _TEXT       bdos.asm:984
setdma           = $EB04 = 60164  _TEXT       bios.asm:253
setdsk           = $E845 = 59461  _TEXT       bdos.asm:2185
setext           = $E0A6 = 57510  _TEXT       bdos.asm:765
setfile          = $E26B = 57963  _TEXT       bdos.asm:1169
setfl1           = $E275 = 57973  _TEXT       bdos.asm:1174
setfl2           = $E288 = 57992  _TEXT       bdos.asm:1186
setfl3           = $E28E = 57998  _TEXT       bdos.asm:1192
setfl4           = $E29D = 58013  _TEXT       bdos.asm:1201
sethlde          = $E0AE = 57518  _TEXT       bdos.asm:773
setiob           = $DEF3 = 57075  _TEXT       bdos.asm:447
setnrec          = $E0D2 = 57554  _TEXT       bdos.asm:799
setran           = $E80E = 59406  _TEXT       bdos.asm:2148
sets2b7          = $E178 = 57720  _TEXT       bdos.asm:941
setsec           = $EB00 = 60160  _TEXT       bios.asm:246
setstat          = $DF01 = 57089  _TEXT       bdos.asm:466
settrk           = $EAFC = 60156  _TEXT       bios.asm:239
setuser          = $E93B = 59707  _TEXT       bdos.asm:2349
shiftl           = $E104 = 57604  _TEXT       bdos.asm:841
shiftl1          = $E105 = 57605  _TEXT       bdos.asm:842
shiftr           = $E0EA = 57578  _TEXT       bdos.asm:815
shiftr1          = $E0EB = 57579  _TEXT       bdos.asm:816
showit           = $DD7F = 56703  _TEXT       bdos.asm:222
siodev           = $F664 = 63076  _TEXT       nabu_sio.asm:20
slcterr          = $DF47 = 57159  _TEXT       bdos.asm:495
so_atab          = $F6D4 = 63188  _TEXT       nabu_sio.asm:131
so_conf          = $F6D8 = 63192  _TEXT       nabu_sio.asm:135
so_ini0          = $F677 = 63095  _TEXT       nabu_sio.asm:39
so_ini1          = $F67D = 63101  _TEXT       nabu_sio.asm:43
so_ini2          = $F684 = 63108  _TEXT       nabu_sio.asm:49
so_ini3          = $F690 = 63120  _TEXT       nabu_sio.asm:59
so_init          = $F66F = 63087  _TEXT       nabu_sio.asm:33
so_rea0          = $F6B7 = 63159  _TEXT       nabu_sio.asm:102
so_read          = $F6AE = 63150  _TEXT       nabu_sio.asm:95
so_sta0          = $F6A6 = 63142  _TEXT       nabu_sio.asm:83
so_stat          = $F69D = 63133  _TEXT       nabu_sio.asm:76
so_wri0          = $F6CA = 63178  _TEXT       nabu_sio.asm:121
so_writ          = $F6C0 = 63168  _TEXT       nabu_sio.asm:113
starting         = $DF0B = 57099  _TEXT       bdos.asm:475
status           = $DF45 = 57157  _TEXT       bdos.asm:491
stbitmap         = $E25C = 57948  _TEXT       bdos.asm:1149
stbmap1          = $E264 = 57956  _TEXT       bdos.asm:1160
stfilpos         = $E1FE = 57854  _TEXT       bdos.asm:1064
stkarea          = $DF41 = 57153  _TEXT       bdos.asm:486
stnrec1          = $E0DE = 57566  _TEXT       bdos.asm:804
strdata          = $E0BB = 57531  _TEXT       bdos.asm:783
ststatus         = $E301 = 58113  _TEXT       bdos.asm:1271
subhl            = $E195 = 57749  _TEXT       bdos.asm:974
swindi0          = $EB31 = 60209  _TEXT       bios.asm:311
swindi1          = $EB37 = 60215  _TEXT       bios.asm:315
swindir          = $EB2D = 60205  _TEXT       bios.asm:309
syshook          = $EB67 = 60263  _TEXT       config_nfs_hybrid.asm:129
tab              = $0009 =     9  _TEXT       zcpr1_ccp_nfs.asm:25
tbase            = $0100 =   256  _TEXT       zcpr1_ccp_nfs.asm:18 (unused)
tbuff            = $0080 =   128  _TEXT       zcpr1_ccp_nfs.asm:17
tdrive           = $0004 =     4  _TEXT       zcpr1_ccp_nfs.asm:10
tfcb             = $005C =    92  _TEXT       zcpr1_ccp_nfs.asm:14 (unused)
tm_40c           = $EDFB = 60923  _TEXT       nabu_vdp.asm:464
tm_80c           = $EE08 = 60936  _TEXT       nabu_vdp.asm:471
tm_addh          = $EF40 = 61248  _TEXT       nabu_vdp.asm:729
tm_addr          = $EF42 = 61250  _TEXT       nabu_vdp.asm:731
tm_ayda          = $0040 =    64  _TEXT       nabu_vdp.asm:36
tm_ayla          = $0041 =    65  _TEXT       nabu_vdp.asm:37
tm_bell          = $EE1B = 60955  _TEXT       nabu_vdp.asm:486
tm_bs            = $ED4C = 60748  _TEXT       nabu_vdp.asm:348
tm_cbuf          = $F962 = 63842  _BSS        nabu_vdp.asm:26
tm_cha0          = $EEE4 = 61156  _TEXT       nabu_vdp.asm:652
tm_chat          = $EEDE = 61150  _TEXT       nabu_vdp.asm:647
tm_cle0          = $EDE7 = 60903  _TEXT       nabu_vdp.asm:449
tm_clea          = $EDD8 = 60888  _TEXT       nabu_vdp.asm:440
tm_cles          = $EDD6 = 60886  _TEXT       nabu_vdp.asm:439
tm_cloc          = $EC5D = 60509  _TEXT       nabu_vdp.asm:172
tm_cls           = $EF25 = 61221  _TEXT       nabu_vdp.asm:706
tm_cls0          = $EF2E = 61230  _TEXT       nabu_vdp.asm:709
tm_cold          = $EF75 = 61301  _TEXT       nabu_vdp.asm:776
tm_colr          = $EF70 = 61296  _TEXT       nabu_vdp.asm:771
tm_cr            = $ED49 = 60745  _TEXT       nabu_vdp.asm:345
tm_cshm          = $ED5B = 60763  _TEXT       nabu_vdp.asm:362
tm_cupd          = $EDFF = 60927  _TEXT       nabu_vdp.asm:466
tm_curx          = $EF73 = 61299  _TEXT       nabu_vdp.asm:774
tm_cury          = $EF74 = 61300  _TEXT       nabu_vdp.asm:775
tm_data          = $00A0 =   160  _TEXT       nabu_vdp.asm:30
tm_dint          = $EF53 = 61267  _TEXT       nabu_vdp.asm:750
tm_dsc0          = $EE4F = 61007  _TEXT       nabu_vdp.asm:517
tm_dsco          = $EE3C = 60988  _TEXT       nabu_vdp.asm:510
tm_eint          = $EF63 = 61283  _TEXT       nabu_vdp.asm:762
tm_esc           = $ED95 = 60821  _TEXT       nabu_vdp.asm:396
tm_esc0          = $EDA6 = 60838  _TEXT       nabu_vdp.asm:407
tm_esc1          = $EDC0 = 60864  _TEXT       nabu_vdp.asm:422
tm_esc2          = $EDCB = 60875  _TEXT       nabu_vdp.asm:429
tm_escd          = $EDA1 = 60833  _TEXT       nabu_vdp.asm:404
tm_esci          = $EDBA = 60858  _TEXT       nabu_vdp.asm:419
tm_escr          = $EDA2 = 60834  _TEXT       nabu_vdp.asm:405
tm_escs          = $F960 = 63840  _BSS        nabu_vdp.asm:24
tm_get0          = $EE78 = 61048  _TEXT       nabu_vdp.asm:552
tm_getc          = $EE62 = 61026  _TEXT       nabu_vdp.asm:538
tm_home          = $ED5E = 60766  _TEXT       nabu_vdp.asm:363
tm_inb           = $EF71 = 61297  _TEXT       nabu_vdp.asm:772
tm_inf           = $EF72 = 61298  _TEXT       nabu_vdp.asm:773
tm_ini0          = $EC30 = 60464  _TEXT       nabu_vdp.asm:140
tm_ini1          = $EC50 = 60496  _TEXT       nabu_vdp.asm:161
tm_inir          = $EBD6 = 60374  _TEXT       nabu_vdp.asm:79
tm_init          = $EC08 = 60424  _TEXT       nabu_vdp.asm:116
tm_inr0          = $EBD7 = 60375  _TEXT       nabu_vdp.asm:80
tm_keyd          = $0090 =   144  _TEXT       nabu_vdp.asm:33
tm_keys          = $0091 =   145  _TEXT       nabu_vdp.asm:34
tm_kirq          = $EE80 = 61056  _TEXT       nabu_vdp.asm:561
tm_last          = $F961 = 63841  _BSS        nabu_vdp.asm:25
tm_latc          = $00A1 =   161  _TEXT       nabu_vdp.asm:31
tm_lf            = $ED3D = 60733  _TEXT       nabu_vdp.asm:336
tm_map           = $EE8E = 61070  _TEXT       nabu_vdp.asm:576
tm_map0          = $EE92 = 61074  _TEXT       nabu_vdp.asm:580
tm_map2          = $EE9E = 61086  _TEXT       nabu_vdp.asm:593
tm_mapt          = $EEA5 = 61093  _TEXT       nabu_vdp.asm:600
tm_mode          = $EF6E = 61294  _TEXT       nabu_vdp.asm:770
tm_oti0          = $EBCE = 60366  _TEXT       nabu_vdp.asm:66
tm_otir          = $EBCD = 60365  _TEXT       nabu_vdp.asm:65
tm_outc          = $F95E = 63838  _BSS        nabu_vdp.asm:22
tm_putc          = $EEBA = 61114  _TEXT       nabu_vdp.asm:618
tm_putf          = $EEC8 = 61128  _TEXT       nabu_vdp.asm:626 (unused)
tm_rea0          = $ECB6 = 60598  _TEXT       nabu_vdp.asm:237
tm_rea1          = $ECCC = 60620  _TEXT       nabu_vdp.asm:249
tm_rea2          = $ECE1 = 60641  _TEXT       nabu_vdp.asm:262
tm_rea3          = $ECF1 = 60657  _TEXT       nabu_vdp.asm:272
tm_read          = $ECAA = 60586  _TEXT       nabu_vdp.asm:231
tm_ri            = $ED36 = 60726  _TEXT       nabu_vdp.asm:330
tm_sclf          = $EC75 = 60533  _TEXT       nabu_vdp.asm:188
tm_scol          = $EE0E = 60942  _TEXT       nabu_vdp.asm:476
tm_scr0          = $EC6D = 60525  _TEXT       nabu_vdp.asm:185
tm_scr1          = $EC73 = 60531  _TEXT       nabu_vdp.asm:187
tm_scri          = $EC63 = 60515  _TEXT       nabu_vdp.asm:180
tm_scro          = $F95F = 63839  _BSS        nabu_vdp.asm:23
tm_setp          = $EC7F = 60543  _TEXT       nabu_vdp.asm:198
tm_sta0          = $EBEB = 60395  _TEXT       nabu_vdp.asm:98
tm_sta1          = $EBF6 = 60406  _TEXT       nabu_vdp.asm:103
tm_sta2          = $ED02 = 60674  _TEXT       nabu_vdp.asm:286
tm_stal          = $ECFF = 60671  _TEXT       nabu_vdp.asm:284
tm_stat          = $EBDF = 60383  _TEXT       nabu_vdp.asm:92
tm_up            = $ED56 = 60758  _TEXT       nabu_vdp.asm:357
tm_updc          = $EE12 = 60946  _TEXT       nabu_vdp.asm:480
tm_usc0          = $EF11 = 61201  _TEXT       nabu_vdp.asm:685
tm_usco          = $EF02 = 61186  _TEXT       nabu_vdp.asm:678
tm_vcpy          = $EEEA = 61162  _TEXT       nabu_vdp.asm:664
tm_virq          = $EF4D = 61261  _TEXT       nabu_vdp.asm:740
tm_wri0          = $ED23 = 60707  _TEXT       nabu_vdp.asm:318
tm_wri1          = $ED62 = 60770  _TEXT       nabu_vdp.asm:368
tm_writ          = $ED08 = 60680  _TEXT       nabu_vdp.asm:298
trksec           = $DFC3 = 57283  _TEXT       bdos.asm:592
trksec1          = $DFD1 = 57297  _TEXT       bdos.asm:601
trksec2          = $DFE4 = 57316  _TEXT       bdos.asm:614
trksec3          = $DFFA = 57338  _TEXT       bdos.asm:630
trksec4          = $E00F = 57359  _TEXT       bdos.asm:647
update           = $E401 = 58369  _TEXT       bdos.asm:1480
update1          = $E410 = 58384  _TEXT       bdos.asm:1488
userdma          = $E9B1 = 59825  _TEXT       bdos.asm:2443
userno           = $DF41 = 57153  _TEXT       bdos.asm:488
usrstack         = $DF0F = 57103  _TEXT       bdos.asm:482
vdpdev           = $EBC0 = 60352  _TEXT       nabu_vdp.asm:51
wbinit           = $EB4F = 60239  _TEXT       config_nfs_hybrid.asm:67
wboot            = $EA46 = 59974  _TEXT       bios.asm:62
wboot0           = $EA6D = 60013  _TEXT       bios.asm:99
wbootin          = $EA03 = 59907  _TEXT       bios.asm:22
wbootr           = $EA5D = 59997  _TEXT       bios.asm:87
write            = $EB0E = 60174  _TEXT       bios.asm:268
writeran         = $E79C = 59292  _TEXT       bdos.asm:2049
wrtprt           = $E9AD = 59821  _TEXT       bdos.asm:2441
wrtprtd          = $E12C = 57644  _TEXT       bdos.asm:877
wrtseq           = $E8E6 = 59622  _TEXT       bdos.asm:2286
wtrandom         = $E947 = 59719  _TEXT       bdos.asm:2360
wtseq            = $E5FE = 58878  _TEXT       bdos.asm:1779
wtseq1           = $E603 = 58883  _TEXT       bdos.asm:1781
wtseq10          = $E6D2 = 59090  _TEXT       bdos.asm:1896
wtseq11          = $E6FE = 59134  _TEXT       bdos.asm:1920
wtseq12          = $E700 = 59136  _TEXT       bdos.asm:1921
wtseq2           = $E63B = 58939  _TEXT       bdos.asm:1804
wtseq3           = $E648 = 58952  _TEXT       bdos.asm:1810
wtseq4           = $E664 = 58980  _TEXT       bdos.asm:1822
wtseq5           = $E66C = 58988  _TEXT       bdos.asm:1829
wtseq6           = $E66E = 58990  _TEXT       bdos.asm:1830
wtseq7           = $E68C = 59020  _TEXT       bdos.asm:1853
wtseq8           = $E69A = 59034  _TEXT       bdos.asm:1860
wtseq9           = $E6BB = 59067  _TEXT       bdos.asm:1880
wtseq99          = $E6DF = 59103  _TEXT       bdos.asm:1907 (unused)
wtspecl          = $E99B = 59803  _TEXT       bdos.asm:2426
xlate            = $E9D0 = 59856  _TEXT       bdos.asm:2469


total time: 0.0870 sec.
no errors
